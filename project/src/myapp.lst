# file opened: /Users/darren/dev/spectrum/zx/project/src/myapp.asm
  1   0000              ; *********************************************************************************************************************
  2   0000              ; Author:  Darren Bowles
  3   0000              ; Date:    2020-05-03
  4   0000              ; Purpose: This is just a test to help me learn coding Z80 on a ZX Spectrum
  5   0000              ; shout out to Jonathan Cauldwell for their excellent tutorials and Allan Turvey of Happy Coding ZX for
  6   0000              ; inspiration from his live streaming warts n all coding session on Lunar Rescue conversion
  7   0000              ; *********************************************************************************************************************
  8   0000
  9   0000
 10   0000                device zxspectrum48
 11   0000
 12   0000              IM2_TABLE   = $FE00 ; IM2 interrupt vector table in decimal is 65024
 13   0000              IM2_VECTOR  = $FDFD ; IM2 interrupt vector in decimal is 65021
 14   0000
 15   0000
 16   0000                org 32768             ; Set the origin of the program to 32768 (the start of the BASIC area)
 17   8000 C3 DB 88       jp start              ; Jump to the start of the program
 18   8003
 19   8003                include "library/doubleBufferAttributes.asm"
# file opened: /Users/darren/dev/spectrum/zx/project/src/library/doubleBufferAttributes.asm
  1+  8003              ; *********************************************************************************************************************
  2+  8003              ; Author:  Darren Bowles
  3+  8003              ; Date:    2020-05-03
  4+  8003              ; Purpose: This is a simple example of how to do double buffering with the screen attributes
  5+  8003              ; It's the same style that Jonathan Cauldwell mentions as being used in Rallybug
  6+  8003              ; see https://chuntey.wordpress.com/tag/double-buffering/ apart from i'm not doing screen memory (yet)
  7+  8003              ; and it's using some sjasmplus macros
  8+  8003              ; *********************************************************************************************************************
  9+  8003
 10+  8003              ; we'll need to keep a copy of the stack pointer, as we'll be moving it around
 11+  8003 00 00        CopyOfStackPointer: defw 0
 12+  8005
 13+  8005                  ; this macro copies over the screen attributes from the attribute buffer to the screen
 14+  8005                  macro DoCopy row, columnStart
 15+  8005 ~                    ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
 16+  8005 ~                    ld sp, AttributeBuffer + (row * 32) + columnStart
 17+  8005 ~                    ; now we start popping the attributes off the 'stack'
 18+  8005 ~                    pop af                      ; 1,0
 19+  8005 ~                    pop bc                      ; 3,2
 20+  8005 ~                    pop de                      ; 5,4
 21+  8005 ~                    pop hl                      ; 7,6
 22+  8005 ~
 23+  8005 ~                    ; oops, we've run out of registers, so we need to swap to alternate registers
 24+  8005 ~                    ex af, af'                  ; swap af with af'
 25+  8005 ~                    exx
 26+  8005 ~
 27+  8005 ~                    ; carry on popping
 28+  8005 ~                    pop af                      ; 9,8
 29+  8005 ~                    pop bc                      ; 11,10
 30+  8005 ~                    pop de                      ; 13,12
 31+  8005 ~                    pop hl                      ; 15,14
 32+  8005 ~
 33+  8005 ~                    ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
 34+  8005 ~                    ; as well as including the 16 bytes that we popped off the buffer stack and stored
 35+  8005 ~                    ld sp, $5800 + (row * 32) + columnStart + 16
 36+  8005 ~
 37+  8005 ~                    ; we push back onto the screen memory stack in reverse order
 38+  8005 ~                    push hl                     ; copy 15,14 to the screen memory
 39+  8005 ~                    push de                     ; copy 13,12 to the screen memory
 40+  8005 ~                    push bc                     ; copy 11,10 to the screen memory
 41+  8005 ~                    push af                     ; copy 9,8 to the screen memory
 42+  8005 ~
 43+  8005 ~                    ; swap back to the original registers
 44+  8005 ~                    ex af, af'
 45+  8005 ~                    exx
 46+  8005 ~
 47+  8005 ~                    push hl                     ; copy 7,6 to the screen memory
 48+  8005 ~                    push de                     ; copy 5,4 to the screen memory
 49+  8005 ~                    push bc                     ; copy 3,2 to the screen memory
 50+  8005 ~                    push af                     ; copy 1,0 to the screen memory
 51+  8005                  endm
 52+  8005
 53+  8005                  ; this macro copies over a number of rows
 54+  8005                  macro BufferCopyMacro count
 55+  8005 ~                    rept count, i
 56+  8005 ~                        DoCopy i, 0   ; copy the first 16 attributes over to the row
 57+  8005 ~                        DoCopy i, 16  ; copy the remaining 16 attributes over to the row
 58+  8005 ~                    endr
 59+  8005                  endm
 60+  8005
 61+  8005                  ; this macro generates the lookup table for the attribute buffer
 62+  8005                  macro AttributeBufferLookupMacro count
 63+  8005 ~                    rept count, i
 64+  8005 ~                        defw AttributeBuffer + (32 * i)
 65+  8005 ~                    endr
 66+  8005                  endm
 67+  8005
 68+  8005              ; here's our buffer - let's initialise it to all white paper, black ink
 69+  8005              AttributeBuffer:
 70+  8005 38 38 38...      block 768, STABLE + DULL + WHITE_PAPER + BLACK_INK
 71+  8305
 72+  8305              ; here's our lookup table
 73+  8305              AttributeBufferLookup:
 74+  8305                  AttributeBufferLookupMacro 24;
 74+  8305             >        rept 24, i
 74+  8305 05 80       >            defw AttributeBuffer + (32 * i)
 74+  8307 25 80       >            defw AttributeBuffer + (32 * i)
 74+  8309 45 80       >            defw AttributeBuffer + (32 * i)
 74+  830B 65 80       >            defw AttributeBuffer + (32 * i)
 74+  830D 85 80       >            defw AttributeBuffer + (32 * i)
 74+  830F A5 80       >            defw AttributeBuffer + (32 * i)
 74+  8311 C5 80       >            defw AttributeBuffer + (32 * i)
 74+  8313 E5 80       >            defw AttributeBuffer + (32 * i)
 74+  8315 05 81       >            defw AttributeBuffer + (32 * i)
 74+  8317 25 81       >            defw AttributeBuffer + (32 * i)
 74+  8319 45 81       >            defw AttributeBuffer + (32 * i)
 74+  831B 65 81       >            defw AttributeBuffer + (32 * i)
 74+  831D 85 81       >            defw AttributeBuffer + (32 * i)
 74+  831F A5 81       >            defw AttributeBuffer + (32 * i)
 74+  8321 C5 81       >            defw AttributeBuffer + (32 * i)
 74+  8323 E5 81       >            defw AttributeBuffer + (32 * i)
 74+  8325 05 82       >            defw AttributeBuffer + (32 * i)
 74+  8327 25 82       >            defw AttributeBuffer + (32 * i)
 74+  8329 45 82       >            defw AttributeBuffer + (32 * i)
 74+  832B 65 82       >            defw AttributeBuffer + (32 * i)
 74+  832D 85 82       >            defw AttributeBuffer + (32 * i)
 74+  832F A5 82       >            defw AttributeBuffer + (32 * i)
 74+  8331 C5 82       >            defw AttributeBuffer + (32 * i)
 74+  8333 E5 82       >            defw AttributeBuffer + (32 * i)
 74+  8335             >        endr
 75+  8335
 76+  8335
 77+  8335              ; CalculateAttributeBufferAddress - Calculates the attribute buffer address for a given position (X, Y)
 78+  8335              ;
 79+  8335              ; Input:
 80+  8335              ;   B: X coordinate (0-31)
 81+  8335              ;   C: Y coordinate (0-23)
 82+  8335              ;
 83+  8335              ; Output:
 84+  8335              ;   HL: Attribute Buffer address
 85+  8335              ;
 86+  8335              CalculateAttributeBufferAddress:
 87+  8335                ; Load the address of the lookup table into HL
 88+  8335 21 05 83       ld hl, AttributeBufferLookup
 89+  8338
 90+  8338                ; Double the Y coordinate by adding it to itself
 91+  8338 79             ld a, c
 92+  8339 87             add a, a
 93+  833A 85             add a, l
 94+  833B 6F             ld l, a
 95+  833C
 96+  833C                ; Get the table address for the Y coordinate
 97+  833C 5E 23 56 2B    ld de, (hl)
 98+  8340
 99+  8340                ; Add the X coordinate (in register B) to the table address (in register E)
100+  8340 78             ld a, b
101+  8341 83             add a, e
102+  8342 5F             ld e, a
103+  8343
104+  8343                ; Check if we got a carry (i.e. we exceeded 255)
105+  8343 30 01          jr nc, .noCarry
106+  8345
107+  8345                ; If we got a carry, increment the high byte of the address
108+  8345 14             inc d
109+  8346
110+  8346              .noCarry:
111+  8346                ; Move the combined address into HL
112+  8346 62 6B          ld hl, de
113+  8348
114+  8348                ; Return from the subroutine
115+  8348 C9             ret
116+  8349
117+  8349
118+  8349              ; Copy the attributes buffer to the screen attributes
119+  8349              ; TODO: This is a crude implementation that copies the entire buffer.
120+  8349              ; A more efficient implementation is possible.
121+  8349              copyScreenAttributes:
122+  8349                ; Save the current stack pointer to memory
123+  8349 ED 73 03 80    ld (CopyOfStackPointer), sp
124+  834D
125+  834D                ; Call the "BufferCopyMacro" macro to copy the buffer
126+  834D                BufferCopyMacro 24
126+  834D             >        rept 24, i
126+  834D             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  834D             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  834D 31 05 80    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8350             >        ; now we start popping the attributes off the 'stack'
126+  8350 F1          >        pop af                      ; 1,0
126+  8351 C1          >        pop bc                      ; 3,2
126+  8352 D1          >        pop de                      ; 5,4
126+  8353 E1          >        pop hl                      ; 7,6
126+  8354             >
126+  8354             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8354 08          >        ex af, af'                  ; swap af with af'
126+  8355 D9          >        exx
126+  8356             >
126+  8356             >        ; carry on popping
126+  8356 F1          >        pop af                      ; 9,8
126+  8357 C1          >        pop bc                      ; 11,10
126+  8358 D1          >        pop de                      ; 13,12
126+  8359 E1          >        pop hl                      ; 15,14
126+  835A             >
126+  835A             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  835A             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  835A 31 10 58    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  835D             >
126+  835D             >        ; we push back onto the screen memory stack in reverse order
126+  835D E5          >        push hl                     ; copy 15,14 to the screen memory
126+  835E D5          >        push de                     ; copy 13,12 to the screen memory
126+  835F C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8360 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8361             >
126+  8361             >        ; swap back to the original registers
126+  8361 08          >        ex af, af'
126+  8362 D9          >        exx
126+  8363             >
126+  8363 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8364 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8365 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8366 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8367             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  8367             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8367 31 15 80    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  836A             >        ; now we start popping the attributes off the 'stack'
126+  836A F1          >        pop af                      ; 1,0
126+  836B C1          >        pop bc                      ; 3,2
126+  836C D1          >        pop de                      ; 5,4
126+  836D E1          >        pop hl                      ; 7,6
126+  836E             >
126+  836E             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  836E 08          >        ex af, af'                  ; swap af with af'
126+  836F D9          >        exx
126+  8370             >
126+  8370             >        ; carry on popping
126+  8370 F1          >        pop af                      ; 9,8
126+  8371 C1          >        pop bc                      ; 11,10
126+  8372 D1          >        pop de                      ; 13,12
126+  8373 E1          >        pop hl                      ; 15,14
126+  8374             >
126+  8374             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8374             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8374 31 20 58    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  8377             >
126+  8377             >        ; we push back onto the screen memory stack in reverse order
126+  8377 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8378 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8379 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  837A F5          >        push af                     ; copy 9,8 to the screen memory
126+  837B             >
126+  837B             >        ; swap back to the original registers
126+  837B 08          >        ex af, af'
126+  837C D9          >        exx
126+  837D             >
126+  837D E5          >        push hl                     ; copy 7,6 to the screen memory
126+  837E D5          >        push de                     ; copy 5,4 to the screen memory
126+  837F C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8380 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8381             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8381             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8381 31 25 80    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8384             >        ; now we start popping the attributes off the 'stack'
126+  8384 F1          >        pop af                      ; 1,0
126+  8385 C1          >        pop bc                      ; 3,2
126+  8386 D1          >        pop de                      ; 5,4
126+  8387 E1          >        pop hl                      ; 7,6
126+  8388             >
126+  8388             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8388 08          >        ex af, af'                  ; swap af with af'
126+  8389 D9          >        exx
126+  838A             >
126+  838A             >        ; carry on popping
126+  838A F1          >        pop af                      ; 9,8
126+  838B C1          >        pop bc                      ; 11,10
126+  838C D1          >        pop de                      ; 13,12
126+  838D E1          >        pop hl                      ; 15,14
126+  838E             >
126+  838E             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  838E             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  838E 31 30 58    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8391             >
126+  8391             >        ; we push back onto the screen memory stack in reverse order
126+  8391 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8392 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8393 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8394 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8395             >
126+  8395             >        ; swap back to the original registers
126+  8395 08          >        ex af, af'
126+  8396 D9          >        exx
126+  8397             >
126+  8397 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8398 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8399 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  839A F5          >        push af                     ; copy 1,0 to the screen memory
126+  839B             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  839B             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  839B 31 35 80    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  839E             >        ; now we start popping the attributes off the 'stack'
126+  839E F1          >        pop af                      ; 1,0
126+  839F C1          >        pop bc                      ; 3,2
126+  83A0 D1          >        pop de                      ; 5,4
126+  83A1 E1          >        pop hl                      ; 7,6
126+  83A2             >
126+  83A2             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  83A2 08          >        ex af, af'                  ; swap af with af'
126+  83A3 D9          >        exx
126+  83A4             >
126+  83A4             >        ; carry on popping
126+  83A4 F1          >        pop af                      ; 9,8
126+  83A5 C1          >        pop bc                      ; 11,10
126+  83A6 D1          >        pop de                      ; 13,12
126+  83A7 E1          >        pop hl                      ; 15,14
126+  83A8             >
126+  83A8             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  83A8             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  83A8 31 40 58    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  83AB             >
126+  83AB             >        ; we push back onto the screen memory stack in reverse order
126+  83AB E5          >        push hl                     ; copy 15,14 to the screen memory
126+  83AC D5          >        push de                     ; copy 13,12 to the screen memory
126+  83AD C5          >        push bc                     ; copy 11,10 to the screen memory
126+  83AE F5          >        push af                     ; copy 9,8 to the screen memory
126+  83AF             >
126+  83AF             >        ; swap back to the original registers
126+  83AF 08          >        ex af, af'
126+  83B0 D9          >        exx
126+  83B1             >
126+  83B1 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  83B2 D5          >        push de                     ; copy 5,4 to the screen memory
126+  83B3 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  83B4 F5          >        push af                     ; copy 1,0 to the screen memory
126+  83B5             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  83B5             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  83B5 31 45 80    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  83B8             >        ; now we start popping the attributes off the 'stack'
126+  83B8 F1          >        pop af                      ; 1,0
126+  83B9 C1          >        pop bc                      ; 3,2
126+  83BA D1          >        pop de                      ; 5,4
126+  83BB E1          >        pop hl                      ; 7,6
126+  83BC             >
126+  83BC             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  83BC 08          >        ex af, af'                  ; swap af with af'
126+  83BD D9          >        exx
126+  83BE             >
126+  83BE             >        ; carry on popping
126+  83BE F1          >        pop af                      ; 9,8
126+  83BF C1          >        pop bc                      ; 11,10
126+  83C0 D1          >        pop de                      ; 13,12
126+  83C1 E1          >        pop hl                      ; 15,14
126+  83C2             >
126+  83C2             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  83C2             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  83C2 31 50 58    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  83C5             >
126+  83C5             >        ; we push back onto the screen memory stack in reverse order
126+  83C5 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  83C6 D5          >        push de                     ; copy 13,12 to the screen memory
126+  83C7 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  83C8 F5          >        push af                     ; copy 9,8 to the screen memory
126+  83C9             >
126+  83C9             >        ; swap back to the original registers
126+  83C9 08          >        ex af, af'
126+  83CA D9          >        exx
126+  83CB             >
126+  83CB E5          >        push hl                     ; copy 7,6 to the screen memory
126+  83CC D5          >        push de                     ; copy 5,4 to the screen memory
126+  83CD C5          >        push bc                     ; copy 3,2 to the screen memory
126+  83CE F5          >        push af                     ; copy 1,0 to the screen memory
126+  83CF             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  83CF             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  83CF 31 55 80    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  83D2             >        ; now we start popping the attributes off the 'stack'
126+  83D2 F1          >        pop af                      ; 1,0
126+  83D3 C1          >        pop bc                      ; 3,2
126+  83D4 D1          >        pop de                      ; 5,4
126+  83D5 E1          >        pop hl                      ; 7,6
126+  83D6             >
126+  83D6             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  83D6 08          >        ex af, af'                  ; swap af with af'
126+  83D7 D9          >        exx
126+  83D8             >
126+  83D8             >        ; carry on popping
126+  83D8 F1          >        pop af                      ; 9,8
126+  83D9 C1          >        pop bc                      ; 11,10
126+  83DA D1          >        pop de                      ; 13,12
126+  83DB E1          >        pop hl                      ; 15,14
126+  83DC             >
126+  83DC             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  83DC             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  83DC 31 60 58    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  83DF             >
126+  83DF             >        ; we push back onto the screen memory stack in reverse order
126+  83DF E5          >        push hl                     ; copy 15,14 to the screen memory
126+  83E0 D5          >        push de                     ; copy 13,12 to the screen memory
126+  83E1 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  83E2 F5          >        push af                     ; copy 9,8 to the screen memory
126+  83E3             >
126+  83E3             >        ; swap back to the original registers
126+  83E3 08          >        ex af, af'
126+  83E4 D9          >        exx
126+  83E5             >
126+  83E5 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  83E6 D5          >        push de                     ; copy 5,4 to the screen memory
126+  83E7 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  83E8 F5          >        push af                     ; copy 1,0 to the screen memory
126+  83E9             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  83E9             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  83E9 31 65 80    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  83EC             >        ; now we start popping the attributes off the 'stack'
126+  83EC F1          >        pop af                      ; 1,0
126+  83ED C1          >        pop bc                      ; 3,2
126+  83EE D1          >        pop de                      ; 5,4
126+  83EF E1          >        pop hl                      ; 7,6
126+  83F0             >
126+  83F0             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  83F0 08          >        ex af, af'                  ; swap af with af'
126+  83F1 D9          >        exx
126+  83F2             >
126+  83F2             >        ; carry on popping
126+  83F2 F1          >        pop af                      ; 9,8
126+  83F3 C1          >        pop bc                      ; 11,10
126+  83F4 D1          >        pop de                      ; 13,12
126+  83F5 E1          >        pop hl                      ; 15,14
126+  83F6             >
126+  83F6             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  83F6             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  83F6 31 70 58    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  83F9             >
126+  83F9             >        ; we push back onto the screen memory stack in reverse order
126+  83F9 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  83FA D5          >        push de                     ; copy 13,12 to the screen memory
126+  83FB C5          >        push bc                     ; copy 11,10 to the screen memory
126+  83FC F5          >        push af                     ; copy 9,8 to the screen memory
126+  83FD             >
126+  83FD             >        ; swap back to the original registers
126+  83FD 08          >        ex af, af'
126+  83FE D9          >        exx
126+  83FF             >
126+  83FF E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8400 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8401 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8402 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8403             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  8403             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8403 31 75 80    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  8406             >        ; now we start popping the attributes off the 'stack'
126+  8406 F1          >        pop af                      ; 1,0
126+  8407 C1          >        pop bc                      ; 3,2
126+  8408 D1          >        pop de                      ; 5,4
126+  8409 E1          >        pop hl                      ; 7,6
126+  840A             >
126+  840A             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  840A 08          >        ex af, af'                  ; swap af with af'
126+  840B D9          >        exx
126+  840C             >
126+  840C             >        ; carry on popping
126+  840C F1          >        pop af                      ; 9,8
126+  840D C1          >        pop bc                      ; 11,10
126+  840E D1          >        pop de                      ; 13,12
126+  840F E1          >        pop hl                      ; 15,14
126+  8410             >
126+  8410             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8410             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8410 31 80 58    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  8413             >
126+  8413             >        ; we push back onto the screen memory stack in reverse order
126+  8413 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8414 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8415 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8416 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8417             >
126+  8417             >        ; swap back to the original registers
126+  8417 08          >        ex af, af'
126+  8418 D9          >        exx
126+  8419             >
126+  8419 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  841A D5          >        push de                     ; copy 5,4 to the screen memory
126+  841B C5          >        push bc                     ; copy 3,2 to the screen memory
126+  841C F5          >        push af                     ; copy 1,0 to the screen memory
126+  841D             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  841D             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  841D 31 85 80    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8420             >        ; now we start popping the attributes off the 'stack'
126+  8420 F1          >        pop af                      ; 1,0
126+  8421 C1          >        pop bc                      ; 3,2
126+  8422 D1          >        pop de                      ; 5,4
126+  8423 E1          >        pop hl                      ; 7,6
126+  8424             >
126+  8424             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8424 08          >        ex af, af'                  ; swap af with af'
126+  8425 D9          >        exx
126+  8426             >
126+  8426             >        ; carry on popping
126+  8426 F1          >        pop af                      ; 9,8
126+  8427 C1          >        pop bc                      ; 11,10
126+  8428 D1          >        pop de                      ; 13,12
126+  8429 E1          >        pop hl                      ; 15,14
126+  842A             >
126+  842A             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  842A             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  842A 31 90 58    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  842D             >
126+  842D             >        ; we push back onto the screen memory stack in reverse order
126+  842D E5          >        push hl                     ; copy 15,14 to the screen memory
126+  842E D5          >        push de                     ; copy 13,12 to the screen memory
126+  842F C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8430 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8431             >
126+  8431             >        ; swap back to the original registers
126+  8431 08          >        ex af, af'
126+  8432 D9          >        exx
126+  8433             >
126+  8433 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8434 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8435 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8436 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8437             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  8437             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8437 31 95 80    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  843A             >        ; now we start popping the attributes off the 'stack'
126+  843A F1          >        pop af                      ; 1,0
126+  843B C1          >        pop bc                      ; 3,2
126+  843C D1          >        pop de                      ; 5,4
126+  843D E1          >        pop hl                      ; 7,6
126+  843E             >
126+  843E             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  843E 08          >        ex af, af'                  ; swap af with af'
126+  843F D9          >        exx
126+  8440             >
126+  8440             >        ; carry on popping
126+  8440 F1          >        pop af                      ; 9,8
126+  8441 C1          >        pop bc                      ; 11,10
126+  8442 D1          >        pop de                      ; 13,12
126+  8443 E1          >        pop hl                      ; 15,14
126+  8444             >
126+  8444             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8444             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8444 31 A0 58    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  8447             >
126+  8447             >        ; we push back onto the screen memory stack in reverse order
126+  8447 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8448 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8449 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  844A F5          >        push af                     ; copy 9,8 to the screen memory
126+  844B             >
126+  844B             >        ; swap back to the original registers
126+  844B 08          >        ex af, af'
126+  844C D9          >        exx
126+  844D             >
126+  844D E5          >        push hl                     ; copy 7,6 to the screen memory
126+  844E D5          >        push de                     ; copy 5,4 to the screen memory
126+  844F C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8450 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8451             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8451             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8451 31 A5 80    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8454             >        ; now we start popping the attributes off the 'stack'
126+  8454 F1          >        pop af                      ; 1,0
126+  8455 C1          >        pop bc                      ; 3,2
126+  8456 D1          >        pop de                      ; 5,4
126+  8457 E1          >        pop hl                      ; 7,6
126+  8458             >
126+  8458             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8458 08          >        ex af, af'                  ; swap af with af'
126+  8459 D9          >        exx
126+  845A             >
126+  845A             >        ; carry on popping
126+  845A F1          >        pop af                      ; 9,8
126+  845B C1          >        pop bc                      ; 11,10
126+  845C D1          >        pop de                      ; 13,12
126+  845D E1          >        pop hl                      ; 15,14
126+  845E             >
126+  845E             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  845E             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  845E 31 B0 58    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8461             >
126+  8461             >        ; we push back onto the screen memory stack in reverse order
126+  8461 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8462 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8463 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8464 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8465             >
126+  8465             >        ; swap back to the original registers
126+  8465 08          >        ex af, af'
126+  8466 D9          >        exx
126+  8467             >
126+  8467 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8468 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8469 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  846A F5          >        push af                     ; copy 1,0 to the screen memory
126+  846B             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  846B             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  846B 31 B5 80    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  846E             >        ; now we start popping the attributes off the 'stack'
126+  846E F1          >        pop af                      ; 1,0
126+  846F C1          >        pop bc                      ; 3,2
126+  8470 D1          >        pop de                      ; 5,4
126+  8471 E1          >        pop hl                      ; 7,6
126+  8472             >
126+  8472             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8472 08          >        ex af, af'                  ; swap af with af'
126+  8473 D9          >        exx
126+  8474             >
126+  8474             >        ; carry on popping
126+  8474 F1          >        pop af                      ; 9,8
126+  8475 C1          >        pop bc                      ; 11,10
126+  8476 D1          >        pop de                      ; 13,12
126+  8477 E1          >        pop hl                      ; 15,14
126+  8478             >
126+  8478             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8478             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8478 31 C0 58    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  847B             >
126+  847B             >        ; we push back onto the screen memory stack in reverse order
126+  847B E5          >        push hl                     ; copy 15,14 to the screen memory
126+  847C D5          >        push de                     ; copy 13,12 to the screen memory
126+  847D C5          >        push bc                     ; copy 11,10 to the screen memory
126+  847E F5          >        push af                     ; copy 9,8 to the screen memory
126+  847F             >
126+  847F             >        ; swap back to the original registers
126+  847F 08          >        ex af, af'
126+  8480 D9          >        exx
126+  8481             >
126+  8481 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8482 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8483 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8484 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8485             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8485             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8485 31 C5 80    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8488             >        ; now we start popping the attributes off the 'stack'
126+  8488 F1          >        pop af                      ; 1,0
126+  8489 C1          >        pop bc                      ; 3,2
126+  848A D1          >        pop de                      ; 5,4
126+  848B E1          >        pop hl                      ; 7,6
126+  848C             >
126+  848C             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  848C 08          >        ex af, af'                  ; swap af with af'
126+  848D D9          >        exx
126+  848E             >
126+  848E             >        ; carry on popping
126+  848E F1          >        pop af                      ; 9,8
126+  848F C1          >        pop bc                      ; 11,10
126+  8490 D1          >        pop de                      ; 13,12
126+  8491 E1          >        pop hl                      ; 15,14
126+  8492             >
126+  8492             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8492             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8492 31 D0 58    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8495             >
126+  8495             >        ; we push back onto the screen memory stack in reverse order
126+  8495 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8496 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8497 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8498 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8499             >
126+  8499             >        ; swap back to the original registers
126+  8499 08          >        ex af, af'
126+  849A D9          >        exx
126+  849B             >
126+  849B E5          >        push hl                     ; copy 7,6 to the screen memory
126+  849C D5          >        push de                     ; copy 5,4 to the screen memory
126+  849D C5          >        push bc                     ; copy 3,2 to the screen memory
126+  849E F5          >        push af                     ; copy 1,0 to the screen memory
126+  849F             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  849F             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  849F 31 D5 80    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  84A2             >        ; now we start popping the attributes off the 'stack'
126+  84A2 F1          >        pop af                      ; 1,0
126+  84A3 C1          >        pop bc                      ; 3,2
126+  84A4 D1          >        pop de                      ; 5,4
126+  84A5 E1          >        pop hl                      ; 7,6
126+  84A6             >
126+  84A6             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  84A6 08          >        ex af, af'                  ; swap af with af'
126+  84A7 D9          >        exx
126+  84A8             >
126+  84A8             >        ; carry on popping
126+  84A8 F1          >        pop af                      ; 9,8
126+  84A9 C1          >        pop bc                      ; 11,10
126+  84AA D1          >        pop de                      ; 13,12
126+  84AB E1          >        pop hl                      ; 15,14
126+  84AC             >
126+  84AC             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  84AC             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  84AC 31 E0 58    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  84AF             >
126+  84AF             >        ; we push back onto the screen memory stack in reverse order
126+  84AF E5          >        push hl                     ; copy 15,14 to the screen memory
126+  84B0 D5          >        push de                     ; copy 13,12 to the screen memory
126+  84B1 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  84B2 F5          >        push af                     ; copy 9,8 to the screen memory
126+  84B3             >
126+  84B3             >        ; swap back to the original registers
126+  84B3 08          >        ex af, af'
126+  84B4 D9          >        exx
126+  84B5             >
126+  84B5 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  84B6 D5          >        push de                     ; copy 5,4 to the screen memory
126+  84B7 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  84B8 F5          >        push af                     ; copy 1,0 to the screen memory
126+  84B9             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  84B9             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  84B9 31 E5 80    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  84BC             >        ; now we start popping the attributes off the 'stack'
126+  84BC F1          >        pop af                      ; 1,0
126+  84BD C1          >        pop bc                      ; 3,2
126+  84BE D1          >        pop de                      ; 5,4
126+  84BF E1          >        pop hl                      ; 7,6
126+  84C0             >
126+  84C0             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  84C0 08          >        ex af, af'                  ; swap af with af'
126+  84C1 D9          >        exx
126+  84C2             >
126+  84C2             >        ; carry on popping
126+  84C2 F1          >        pop af                      ; 9,8
126+  84C3 C1          >        pop bc                      ; 11,10
126+  84C4 D1          >        pop de                      ; 13,12
126+  84C5 E1          >        pop hl                      ; 15,14
126+  84C6             >
126+  84C6             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  84C6             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  84C6 31 F0 58    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  84C9             >
126+  84C9             >        ; we push back onto the screen memory stack in reverse order
126+  84C9 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  84CA D5          >        push de                     ; copy 13,12 to the screen memory
126+  84CB C5          >        push bc                     ; copy 11,10 to the screen memory
126+  84CC F5          >        push af                     ; copy 9,8 to the screen memory
126+  84CD             >
126+  84CD             >        ; swap back to the original registers
126+  84CD 08          >        ex af, af'
126+  84CE D9          >        exx
126+  84CF             >
126+  84CF E5          >        push hl                     ; copy 7,6 to the screen memory
126+  84D0 D5          >        push de                     ; copy 5,4 to the screen memory
126+  84D1 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  84D2 F5          >        push af                     ; copy 1,0 to the screen memory
126+  84D3             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  84D3             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  84D3 31 F5 80    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  84D6             >        ; now we start popping the attributes off the 'stack'
126+  84D6 F1          >        pop af                      ; 1,0
126+  84D7 C1          >        pop bc                      ; 3,2
126+  84D8 D1          >        pop de                      ; 5,4
126+  84D9 E1          >        pop hl                      ; 7,6
126+  84DA             >
126+  84DA             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  84DA 08          >        ex af, af'                  ; swap af with af'
126+  84DB D9          >        exx
126+  84DC             >
126+  84DC             >        ; carry on popping
126+  84DC F1          >        pop af                      ; 9,8
126+  84DD C1          >        pop bc                      ; 11,10
126+  84DE D1          >        pop de                      ; 13,12
126+  84DF E1          >        pop hl                      ; 15,14
126+  84E0             >
126+  84E0             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  84E0             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  84E0 31 00 59    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  84E3             >
126+  84E3             >        ; we push back onto the screen memory stack in reverse order
126+  84E3 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  84E4 D5          >        push de                     ; copy 13,12 to the screen memory
126+  84E5 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  84E6 F5          >        push af                     ; copy 9,8 to the screen memory
126+  84E7             >
126+  84E7             >        ; swap back to the original registers
126+  84E7 08          >        ex af, af'
126+  84E8 D9          >        exx
126+  84E9             >
126+  84E9 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  84EA D5          >        push de                     ; copy 5,4 to the screen memory
126+  84EB C5          >        push bc                     ; copy 3,2 to the screen memory
126+  84EC F5          >        push af                     ; copy 1,0 to the screen memory
126+  84ED             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  84ED             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  84ED 31 05 81    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  84F0             >        ; now we start popping the attributes off the 'stack'
126+  84F0 F1          >        pop af                      ; 1,0
126+  84F1 C1          >        pop bc                      ; 3,2
126+  84F2 D1          >        pop de                      ; 5,4
126+  84F3 E1          >        pop hl                      ; 7,6
126+  84F4             >
126+  84F4             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  84F4 08          >        ex af, af'                  ; swap af with af'
126+  84F5 D9          >        exx
126+  84F6             >
126+  84F6             >        ; carry on popping
126+  84F6 F1          >        pop af                      ; 9,8
126+  84F7 C1          >        pop bc                      ; 11,10
126+  84F8 D1          >        pop de                      ; 13,12
126+  84F9 E1          >        pop hl                      ; 15,14
126+  84FA             >
126+  84FA             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  84FA             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  84FA 31 10 59    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  84FD             >
126+  84FD             >        ; we push back onto the screen memory stack in reverse order
126+  84FD E5          >        push hl                     ; copy 15,14 to the screen memory
126+  84FE D5          >        push de                     ; copy 13,12 to the screen memory
126+  84FF C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8500 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8501             >
126+  8501             >        ; swap back to the original registers
126+  8501 08          >        ex af, af'
126+  8502 D9          >        exx
126+  8503             >
126+  8503 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8504 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8505 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8506 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8507             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  8507             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8507 31 15 81    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  850A             >        ; now we start popping the attributes off the 'stack'
126+  850A F1          >        pop af                      ; 1,0
126+  850B C1          >        pop bc                      ; 3,2
126+  850C D1          >        pop de                      ; 5,4
126+  850D E1          >        pop hl                      ; 7,6
126+  850E             >
126+  850E             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  850E 08          >        ex af, af'                  ; swap af with af'
126+  850F D9          >        exx
126+  8510             >
126+  8510             >        ; carry on popping
126+  8510 F1          >        pop af                      ; 9,8
126+  8511 C1          >        pop bc                      ; 11,10
126+  8512 D1          >        pop de                      ; 13,12
126+  8513 E1          >        pop hl                      ; 15,14
126+  8514             >
126+  8514             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8514             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8514 31 20 59    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  8517             >
126+  8517             >        ; we push back onto the screen memory stack in reverse order
126+  8517 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8518 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8519 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  851A F5          >        push af                     ; copy 9,8 to the screen memory
126+  851B             >
126+  851B             >        ; swap back to the original registers
126+  851B 08          >        ex af, af'
126+  851C D9          >        exx
126+  851D             >
126+  851D E5          >        push hl                     ; copy 7,6 to the screen memory
126+  851E D5          >        push de                     ; copy 5,4 to the screen memory
126+  851F C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8520 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8521             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8521             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8521 31 25 81    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8524             >        ; now we start popping the attributes off the 'stack'
126+  8524 F1          >        pop af                      ; 1,0
126+  8525 C1          >        pop bc                      ; 3,2
126+  8526 D1          >        pop de                      ; 5,4
126+  8527 E1          >        pop hl                      ; 7,6
126+  8528             >
126+  8528             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8528 08          >        ex af, af'                  ; swap af with af'
126+  8529 D9          >        exx
126+  852A             >
126+  852A             >        ; carry on popping
126+  852A F1          >        pop af                      ; 9,8
126+  852B C1          >        pop bc                      ; 11,10
126+  852C D1          >        pop de                      ; 13,12
126+  852D E1          >        pop hl                      ; 15,14
126+  852E             >
126+  852E             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  852E             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  852E 31 30 59    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8531             >
126+  8531             >        ; we push back onto the screen memory stack in reverse order
126+  8531 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8532 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8533 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8534 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8535             >
126+  8535             >        ; swap back to the original registers
126+  8535 08          >        ex af, af'
126+  8536 D9          >        exx
126+  8537             >
126+  8537 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8538 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8539 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  853A F5          >        push af                     ; copy 1,0 to the screen memory
126+  853B             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  853B             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  853B 31 35 81    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  853E             >        ; now we start popping the attributes off the 'stack'
126+  853E F1          >        pop af                      ; 1,0
126+  853F C1          >        pop bc                      ; 3,2
126+  8540 D1          >        pop de                      ; 5,4
126+  8541 E1          >        pop hl                      ; 7,6
126+  8542             >
126+  8542             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8542 08          >        ex af, af'                  ; swap af with af'
126+  8543 D9          >        exx
126+  8544             >
126+  8544             >        ; carry on popping
126+  8544 F1          >        pop af                      ; 9,8
126+  8545 C1          >        pop bc                      ; 11,10
126+  8546 D1          >        pop de                      ; 13,12
126+  8547 E1          >        pop hl                      ; 15,14
126+  8548             >
126+  8548             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8548             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8548 31 40 59    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  854B             >
126+  854B             >        ; we push back onto the screen memory stack in reverse order
126+  854B E5          >        push hl                     ; copy 15,14 to the screen memory
126+  854C D5          >        push de                     ; copy 13,12 to the screen memory
126+  854D C5          >        push bc                     ; copy 11,10 to the screen memory
126+  854E F5          >        push af                     ; copy 9,8 to the screen memory
126+  854F             >
126+  854F             >        ; swap back to the original registers
126+  854F 08          >        ex af, af'
126+  8550 D9          >        exx
126+  8551             >
126+  8551 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8552 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8553 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8554 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8555             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8555             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8555 31 45 81    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8558             >        ; now we start popping the attributes off the 'stack'
126+  8558 F1          >        pop af                      ; 1,0
126+  8559 C1          >        pop bc                      ; 3,2
126+  855A D1          >        pop de                      ; 5,4
126+  855B E1          >        pop hl                      ; 7,6
126+  855C             >
126+  855C             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  855C 08          >        ex af, af'                  ; swap af with af'
126+  855D D9          >        exx
126+  855E             >
126+  855E             >        ; carry on popping
126+  855E F1          >        pop af                      ; 9,8
126+  855F C1          >        pop bc                      ; 11,10
126+  8560 D1          >        pop de                      ; 13,12
126+  8561 E1          >        pop hl                      ; 15,14
126+  8562             >
126+  8562             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8562             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8562 31 50 59    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8565             >
126+  8565             >        ; we push back onto the screen memory stack in reverse order
126+  8565 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8566 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8567 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8568 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8569             >
126+  8569             >        ; swap back to the original registers
126+  8569 08          >        ex af, af'
126+  856A D9          >        exx
126+  856B             >
126+  856B E5          >        push hl                     ; copy 7,6 to the screen memory
126+  856C D5          >        push de                     ; copy 5,4 to the screen memory
126+  856D C5          >        push bc                     ; copy 3,2 to the screen memory
126+  856E F5          >        push af                     ; copy 1,0 to the screen memory
126+  856F             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  856F             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  856F 31 55 81    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  8572             >        ; now we start popping the attributes off the 'stack'
126+  8572 F1          >        pop af                      ; 1,0
126+  8573 C1          >        pop bc                      ; 3,2
126+  8574 D1          >        pop de                      ; 5,4
126+  8575 E1          >        pop hl                      ; 7,6
126+  8576             >
126+  8576             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8576 08          >        ex af, af'                  ; swap af with af'
126+  8577 D9          >        exx
126+  8578             >
126+  8578             >        ; carry on popping
126+  8578 F1          >        pop af                      ; 9,8
126+  8579 C1          >        pop bc                      ; 11,10
126+  857A D1          >        pop de                      ; 13,12
126+  857B E1          >        pop hl                      ; 15,14
126+  857C             >
126+  857C             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  857C             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  857C 31 60 59    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  857F             >
126+  857F             >        ; we push back onto the screen memory stack in reverse order
126+  857F E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8580 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8581 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8582 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8583             >
126+  8583             >        ; swap back to the original registers
126+  8583 08          >        ex af, af'
126+  8584 D9          >        exx
126+  8585             >
126+  8585 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8586 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8587 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8588 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8589             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8589             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8589 31 65 81    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  858C             >        ; now we start popping the attributes off the 'stack'
126+  858C F1          >        pop af                      ; 1,0
126+  858D C1          >        pop bc                      ; 3,2
126+  858E D1          >        pop de                      ; 5,4
126+  858F E1          >        pop hl                      ; 7,6
126+  8590             >
126+  8590             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8590 08          >        ex af, af'                  ; swap af with af'
126+  8591 D9          >        exx
126+  8592             >
126+  8592             >        ; carry on popping
126+  8592 F1          >        pop af                      ; 9,8
126+  8593 C1          >        pop bc                      ; 11,10
126+  8594 D1          >        pop de                      ; 13,12
126+  8595 E1          >        pop hl                      ; 15,14
126+  8596             >
126+  8596             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8596             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8596 31 70 59    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8599             >
126+  8599             >        ; we push back onto the screen memory stack in reverse order
126+  8599 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  859A D5          >        push de                     ; copy 13,12 to the screen memory
126+  859B C5          >        push bc                     ; copy 11,10 to the screen memory
126+  859C F5          >        push af                     ; copy 9,8 to the screen memory
126+  859D             >
126+  859D             >        ; swap back to the original registers
126+  859D 08          >        ex af, af'
126+  859E D9          >        exx
126+  859F             >
126+  859F E5          >        push hl                     ; copy 7,6 to the screen memory
126+  85A0 D5          >        push de                     ; copy 5,4 to the screen memory
126+  85A1 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  85A2 F5          >        push af                     ; copy 1,0 to the screen memory
126+  85A3             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  85A3             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  85A3 31 75 81    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  85A6             >        ; now we start popping the attributes off the 'stack'
126+  85A6 F1          >        pop af                      ; 1,0
126+  85A7 C1          >        pop bc                      ; 3,2
126+  85A8 D1          >        pop de                      ; 5,4
126+  85A9 E1          >        pop hl                      ; 7,6
126+  85AA             >
126+  85AA             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  85AA 08          >        ex af, af'                  ; swap af with af'
126+  85AB D9          >        exx
126+  85AC             >
126+  85AC             >        ; carry on popping
126+  85AC F1          >        pop af                      ; 9,8
126+  85AD C1          >        pop bc                      ; 11,10
126+  85AE D1          >        pop de                      ; 13,12
126+  85AF E1          >        pop hl                      ; 15,14
126+  85B0             >
126+  85B0             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  85B0             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  85B0 31 80 59    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  85B3             >
126+  85B3             >        ; we push back onto the screen memory stack in reverse order
126+  85B3 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  85B4 D5          >        push de                     ; copy 13,12 to the screen memory
126+  85B5 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  85B6 F5          >        push af                     ; copy 9,8 to the screen memory
126+  85B7             >
126+  85B7             >        ; swap back to the original registers
126+  85B7 08          >        ex af, af'
126+  85B8 D9          >        exx
126+  85B9             >
126+  85B9 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  85BA D5          >        push de                     ; copy 5,4 to the screen memory
126+  85BB C5          >        push bc                     ; copy 3,2 to the screen memory
126+  85BC F5          >        push af                     ; copy 1,0 to the screen memory
126+  85BD             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  85BD             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  85BD 31 85 81    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  85C0             >        ; now we start popping the attributes off the 'stack'
126+  85C0 F1          >        pop af                      ; 1,0
126+  85C1 C1          >        pop bc                      ; 3,2
126+  85C2 D1          >        pop de                      ; 5,4
126+  85C3 E1          >        pop hl                      ; 7,6
126+  85C4             >
126+  85C4             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  85C4 08          >        ex af, af'                  ; swap af with af'
126+  85C5 D9          >        exx
126+  85C6             >
126+  85C6             >        ; carry on popping
126+  85C6 F1          >        pop af                      ; 9,8
126+  85C7 C1          >        pop bc                      ; 11,10
126+  85C8 D1          >        pop de                      ; 13,12
126+  85C9 E1          >        pop hl                      ; 15,14
126+  85CA             >
126+  85CA             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  85CA             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  85CA 31 90 59    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  85CD             >
126+  85CD             >        ; we push back onto the screen memory stack in reverse order
126+  85CD E5          >        push hl                     ; copy 15,14 to the screen memory
126+  85CE D5          >        push de                     ; copy 13,12 to the screen memory
126+  85CF C5          >        push bc                     ; copy 11,10 to the screen memory
126+  85D0 F5          >        push af                     ; copy 9,8 to the screen memory
126+  85D1             >
126+  85D1             >        ; swap back to the original registers
126+  85D1 08          >        ex af, af'
126+  85D2 D9          >        exx
126+  85D3             >
126+  85D3 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  85D4 D5          >        push de                     ; copy 5,4 to the screen memory
126+  85D5 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  85D6 F5          >        push af                     ; copy 1,0 to the screen memory
126+  85D7             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  85D7             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  85D7 31 95 81    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  85DA             >        ; now we start popping the attributes off the 'stack'
126+  85DA F1          >        pop af                      ; 1,0
126+  85DB C1          >        pop bc                      ; 3,2
126+  85DC D1          >        pop de                      ; 5,4
126+  85DD E1          >        pop hl                      ; 7,6
126+  85DE             >
126+  85DE             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  85DE 08          >        ex af, af'                  ; swap af with af'
126+  85DF D9          >        exx
126+  85E0             >
126+  85E0             >        ; carry on popping
126+  85E0 F1          >        pop af                      ; 9,8
126+  85E1 C1          >        pop bc                      ; 11,10
126+  85E2 D1          >        pop de                      ; 13,12
126+  85E3 E1          >        pop hl                      ; 15,14
126+  85E4             >
126+  85E4             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  85E4             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  85E4 31 A0 59    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  85E7             >
126+  85E7             >        ; we push back onto the screen memory stack in reverse order
126+  85E7 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  85E8 D5          >        push de                     ; copy 13,12 to the screen memory
126+  85E9 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  85EA F5          >        push af                     ; copy 9,8 to the screen memory
126+  85EB             >
126+  85EB             >        ; swap back to the original registers
126+  85EB 08          >        ex af, af'
126+  85EC D9          >        exx
126+  85ED             >
126+  85ED E5          >        push hl                     ; copy 7,6 to the screen memory
126+  85EE D5          >        push de                     ; copy 5,4 to the screen memory
126+  85EF C5          >        push bc                     ; copy 3,2 to the screen memory
126+  85F0 F5          >        push af                     ; copy 1,0 to the screen memory
126+  85F1             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  85F1             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  85F1 31 A5 81    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  85F4             >        ; now we start popping the attributes off the 'stack'
126+  85F4 F1          >        pop af                      ; 1,0
126+  85F5 C1          >        pop bc                      ; 3,2
126+  85F6 D1          >        pop de                      ; 5,4
126+  85F7 E1          >        pop hl                      ; 7,6
126+  85F8             >
126+  85F8             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  85F8 08          >        ex af, af'                  ; swap af with af'
126+  85F9 D9          >        exx
126+  85FA             >
126+  85FA             >        ; carry on popping
126+  85FA F1          >        pop af                      ; 9,8
126+  85FB C1          >        pop bc                      ; 11,10
126+  85FC D1          >        pop de                      ; 13,12
126+  85FD E1          >        pop hl                      ; 15,14
126+  85FE             >
126+  85FE             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  85FE             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  85FE 31 B0 59    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8601             >
126+  8601             >        ; we push back onto the screen memory stack in reverse order
126+  8601 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8602 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8603 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8604 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8605             >
126+  8605             >        ; swap back to the original registers
126+  8605 08          >        ex af, af'
126+  8606 D9          >        exx
126+  8607             >
126+  8607 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8608 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8609 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  860A F5          >        push af                     ; copy 1,0 to the screen memory
126+  860B             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  860B             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  860B 31 B5 81    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  860E             >        ; now we start popping the attributes off the 'stack'
126+  860E F1          >        pop af                      ; 1,0
126+  860F C1          >        pop bc                      ; 3,2
126+  8610 D1          >        pop de                      ; 5,4
126+  8611 E1          >        pop hl                      ; 7,6
126+  8612             >
126+  8612             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8612 08          >        ex af, af'                  ; swap af with af'
126+  8613 D9          >        exx
126+  8614             >
126+  8614             >        ; carry on popping
126+  8614 F1          >        pop af                      ; 9,8
126+  8615 C1          >        pop bc                      ; 11,10
126+  8616 D1          >        pop de                      ; 13,12
126+  8617 E1          >        pop hl                      ; 15,14
126+  8618             >
126+  8618             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8618             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8618 31 C0 59    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  861B             >
126+  861B             >        ; we push back onto the screen memory stack in reverse order
126+  861B E5          >        push hl                     ; copy 15,14 to the screen memory
126+  861C D5          >        push de                     ; copy 13,12 to the screen memory
126+  861D C5          >        push bc                     ; copy 11,10 to the screen memory
126+  861E F5          >        push af                     ; copy 9,8 to the screen memory
126+  861F             >
126+  861F             >        ; swap back to the original registers
126+  861F 08          >        ex af, af'
126+  8620 D9          >        exx
126+  8621             >
126+  8621 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8622 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8623 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8624 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8625             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8625             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8625 31 C5 81    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8628             >        ; now we start popping the attributes off the 'stack'
126+  8628 F1          >        pop af                      ; 1,0
126+  8629 C1          >        pop bc                      ; 3,2
126+  862A D1          >        pop de                      ; 5,4
126+  862B E1          >        pop hl                      ; 7,6
126+  862C             >
126+  862C             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  862C 08          >        ex af, af'                  ; swap af with af'
126+  862D D9          >        exx
126+  862E             >
126+  862E             >        ; carry on popping
126+  862E F1          >        pop af                      ; 9,8
126+  862F C1          >        pop bc                      ; 11,10
126+  8630 D1          >        pop de                      ; 13,12
126+  8631 E1          >        pop hl                      ; 15,14
126+  8632             >
126+  8632             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8632             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8632 31 D0 59    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8635             >
126+  8635             >        ; we push back onto the screen memory stack in reverse order
126+  8635 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8636 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8637 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8638 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8639             >
126+  8639             >        ; swap back to the original registers
126+  8639 08          >        ex af, af'
126+  863A D9          >        exx
126+  863B             >
126+  863B E5          >        push hl                     ; copy 7,6 to the screen memory
126+  863C D5          >        push de                     ; copy 5,4 to the screen memory
126+  863D C5          >        push bc                     ; copy 3,2 to the screen memory
126+  863E F5          >        push af                     ; copy 1,0 to the screen memory
126+  863F             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  863F             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  863F 31 D5 81    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  8642             >        ; now we start popping the attributes off the 'stack'
126+  8642 F1          >        pop af                      ; 1,0
126+  8643 C1          >        pop bc                      ; 3,2
126+  8644 D1          >        pop de                      ; 5,4
126+  8645 E1          >        pop hl                      ; 7,6
126+  8646             >
126+  8646             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8646 08          >        ex af, af'                  ; swap af with af'
126+  8647 D9          >        exx
126+  8648             >
126+  8648             >        ; carry on popping
126+  8648 F1          >        pop af                      ; 9,8
126+  8649 C1          >        pop bc                      ; 11,10
126+  864A D1          >        pop de                      ; 13,12
126+  864B E1          >        pop hl                      ; 15,14
126+  864C             >
126+  864C             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  864C             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  864C 31 E0 59    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  864F             >
126+  864F             >        ; we push back onto the screen memory stack in reverse order
126+  864F E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8650 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8651 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8652 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8653             >
126+  8653             >        ; swap back to the original registers
126+  8653 08          >        ex af, af'
126+  8654 D9          >        exx
126+  8655             >
126+  8655 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8656 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8657 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8658 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8659             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8659             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8659 31 E5 81    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  865C             >        ; now we start popping the attributes off the 'stack'
126+  865C F1          >        pop af                      ; 1,0
126+  865D C1          >        pop bc                      ; 3,2
126+  865E D1          >        pop de                      ; 5,4
126+  865F E1          >        pop hl                      ; 7,6
126+  8660             >
126+  8660             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8660 08          >        ex af, af'                  ; swap af with af'
126+  8661 D9          >        exx
126+  8662             >
126+  8662             >        ; carry on popping
126+  8662 F1          >        pop af                      ; 9,8
126+  8663 C1          >        pop bc                      ; 11,10
126+  8664 D1          >        pop de                      ; 13,12
126+  8665 E1          >        pop hl                      ; 15,14
126+  8666             >
126+  8666             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8666             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8666 31 F0 59    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8669             >
126+  8669             >        ; we push back onto the screen memory stack in reverse order
126+  8669 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  866A D5          >        push de                     ; copy 13,12 to the screen memory
126+  866B C5          >        push bc                     ; copy 11,10 to the screen memory
126+  866C F5          >        push af                     ; copy 9,8 to the screen memory
126+  866D             >
126+  866D             >        ; swap back to the original registers
126+  866D 08          >        ex af, af'
126+  866E D9          >        exx
126+  866F             >
126+  866F E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8670 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8671 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8672 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8673             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  8673             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8673 31 F5 81    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  8676             >        ; now we start popping the attributes off the 'stack'
126+  8676 F1          >        pop af                      ; 1,0
126+  8677 C1          >        pop bc                      ; 3,2
126+  8678 D1          >        pop de                      ; 5,4
126+  8679 E1          >        pop hl                      ; 7,6
126+  867A             >
126+  867A             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  867A 08          >        ex af, af'                  ; swap af with af'
126+  867B D9          >        exx
126+  867C             >
126+  867C             >        ; carry on popping
126+  867C F1          >        pop af                      ; 9,8
126+  867D C1          >        pop bc                      ; 11,10
126+  867E D1          >        pop de                      ; 13,12
126+  867F E1          >        pop hl                      ; 15,14
126+  8680             >
126+  8680             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8680             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8680 31 00 5A    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  8683             >
126+  8683             >        ; we push back onto the screen memory stack in reverse order
126+  8683 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8684 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8685 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8686 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8687             >
126+  8687             >        ; swap back to the original registers
126+  8687 08          >        ex af, af'
126+  8688 D9          >        exx
126+  8689             >
126+  8689 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  868A D5          >        push de                     ; copy 5,4 to the screen memory
126+  868B C5          >        push bc                     ; copy 3,2 to the screen memory
126+  868C F5          >        push af                     ; copy 1,0 to the screen memory
126+  868D             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  868D             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  868D 31 05 82    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8690             >        ; now we start popping the attributes off the 'stack'
126+  8690 F1          >        pop af                      ; 1,0
126+  8691 C1          >        pop bc                      ; 3,2
126+  8692 D1          >        pop de                      ; 5,4
126+  8693 E1          >        pop hl                      ; 7,6
126+  8694             >
126+  8694             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8694 08          >        ex af, af'                  ; swap af with af'
126+  8695 D9          >        exx
126+  8696             >
126+  8696             >        ; carry on popping
126+  8696 F1          >        pop af                      ; 9,8
126+  8697 C1          >        pop bc                      ; 11,10
126+  8698 D1          >        pop de                      ; 13,12
126+  8699 E1          >        pop hl                      ; 15,14
126+  869A             >
126+  869A             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  869A             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  869A 31 10 5A    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  869D             >
126+  869D             >        ; we push back onto the screen memory stack in reverse order
126+  869D E5          >        push hl                     ; copy 15,14 to the screen memory
126+  869E D5          >        push de                     ; copy 13,12 to the screen memory
126+  869F C5          >        push bc                     ; copy 11,10 to the screen memory
126+  86A0 F5          >        push af                     ; copy 9,8 to the screen memory
126+  86A1             >
126+  86A1             >        ; swap back to the original registers
126+  86A1 08          >        ex af, af'
126+  86A2 D9          >        exx
126+  86A3             >
126+  86A3 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  86A4 D5          >        push de                     ; copy 5,4 to the screen memory
126+  86A5 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  86A6 F5          >        push af                     ; copy 1,0 to the screen memory
126+  86A7             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  86A7             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  86A7 31 15 82    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  86AA             >        ; now we start popping the attributes off the 'stack'
126+  86AA F1          >        pop af                      ; 1,0
126+  86AB C1          >        pop bc                      ; 3,2
126+  86AC D1          >        pop de                      ; 5,4
126+  86AD E1          >        pop hl                      ; 7,6
126+  86AE             >
126+  86AE             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  86AE 08          >        ex af, af'                  ; swap af with af'
126+  86AF D9          >        exx
126+  86B0             >
126+  86B0             >        ; carry on popping
126+  86B0 F1          >        pop af                      ; 9,8
126+  86B1 C1          >        pop bc                      ; 11,10
126+  86B2 D1          >        pop de                      ; 13,12
126+  86B3 E1          >        pop hl                      ; 15,14
126+  86B4             >
126+  86B4             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  86B4             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  86B4 31 20 5A    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  86B7             >
126+  86B7             >        ; we push back onto the screen memory stack in reverse order
126+  86B7 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  86B8 D5          >        push de                     ; copy 13,12 to the screen memory
126+  86B9 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  86BA F5          >        push af                     ; copy 9,8 to the screen memory
126+  86BB             >
126+  86BB             >        ; swap back to the original registers
126+  86BB 08          >        ex af, af'
126+  86BC D9          >        exx
126+  86BD             >
126+  86BD E5          >        push hl                     ; copy 7,6 to the screen memory
126+  86BE D5          >        push de                     ; copy 5,4 to the screen memory
126+  86BF C5          >        push bc                     ; copy 3,2 to the screen memory
126+  86C0 F5          >        push af                     ; copy 1,0 to the screen memory
126+  86C1             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  86C1             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  86C1 31 25 82    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  86C4             >        ; now we start popping the attributes off the 'stack'
126+  86C4 F1          >        pop af                      ; 1,0
126+  86C5 C1          >        pop bc                      ; 3,2
126+  86C6 D1          >        pop de                      ; 5,4
126+  86C7 E1          >        pop hl                      ; 7,6
126+  86C8             >
126+  86C8             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  86C8 08          >        ex af, af'                  ; swap af with af'
126+  86C9 D9          >        exx
126+  86CA             >
126+  86CA             >        ; carry on popping
126+  86CA F1          >        pop af                      ; 9,8
126+  86CB C1          >        pop bc                      ; 11,10
126+  86CC D1          >        pop de                      ; 13,12
126+  86CD E1          >        pop hl                      ; 15,14
126+  86CE             >
126+  86CE             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  86CE             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  86CE 31 30 5A    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  86D1             >
126+  86D1             >        ; we push back onto the screen memory stack in reverse order
126+  86D1 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  86D2 D5          >        push de                     ; copy 13,12 to the screen memory
126+  86D3 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  86D4 F5          >        push af                     ; copy 9,8 to the screen memory
126+  86D5             >
126+  86D5             >        ; swap back to the original registers
126+  86D5 08          >        ex af, af'
126+  86D6 D9          >        exx
126+  86D7             >
126+  86D7 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  86D8 D5          >        push de                     ; copy 5,4 to the screen memory
126+  86D9 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  86DA F5          >        push af                     ; copy 1,0 to the screen memory
126+  86DB             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  86DB             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  86DB 31 35 82    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  86DE             >        ; now we start popping the attributes off the 'stack'
126+  86DE F1          >        pop af                      ; 1,0
126+  86DF C1          >        pop bc                      ; 3,2
126+  86E0 D1          >        pop de                      ; 5,4
126+  86E1 E1          >        pop hl                      ; 7,6
126+  86E2             >
126+  86E2             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  86E2 08          >        ex af, af'                  ; swap af with af'
126+  86E3 D9          >        exx
126+  86E4             >
126+  86E4             >        ; carry on popping
126+  86E4 F1          >        pop af                      ; 9,8
126+  86E5 C1          >        pop bc                      ; 11,10
126+  86E6 D1          >        pop de                      ; 13,12
126+  86E7 E1          >        pop hl                      ; 15,14
126+  86E8             >
126+  86E8             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  86E8             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  86E8 31 40 5A    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  86EB             >
126+  86EB             >        ; we push back onto the screen memory stack in reverse order
126+  86EB E5          >        push hl                     ; copy 15,14 to the screen memory
126+  86EC D5          >        push de                     ; copy 13,12 to the screen memory
126+  86ED C5          >        push bc                     ; copy 11,10 to the screen memory
126+  86EE F5          >        push af                     ; copy 9,8 to the screen memory
126+  86EF             >
126+  86EF             >        ; swap back to the original registers
126+  86EF 08          >        ex af, af'
126+  86F0 D9          >        exx
126+  86F1             >
126+  86F1 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  86F2 D5          >        push de                     ; copy 5,4 to the screen memory
126+  86F3 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  86F4 F5          >        push af                     ; copy 1,0 to the screen memory
126+  86F5             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  86F5             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  86F5 31 45 82    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  86F8             >        ; now we start popping the attributes off the 'stack'
126+  86F8 F1          >        pop af                      ; 1,0
126+  86F9 C1          >        pop bc                      ; 3,2
126+  86FA D1          >        pop de                      ; 5,4
126+  86FB E1          >        pop hl                      ; 7,6
126+  86FC             >
126+  86FC             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  86FC 08          >        ex af, af'                  ; swap af with af'
126+  86FD D9          >        exx
126+  86FE             >
126+  86FE             >        ; carry on popping
126+  86FE F1          >        pop af                      ; 9,8
126+  86FF C1          >        pop bc                      ; 11,10
126+  8700 D1          >        pop de                      ; 13,12
126+  8701 E1          >        pop hl                      ; 15,14
126+  8702             >
126+  8702             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8702             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8702 31 50 5A    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8705             >
126+  8705             >        ; we push back onto the screen memory stack in reverse order
126+  8705 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8706 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8707 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8708 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8709             >
126+  8709             >        ; swap back to the original registers
126+  8709 08          >        ex af, af'
126+  870A D9          >        exx
126+  870B             >
126+  870B E5          >        push hl                     ; copy 7,6 to the screen memory
126+  870C D5          >        push de                     ; copy 5,4 to the screen memory
126+  870D C5          >        push bc                     ; copy 3,2 to the screen memory
126+  870E F5          >        push af                     ; copy 1,0 to the screen memory
126+  870F             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  870F             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  870F 31 55 82    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  8712             >        ; now we start popping the attributes off the 'stack'
126+  8712 F1          >        pop af                      ; 1,0
126+  8713 C1          >        pop bc                      ; 3,2
126+  8714 D1          >        pop de                      ; 5,4
126+  8715 E1          >        pop hl                      ; 7,6
126+  8716             >
126+  8716             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8716 08          >        ex af, af'                  ; swap af with af'
126+  8717 D9          >        exx
126+  8718             >
126+  8718             >        ; carry on popping
126+  8718 F1          >        pop af                      ; 9,8
126+  8719 C1          >        pop bc                      ; 11,10
126+  871A D1          >        pop de                      ; 13,12
126+  871B E1          >        pop hl                      ; 15,14
126+  871C             >
126+  871C             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  871C             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  871C 31 60 5A    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  871F             >
126+  871F             >        ; we push back onto the screen memory stack in reverse order
126+  871F E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8720 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8721 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8722 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8723             >
126+  8723             >        ; swap back to the original registers
126+  8723 08          >        ex af, af'
126+  8724 D9          >        exx
126+  8725             >
126+  8725 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8726 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8727 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8728 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8729             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8729             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8729 31 65 82    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  872C             >        ; now we start popping the attributes off the 'stack'
126+  872C F1          >        pop af                      ; 1,0
126+  872D C1          >        pop bc                      ; 3,2
126+  872E D1          >        pop de                      ; 5,4
126+  872F E1          >        pop hl                      ; 7,6
126+  8730             >
126+  8730             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8730 08          >        ex af, af'                  ; swap af with af'
126+  8731 D9          >        exx
126+  8732             >
126+  8732             >        ; carry on popping
126+  8732 F1          >        pop af                      ; 9,8
126+  8733 C1          >        pop bc                      ; 11,10
126+  8734 D1          >        pop de                      ; 13,12
126+  8735 E1          >        pop hl                      ; 15,14
126+  8736             >
126+  8736             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8736             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8736 31 70 5A    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8739             >
126+  8739             >        ; we push back onto the screen memory stack in reverse order
126+  8739 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  873A D5          >        push de                     ; copy 13,12 to the screen memory
126+  873B C5          >        push bc                     ; copy 11,10 to the screen memory
126+  873C F5          >        push af                     ; copy 9,8 to the screen memory
126+  873D             >
126+  873D             >        ; swap back to the original registers
126+  873D 08          >        ex af, af'
126+  873E D9          >        exx
126+  873F             >
126+  873F E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8740 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8741 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8742 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8743             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  8743             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8743 31 75 82    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  8746             >        ; now we start popping the attributes off the 'stack'
126+  8746 F1          >        pop af                      ; 1,0
126+  8747 C1          >        pop bc                      ; 3,2
126+  8748 D1          >        pop de                      ; 5,4
126+  8749 E1          >        pop hl                      ; 7,6
126+  874A             >
126+  874A             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  874A 08          >        ex af, af'                  ; swap af with af'
126+  874B D9          >        exx
126+  874C             >
126+  874C             >        ; carry on popping
126+  874C F1          >        pop af                      ; 9,8
126+  874D C1          >        pop bc                      ; 11,10
126+  874E D1          >        pop de                      ; 13,12
126+  874F E1          >        pop hl                      ; 15,14
126+  8750             >
126+  8750             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8750             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8750 31 80 5A    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  8753             >
126+  8753             >        ; we push back onto the screen memory stack in reverse order
126+  8753 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8754 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8755 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8756 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8757             >
126+  8757             >        ; swap back to the original registers
126+  8757 08          >        ex af, af'
126+  8758 D9          >        exx
126+  8759             >
126+  8759 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  875A D5          >        push de                     ; copy 5,4 to the screen memory
126+  875B C5          >        push bc                     ; copy 3,2 to the screen memory
126+  875C F5          >        push af                     ; copy 1,0 to the screen memory
126+  875D             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  875D             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  875D 31 85 82    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8760             >        ; now we start popping the attributes off the 'stack'
126+  8760 F1          >        pop af                      ; 1,0
126+  8761 C1          >        pop bc                      ; 3,2
126+  8762 D1          >        pop de                      ; 5,4
126+  8763 E1          >        pop hl                      ; 7,6
126+  8764             >
126+  8764             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8764 08          >        ex af, af'                  ; swap af with af'
126+  8765 D9          >        exx
126+  8766             >
126+  8766             >        ; carry on popping
126+  8766 F1          >        pop af                      ; 9,8
126+  8767 C1          >        pop bc                      ; 11,10
126+  8768 D1          >        pop de                      ; 13,12
126+  8769 E1          >        pop hl                      ; 15,14
126+  876A             >
126+  876A             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  876A             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  876A 31 90 5A    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  876D             >
126+  876D             >        ; we push back onto the screen memory stack in reverse order
126+  876D E5          >        push hl                     ; copy 15,14 to the screen memory
126+  876E D5          >        push de                     ; copy 13,12 to the screen memory
126+  876F C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8770 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8771             >
126+  8771             >        ; swap back to the original registers
126+  8771 08          >        ex af, af'
126+  8772 D9          >        exx
126+  8773             >
126+  8773 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8774 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8775 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8776 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8777             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  8777             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8777 31 95 82    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  877A             >        ; now we start popping the attributes off the 'stack'
126+  877A F1          >        pop af                      ; 1,0
126+  877B C1          >        pop bc                      ; 3,2
126+  877C D1          >        pop de                      ; 5,4
126+  877D E1          >        pop hl                      ; 7,6
126+  877E             >
126+  877E             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  877E 08          >        ex af, af'                  ; swap af with af'
126+  877F D9          >        exx
126+  8780             >
126+  8780             >        ; carry on popping
126+  8780 F1          >        pop af                      ; 9,8
126+  8781 C1          >        pop bc                      ; 11,10
126+  8782 D1          >        pop de                      ; 13,12
126+  8783 E1          >        pop hl                      ; 15,14
126+  8784             >
126+  8784             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8784             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8784 31 A0 5A    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  8787             >
126+  8787             >        ; we push back onto the screen memory stack in reverse order
126+  8787 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8788 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8789 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  878A F5          >        push af                     ; copy 9,8 to the screen memory
126+  878B             >
126+  878B             >        ; swap back to the original registers
126+  878B 08          >        ex af, af'
126+  878C D9          >        exx
126+  878D             >
126+  878D E5          >        push hl                     ; copy 7,6 to the screen memory
126+  878E D5          >        push de                     ; copy 5,4 to the screen memory
126+  878F C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8790 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8791             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8791             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8791 31 A5 82    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8794             >        ; now we start popping the attributes off the 'stack'
126+  8794 F1          >        pop af                      ; 1,0
126+  8795 C1          >        pop bc                      ; 3,2
126+  8796 D1          >        pop de                      ; 5,4
126+  8797 E1          >        pop hl                      ; 7,6
126+  8798             >
126+  8798             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8798 08          >        ex af, af'                  ; swap af with af'
126+  8799 D9          >        exx
126+  879A             >
126+  879A             >        ; carry on popping
126+  879A F1          >        pop af                      ; 9,8
126+  879B C1          >        pop bc                      ; 11,10
126+  879C D1          >        pop de                      ; 13,12
126+  879D E1          >        pop hl                      ; 15,14
126+  879E             >
126+  879E             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  879E             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  879E 31 B0 5A    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  87A1             >
126+  87A1             >        ; we push back onto the screen memory stack in reverse order
126+  87A1 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  87A2 D5          >        push de                     ; copy 13,12 to the screen memory
126+  87A3 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  87A4 F5          >        push af                     ; copy 9,8 to the screen memory
126+  87A5             >
126+  87A5             >        ; swap back to the original registers
126+  87A5 08          >        ex af, af'
126+  87A6 D9          >        exx
126+  87A7             >
126+  87A7 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  87A8 D5          >        push de                     ; copy 5,4 to the screen memory
126+  87A9 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  87AA F5          >        push af                     ; copy 1,0 to the screen memory
126+  87AB             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  87AB             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  87AB 31 B5 82    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  87AE             >        ; now we start popping the attributes off the 'stack'
126+  87AE F1          >        pop af                      ; 1,0
126+  87AF C1          >        pop bc                      ; 3,2
126+  87B0 D1          >        pop de                      ; 5,4
126+  87B1 E1          >        pop hl                      ; 7,6
126+  87B2             >
126+  87B2             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  87B2 08          >        ex af, af'                  ; swap af with af'
126+  87B3 D9          >        exx
126+  87B4             >
126+  87B4             >        ; carry on popping
126+  87B4 F1          >        pop af                      ; 9,8
126+  87B5 C1          >        pop bc                      ; 11,10
126+  87B6 D1          >        pop de                      ; 13,12
126+  87B7 E1          >        pop hl                      ; 15,14
126+  87B8             >
126+  87B8             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  87B8             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  87B8 31 C0 5A    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  87BB             >
126+  87BB             >        ; we push back onto the screen memory stack in reverse order
126+  87BB E5          >        push hl                     ; copy 15,14 to the screen memory
126+  87BC D5          >        push de                     ; copy 13,12 to the screen memory
126+  87BD C5          >        push bc                     ; copy 11,10 to the screen memory
126+  87BE F5          >        push af                     ; copy 9,8 to the screen memory
126+  87BF             >
126+  87BF             >        ; swap back to the original registers
126+  87BF 08          >        ex af, af'
126+  87C0 D9          >        exx
126+  87C1             >
126+  87C1 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  87C2 D5          >        push de                     ; copy 5,4 to the screen memory
126+  87C3 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  87C4 F5          >        push af                     ; copy 1,0 to the screen memory
126+  87C5             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  87C5             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  87C5 31 C5 82    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  87C8             >        ; now we start popping the attributes off the 'stack'
126+  87C8 F1          >        pop af                      ; 1,0
126+  87C9 C1          >        pop bc                      ; 3,2
126+  87CA D1          >        pop de                      ; 5,4
126+  87CB E1          >        pop hl                      ; 7,6
126+  87CC             >
126+  87CC             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  87CC 08          >        ex af, af'                  ; swap af with af'
126+  87CD D9          >        exx
126+  87CE             >
126+  87CE             >        ; carry on popping
126+  87CE F1          >        pop af                      ; 9,8
126+  87CF C1          >        pop bc                      ; 11,10
126+  87D0 D1          >        pop de                      ; 13,12
126+  87D1 E1          >        pop hl                      ; 15,14
126+  87D2             >
126+  87D2             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  87D2             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  87D2 31 D0 5A    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  87D5             >
126+  87D5             >        ; we push back onto the screen memory stack in reverse order
126+  87D5 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  87D6 D5          >        push de                     ; copy 13,12 to the screen memory
126+  87D7 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  87D8 F5          >        push af                     ; copy 9,8 to the screen memory
126+  87D9             >
126+  87D9             >        ; swap back to the original registers
126+  87D9 08          >        ex af, af'
126+  87DA D9          >        exx
126+  87DB             >
126+  87DB E5          >        push hl                     ; copy 7,6 to the screen memory
126+  87DC D5          >        push de                     ; copy 5,4 to the screen memory
126+  87DD C5          >        push bc                     ; copy 3,2 to the screen memory
126+  87DE F5          >        push af                     ; copy 1,0 to the screen memory
126+  87DF             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  87DF             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  87DF 31 D5 82    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  87E2             >        ; now we start popping the attributes off the 'stack'
126+  87E2 F1          >        pop af                      ; 1,0
126+  87E3 C1          >        pop bc                      ; 3,2
126+  87E4 D1          >        pop de                      ; 5,4
126+  87E5 E1          >        pop hl                      ; 7,6
126+  87E6             >
126+  87E6             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  87E6 08          >        ex af, af'                  ; swap af with af'
126+  87E7 D9          >        exx
126+  87E8             >
126+  87E8             >        ; carry on popping
126+  87E8 F1          >        pop af                      ; 9,8
126+  87E9 C1          >        pop bc                      ; 11,10
126+  87EA D1          >        pop de                      ; 13,12
126+  87EB E1          >        pop hl                      ; 15,14
126+  87EC             >
126+  87EC             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  87EC             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  87EC 31 E0 5A    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  87EF             >
126+  87EF             >        ; we push back onto the screen memory stack in reverse order
126+  87EF E5          >        push hl                     ; copy 15,14 to the screen memory
126+  87F0 D5          >        push de                     ; copy 13,12 to the screen memory
126+  87F1 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  87F2 F5          >        push af                     ; copy 9,8 to the screen memory
126+  87F3             >
126+  87F3             >        ; swap back to the original registers
126+  87F3 08          >        ex af, af'
126+  87F4 D9          >        exx
126+  87F5             >
126+  87F5 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  87F6 D5          >        push de                     ; copy 5,4 to the screen memory
126+  87F7 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  87F8 F5          >        push af                     ; copy 1,0 to the screen memory
126+  87F9             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  87F9             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  87F9 31 E5 82    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  87FC             >        ; now we start popping the attributes off the 'stack'
126+  87FC F1          >        pop af                      ; 1,0
126+  87FD C1          >        pop bc                      ; 3,2
126+  87FE D1          >        pop de                      ; 5,4
126+  87FF E1          >        pop hl                      ; 7,6
126+  8800             >
126+  8800             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8800 08          >        ex af, af'                  ; swap af with af'
126+  8801 D9          >        exx
126+  8802             >
126+  8802             >        ; carry on popping
126+  8802 F1          >        pop af                      ; 9,8
126+  8803 C1          >        pop bc                      ; 11,10
126+  8804 D1          >        pop de                      ; 13,12
126+  8805 E1          >        pop hl                      ; 15,14
126+  8806             >
126+  8806             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8806             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8806 31 F0 5A    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8809             >
126+  8809             >        ; we push back onto the screen memory stack in reverse order
126+  8809 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  880A D5          >        push de                     ; copy 13,12 to the screen memory
126+  880B C5          >        push bc                     ; copy 11,10 to the screen memory
126+  880C F5          >        push af                     ; copy 9,8 to the screen memory
126+  880D             >
126+  880D             >        ; swap back to the original registers
126+  880D 08          >        ex af, af'
126+  880E D9          >        exx
126+  880F             >
126+  880F E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8810 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8811 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8812 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8813             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  8813             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8813 31 F5 82    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  8816             >        ; now we start popping the attributes off the 'stack'
126+  8816 F1          >        pop af                      ; 1,0
126+  8817 C1          >        pop bc                      ; 3,2
126+  8818 D1          >        pop de                      ; 5,4
126+  8819 E1          >        pop hl                      ; 7,6
126+  881A             >
126+  881A             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  881A 08          >        ex af, af'                  ; swap af with af'
126+  881B D9          >        exx
126+  881C             >
126+  881C             >        ; carry on popping
126+  881C F1          >        pop af                      ; 9,8
126+  881D C1          >        pop bc                      ; 11,10
126+  881E D1          >        pop de                      ; 13,12
126+  881F E1          >        pop hl                      ; 15,14
126+  8820             >
126+  8820             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8820             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8820 31 00 5B    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  8823             >
126+  8823             >        ; we push back onto the screen memory stack in reverse order
126+  8823 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8824 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8825 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8826 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8827             >
126+  8827             >        ; swap back to the original registers
126+  8827 08          >        ex af, af'
126+  8828 D9          >        exx
126+  8829             >
126+  8829 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  882A D5          >        push de                     ; copy 5,4 to the screen memory
126+  882B C5          >        push bc                     ; copy 3,2 to the screen memory
126+  882C F5          >        push af                     ; copy 1,0 to the screen memory
126+  882D             >        endr
127+  882D
128+  882D                ; Restore the stack pointer from memory
129+  882D ED 7B 03 80    ld sp, (CopyOfStackPointer)
130+  8831
131+  8831                ; Return from the subroutine
132+  8831 C9             ret
133+  8832
# file closed: /Users/darren/dev/spectrum/zx/project/src/library/doubleBufferAttributes.asm
 20   8832                include "library/colours.asm"
# file opened: /Users/darren/dev/spectrum/zx/project/src/library/colours.asm
  1+  8832              ; *********************************************************************************************************************
  2+  8832              ; Author:  Darren Bowles
  3+  8832              ; Date:    2020-05-03
  4+  8832              ; Purpose: This is currently just colour constants for the ZX Spectrum
  5+  8832              ; *********************************************************************************************************************
  6+  8832
  7+  8832
  8+  8832              STABLE:         equ 0;            %00000000
  9+  8832              FLASHING:       equ 128;          %10000000
 10+  8832
 11+  8832              DULL:           equ 0;            %00000000
 12+  8832              BRIGHT:         equ 64;           %01000000
 13+  8832
 14+  8832              WHITE_PAPER:    equ 56;           %00111000
 15+  8832              YELLOW_PAPER:   equ 48;           %00110000
 16+  8832              CYAN_PAPER:     equ 40;           %00101000
 17+  8832              GREEN_PAPER:    equ 32;           %00100000
 18+  8832              MAGENTA_PAPER:  equ 24;           %00011000
 19+  8832              RED_PAPER:      equ 16;           %00010000
 20+  8832              BLUE_PAPER:     equ 8;            %00001000
 21+  8832              BLACK_PAPER:    equ 0;            %00000000
 22+  8832
 23+  8832              WHITE_INK:      equ 7;            %00000111
 24+  8832              YELLOW_INK:     equ 6;            %00000110
 25+  8832              CYAN_INK:       equ 5;            %00000101
 26+  8832              GREEN_INK:      equ 4;            %00000100
 27+  8832              MAGENTA_INK:    equ 3;            %00000011
 28+  8832              RED_INK:        equ 2;            %00000010
 29+  8832              BLUE_INK:       equ 1;            %00000001
 30+  8832              BLACK_INK:      equ 0;            %00000000
# file closed: /Users/darren/dev/spectrum/zx/project/src/library/colours.asm
 21   8832
 22   8832              ; store the previous timer value
 23   8832 00           previousTimer: defb 0
 24   8833
 25   8833              ; directions
 26   8833              up: equ 1
 27   8833              down: equ 2
 28   8833              left: equ 4
 29   8833              right: equ 8
 30   8833
 31   8833              ; well, just blobs of colour at the moment
 32   8833              ; direction, x, y, colour
 33   8833              aliens:
 34   8833 08 00 00 00    db right, 0,0, BLACK_PAPER
 35   8837 02 00 00 00    db down, 0, 0, BLACK_PAPER
 36   883B 04 1F 17 00    db left, 31, 23, BLACK_PAPER
 37   883F 02 1F 00 00    db down, 31,0, BLACK_PAPER
 38   8843 01 1F 17 00    db up, 31, 23, BLACK_PAPER
 39   8847 08 08 17 00    db right, 8,23, BLACK_PAPER
 40   884B 0A 0F 10 28    db right + down, 15, 16, CYAN_PAPER
 41   884F 04 03 04 28    db left, 3,4, CYAN_PAPER
 42   8853 08 01 02 28    db right, 1,2, CYAN_PAPER
 43   8857 0A 0A 0A 28    db right + down, 10, 10, CYAN_PAPER
 44   885B 02 14 14 28    db down, 20, 20, CYAN_PAPER
 45   885F 01 15 14 28    db up, 21,20, CYAN_PAPER
 46   8863 06 20 14 18    db down + left, 32, 20, MAGENTA_PAPER
 47   8867 0A 05 06 28    db right + down, 5, 6  , CYAN_PAPER
 48   886B 04 0D 0E 28    db left, 13,14, CYAN_PAPER
 49   886F 08 0B 16 28    db right, 11,22, CYAN_PAPER
 50   8873 0A 01 01 28    db right + down, 1, 1, CYAN_PAPER
 51   8877 02 02 02 28    db down, 2, 2, CYAN_PAPER
 52   887B 01 0B 14 28    db up, 11,20, CYAN_PAPER
 53   887F 06 16 0A 28    db down + left, 22, 10, CYAN_PAPER
 54   8883 06 20 00 18    db down + left, 32, 0, MAGENTA_PAPER
 55   8887 06 1E 02 18    db down + left, 30, 2, MAGENTA_PAPER
 56   888B 06 1C 04 18    db down + left, 28, 4, MAGENTA_PAPER
 57   888F 01 04 17 00    db up, 4, 23, BLACK_PAPER
 58   8893 01 05 17 00    db up, 5, 23, BLACK_PAPER
 59   8897 02 0A 00 00    db down, 10, 0, BLACK_PAPER
 60   889B 02 0B 00 00    db down, 11, 0, BLACK_PAPER
 61   889F 01 0F 17 30    db up, 15, 23, YELLOW_PAPER
 62   88A3 01 10 17 30    db up, 16, 23, YELLOW_PAPER
 63   88A7 02 11 00 20    db down, 17, 0, GREEN_PAPER
 64   88AB 02 12 00 20    db down, 18, 0, GREEN_PAPER
 65   88AF 04 20 0A 10    db left, 32, 10, RED_PAPER
 66   88B3 04 20 0B 10    db left, 32, 11, RED_PAPER
 67   88B7 08 00 0A 10    db right, 0, 10, RED_PAPER
 68   88BB 08 00 0B 10    db right, 0, 11, RED_PAPER
 69   88BF 02 0F 00 10    db down, 15, 0, RED_PAPER
 70   88C3 02 10 00 10    db down, 16, 0, RED_PAPER
 71   88C7 01 0F 17 10    db up, 15, 23, RED_PAPER
 72   88CB 01 10 17 10    db up, 16, 23, RED_PAPER
 73   88CF 06 1C 00 08    db down + left, 28, 0, BLUE_PAPER
 74   88D3 06 1D 01 08    db down + left, 29, 1, BLUE_PAPER
 75   88D7 06 1E 02 08    db down + left, 30, 2, BLUE_PAPER
 76   88DB
 77   88DB              numberOfAliens: equ ($ - aliens) / 4
 78   88DB
 79   88DB              start:
 80   88DB                ; This section of code sets up the IM2 interrupt vector table and enables interrupts.
 81   88DB
 82   88DB                ; Disable interrupts
 83   88DB F3             di
 84   88DC
 85   88DC                ; Load the address of the IM2 interrupt vector table into DE
 86   88DC 11 00 FE       ld de, IM2_TABLE
 87   88DF
 88   88DF                ; Load the address of the IM2 interrupt handler into HL
 89   88DF 21 FD FD       ld hl, IM2_VECTOR
 90   88E2
 91   88E2                ; Load the value of D into A and set the interrupt mode to 2
 92   88E2 7A             ld a,d
 93   88E3 ED 47          ld i,a
 94   88E5 ED 5E          im 2
 95   88E7
 96   88E7                ; Fill the IM2 interrupt vector table with the address of the IM2 interrupt handler
 97   88E7              .fill_loop:
 98   88E7 7D             ld a,l
 99   88E8 12             ld (de),a
100   88E9 1C             inc e
101   88EA C2 E7 88       jp nz, .fill_loop
102   88ED 14             inc d
103   88EE 12             ld (de), a
104   88EF
105   88EF              ; Set the IM2 interrupt vector to point to the IM2 interrupt handler
106   88EF 36 C3          ld (hl),$c3
107   88F1 2C             inc l
108   88F2 36 46          ld (hl),low im2_handler
109   88F4 2C             inc l
110   88F5 36 8A          ld (hl),high im2_handler
111   88F7
112   88F7              ; Enable interrupts
113   88F7 FB             ei
114   88F8
115   88F8
116   88F8
117   88F8              gameLoop:
118   88F8
119   88F8              .wait:
120   88F8 21 32 88       ld hl, previousTimer
121   88FB 3A 78 5C       ld a, (23672) ; get the timer
122   88FE 96             sub (hl) ; get the difference between current and previous timer
123   88FF
124   88FF              .keepWaiting2:
125   88FF FE 02          cp 2; have we waited 2 ticks?
126   8901 30 03          jr nc, .wait0 ; no more delay
127   8903
128   8903 C3 F8 88       jp .wait ; wait some more
129   8906              .wait0:
130   8906 3A 78 5C       ld a, (23672) ; get the timer
131   8909 32 32 88       ld (previousTimer), a ; store
132   890C
133   890C 3E 00          ld a, 0
134   890E D3 FE          out (254),a
135   8910
136   8910 DD 21 33 88    ld ix, aliens
137   8914 06 2A          ld b, numberOfAliens
138   8916 0E 00          ld c,0
139   8918              .nextAlien:
140   8918 C5             push bc
141   8919
142   8919 CD 4B 89       call showAlien
143   891C C1             pop bc
144   891D
145   891D 11 04 00       ld de, 4 ; size of the table entry
146   8920 DD 19          add ix, de ; move onto next alien
147   8922 10 F4          djnz .nextAlien
148   8924
149   8924              .display:
150   8924 CD 49 83       call copyScreenAttributes
151   8927 CD 2D 89       call undrawAliens
152   892A C3 F8 88       jp gameLoop
153   892D
154   892D              ; undraws the alien and then moves it
155   892D              undrawAliens:
156   892D DD 21 33 88    ld ix, aliens
157   8931 06 2A          ld b, numberOfAliens
158   8933 0E 00          ld c,0
159   8935              .loop:
160   8935 C5             push bc
161   8936 CD 53 89       call getAlienAddress
162   8939 3E 38          ld a, WHITE_PAPER
163   893B 77             ld (hl), a
164   893C
165   893C
166   893C CD 63 89       call moveAlien
167   893F CD 98 89       call checkBounds
168   8942 C1             pop bc
169   8943
170   8943 11 04 00       ld de, 4 ; size of the table entry
171   8946 DD 19          add ix, de ; next alien
172   8948 10 EB          djnz .loop
173   894A
174   894A C9             ret
175   894B
176   894B              showAlien:
177   894B CD 53 89      call getAlienAddress
178   894E
179   894E DD 7E 03       ld a, (ix+3)
180   8951 77             ld (hl), a ; put it in the buffer
181   8952
182   8952 C9             ret
183   8953
184   8953              getAlienAddress:
185   8953 DD 7E 00       ld a, (ix) ; get the status / direction
186   8956 FE FF          cp 255 ; is it disabled?
187   8958 C8             ret z ; yes, return
188   8959
189   8959 DD 46 01       ld b, (ix+1) ; get x coordinate
190   895C DD 4E 02       ld c, (ix+2) ; get y coordinate
191   895F
192   895F CD 35 83       call CalculateAttributeBufferAddress
193   8962 C9             ret
194   8963
195   8963              moveAlien:
196   8963 DD 7E 00       ld a, (ix)
197   8966 E6 01          and up
198   8968 C4 84 89       call nz, moveAlienUp
199   896B
200   896B DD 7E 00       ld a, (ix)
201   896E E6 02          and down
202   8970 C4 89 89       call nz, moveAlienDown
203   8973
204   8973 DD 7E 00       ld a, (ix)
205   8976 E6 04          and left
206   8978 C4 8E 89       call nz, moveAlienLeft
207   897B
208   897B DD 7E 00       ld a, (ix)
209   897E E6 08          and right
210   8980 C4 93 89       call nz, moveAlienRight
211   8983
212   8983 C9             ret
213   8984
214   8984              moveAlienUp:
215   8984 0D             dec c
216   8985 DD 71 02       ld (ix+2), c
217   8988 C9             ret
218   8989              moveAlienDown:
219   8989 0C             inc c
220   898A DD 71 02       ld (ix+2), c
221   898D C9             ret
222   898E              moveAlienLeft:
223   898E 05             dec b
224   898F DD 70 01       ld (ix+1), b
225   8992 C9             ret
226   8993              moveAlienRight:
227   8993 04             inc b
228   8994 DD 70 01       ld (ix+1), b
229   8997 C9             ret
230   8998
231   8998              checkBounds:
232   8998                ; the position is stored in bc
233   8998 DD 7E 00       ld a, (ix) ;  load the direction / status into D
234   899B
235   899B              .checkRight:
236   899B                ; are we going right
237   899B CB 5F          bit 3, a
238   899D 28 0F          jr z, .checkLeft
239   899F                ; if we are going right, check if we've hit the right boundary
240   899F 78             ld a, b ; load the X position into A
241   89A0 FE 1F          cp 31                    ; compare with the right boundary
242   89A2 20 0A          jr nz, .checkLeft        ; if A < 31, we haven't hit the right boundary
243   89A4 DD 7E 00       ld a, (ix)
244   89A7 E6 F7          and 255 - right
245   89A9 F6 04          or left
246   89AB DD 77 00       ld (ix), a
247   89AE
248   89AE
249   89AE              .checkLeft:
250   89AE                ; are we going left
251   89AE DD 7E 00       ld a, (ix) ;  load the direction / status into D
252   89B1 CB 57          bit 2, a
253   89B3 28 0F          jr z, .checkUp
254   89B5                ; if we are going left, check if we've hit the left boundary
255   89B5 78             ld a, b ; load the X position into A
256   89B6 FE 00          cp 0
257   89B8 20 0A          jr nz, .checkUp
258   89BA DD 7E 00       ld a, (ix)
259   89BD E6 FB          and 255 - left
260   89BF F6 08          or right
261   89C1 DD 77 00       ld (ix), a
262   89C4
263   89C4              .checkUp:
264   89C4                ; are we going up
265   89C4 DD 7E 00       ld a, (ix) ;  load the direction / status into D
266   89C7 CB 47          bit 0, a
267   89C9 28 12          jr z, .checkDown
268   89CB                ; if we are going up, check if we've hit the top boundary
269   89CB 79             ld a, c
270   89CC FE 00          cp 0
271   89CE 20 0D          jr nz, .checkDown
272   89D0 DD 7E 00       ld a, (ix)
273   89D3 E6 FE          and 255 - up
274   89D5 F6 02          or down
275   89D7 DD 77 00       ld (ix), a
276   89DA C3 F3 89       jp .done
277   89DD
278   89DD              .checkDown:
279   89DD                ; are we going down
280   89DD DD 7E 00       ld a, (ix) ;  load the direction / status into D
281   89E0 CB 4F          bit 1, a
282   89E2 28 0F          jr z, .done
283   89E4                ; if we are going down, check if we've hit the bottom boundary
284   89E4 79             ld a, c
285   89E5 FE 17          cp 23                    ; compare with the bottom boundary
286   89E7 20 0A          jr nz, .done             ; if A < 23, we haven't hit the bottom boundary
287   89E9 DD 7E 00       ld a, (ix)
288   89EC E6 FD          and 255 - down
289   89EE F6 01          or up
290   89F0 DD 77 00       ld (ix), a
291   89F3              .done:
292   89F3 C9             ret
293   89F4
294   89F4
295   89F4 FE 1F          cp 31                    ; compare with the right boundary
296   89F6 30 3B          jr nc, hitRightBoundary  ; if A >= 31, we've hit the right boundary
297   89F8 B7             or a                     ; check if A is 0 (the left boundary)
298   89F9 28 25          jr z, hitLeftBoundary    ; if A == 0, we've hit the left boundary
299   89FB              checkUpperLowerScreenBounds:
300   89FB                                   ; move to Y position in memory
301   89FB 79             ld a, c               ; load the Y position into A
302   89FC FE 17          cp 23                    ; compare with the bottom boundary
303   89FE 30 12          jr nc, hitBottomBoundary ; if A >= 23, we've hit the bottom boundary
304   8A00 B7             or a                     ; check if A is 0 (the top boundary)
305   8A01 28 01          jr z, hitTopBoundary     ; if A == 0, we've hit the top boundary
306   8A03
307   8A03 C9             ret
308   8A04
309   8A04              hitTopBoundary:
310   8A04 DD 7E 00       ld a, (ix)
311   8A07
312   8A07 CB 47          bit 0, a            ; Check if the "down" bit is set in A.
313   8A09 C8             ret z  ; If the "down" bit is not set, we don't need to change the direction.
314   8A0A
315   8A0A
316   8A0A E6 FE          and 255 - up
317   8A0C F6 02          or down
318   8A0E DD 77 00       ld (ix), a
319   8A11 C9             ret
320   8A12
321   8A12              ; This function is called when the alien hits the bottom boundary of the screen.
322   8A12              ; It plays a sound effect, changes the direction of the alien to move up, and returns.
323   8A12
324   8A12              hitBottomBoundary:
325   8A12 DD 7E 00       ld a, (ix)          ; Load the current direction of the alien into A.
326   8A15
327   8A15 CB 4F          bit 1, a            ; Check if the "down" bit is set in A.
328   8A17 C8             ret z  ; If the "down" bit is not set, we don't need to change the direction.
329   8A18
330   8A18
331   8A18 E6 FD          and 255 - down      ; Clear the "down" bit in A by ANDing it with the bitwise complement of "down".
332   8A1A F6 01          or up               ; Set the "up" bit in A by ORing it with "up".
333   8A1C DD 77 00       ld (ix), a          ; Store the new direction back into memory.
334   8A1F C9             ret                 ; Return from the function.
335   8A20
336   8A20              hitLeftBoundary:
337   8A20 DD 7E 00       ld a, (ix)
338   8A23 CB 5F          bit 3,a
339   8A25 CA FB 89       jp z, checkUpperLowerScreenBounds ; If the "left" bit is not set, we don't need to change the direction.
340   8A28 E6 FB          and 255 - left
341   8A2A F6 08          or right
342   8A2C DD 77 00       ld (ix), a
343   8A2F C3 FB 89       jp checkUpperLowerScreenBounds
344   8A32 C9             ret
345   8A33              hitRightBoundary:
346   8A33 DD 7E 00       ld a, (ix)
347   8A36
348   8A36 CB 67          bit 4, a ; Check if the "right" bit is set in A.
349   8A38 CA FB 89       jp z, checkUpperLowerScreenBounds ; If the "right" bit is not set, we don't need to change the direction.
350   8A3B
351   8A3B E6 F7          and 255 - right
352   8A3D F6 04          or left
353   8A3F DD 77 00       ld (ix), a
354   8A42 C3 FB 89       jp checkUpperLowerScreenBounds
355   8A45 C9             ret
356   8A46
357   8A46              im2_handler:
358   8A46 F5             push af
359   8A47 C5             push bc
360   8A48 D5             push de
361   8A49 E5             push hl
362   8A4A 08             ex af,af'
363   8A4B D9             exx
364   8A4C F5             push af
365   8A4D C5             push bc
366   8A4E D5             push de
367   8A4F E5             push hl
368   8A50 DD E5          push ix
369   8A52 FD E5          push iy
370   8A54
371   8A54
372   8A54
373   8A54                ;rst 56 ; read the keys and update clock
374   8A54 2A 78 5C       ld hl, (23672)
375   8A57 23             inc hl
376   8A58 22 78 5C       ld (23672), hl
377   8A5B 7C             ld a,h
378   8A5C B5             or l
379   8A5D
380   8A5D                ; ^^ this is the same as rst 56
381   8A5D
382   8A5D FD E1          pop iy
383   8A5F DD E1          pop ix
384   8A61 E1             pop hl
385   8A62 D1             pop de
386   8A63 C1             pop bc
387   8A64 F1             pop af
388   8A65 08             ex af,af'
389   8A66 D9             exx
390   8A67 E1             pop hl
391   8A68 D1             pop de
392   8A69 C1             pop bc
393   8A6A F1             pop af
394   8A6B FB             ei
395   8A6C C9             ret
396   8A6D
397   8A6D
398   8A6D              ; Deployment
399   8A6D                savesna "myapp.sna",start  ; Save the program as a snapshot file
# file closed: /Users/darren/dev/spectrum/zx/project/src/myapp.asm
