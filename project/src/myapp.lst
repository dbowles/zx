# file opened: /Users/darren/dev/spectrum/zx/project/src/myapp.asm
  1   0000              ; *********************************************************************************************************************
  2   0000              ; Author:  Darren Bowles
  3   0000              ; Date:    2020-05-03
  4   0000              ; Purpose: This is just a test to help me learn coding Z80 on a ZX Spectrum
  5   0000              ; shout out to Jonathan Cauldwell for their excellent tutorials and Allan Turvey of Happy Coding ZX for
  6   0000              ; inspiration from his live streaming warts n all coding session on Lunar Rescue conversion
  7   0000              ; *********************************************************************************************************************
  8   0000
  9   0000
 10   0000                device zxspectrum48
 11   0000
 12   0000              IM2_TABLE   = $FE00 ; IM2 interrupt vector table in decimal is 65024
 13   0000              IM2_VECTOR  = $FDFD ; IM2 interrupt vector in decimal is 65021
 14   0000
 15   0000
 16   0000                org 32768             ; Set the origin of the program to 32768 (the start of the BASIC area)
 17   8000 C3 8B 89       jp start              ; Jump to the start of the program
 18   8003
 19   8003                include "library/doubleBufferAttributes.asm"
# file opened: /Users/darren/dev/spectrum/zx/project/src/library/doubleBufferAttributes.asm
  1+  8003              ; *********************************************************************************************************************
  2+  8003              ; Author:  Darren Bowles
  3+  8003              ; Date:    2020-05-03
  4+  8003              ; Purpose: This is a simple example of how to do double buffering with the screen attributes
  5+  8003              ; It's the same style that Jonathan Cauldwell mentions as being used in Rallybug
  6+  8003              ; see https://chuntey.wordpress.com/tag/double-buffering/ apart from i'm not doing screen memory (yet)
  7+  8003              ; and it's using some sjasmplus macros
  8+  8003              ; *********************************************************************************************************************
  9+  8003
 10+  8003              ; we'll need to keep a copy of the stack pointer, as we'll be moving it around
 11+  8003 00 00        CopyOfStackPointer: defw 0
 12+  8005
 13+  8005                  ; this macro copies over the screen attributes from the attribute buffer to the screen
 14+  8005                  macro DoCopy row, columnStart
 15+  8005 ~                    ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
 16+  8005 ~                    ld sp, AttributeBuffer + (row * 32) + columnStart
 17+  8005 ~                    ; now we start popping the attributes off the 'stack'
 18+  8005 ~                    pop af                      ; 1,0
 19+  8005 ~                    pop bc                      ; 3,2
 20+  8005 ~                    pop de                      ; 5,4
 21+  8005 ~                    pop hl                      ; 7,6
 22+  8005 ~
 23+  8005 ~                    ; oops, we've run out of registers, so we need to swap to alternate registers
 24+  8005 ~                    ex af, af'                  ; swap af with af'
 25+  8005 ~                    exx
 26+  8005 ~
 27+  8005 ~                    ; carry on popping
 28+  8005 ~                    pop af                      ; 9,8
 29+  8005 ~                    pop bc                      ; 11,10
 30+  8005 ~                    pop de                      ; 13,12
 31+  8005 ~                    pop hl                      ; 15,14
 32+  8005 ~
 33+  8005 ~                    ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
 34+  8005 ~                    ; as well as including the 16 bytes that we popped off the buffer stack and stored
 35+  8005 ~                    ld sp, $5800 + (row * 32) + columnStart + 16
 36+  8005 ~
 37+  8005 ~                    ; we push back onto the screen memory stack in reverse order
 38+  8005 ~                    push hl                     ; copy 15,14 to the screen memory
 39+  8005 ~                    push de                     ; copy 13,12 to the screen memory
 40+  8005 ~                    push bc                     ; copy 11,10 to the screen memory
 41+  8005 ~                    push af                     ; copy 9,8 to the screen memory
 42+  8005 ~
 43+  8005 ~                    ; swap back to the original registers
 44+  8005 ~                    ex af, af'
 45+  8005 ~                    exx
 46+  8005 ~
 47+  8005 ~                    push hl                     ; copy 7,6 to the screen memory
 48+  8005 ~                    push de                     ; copy 5,4 to the screen memory
 49+  8005 ~                    push bc                     ; copy 3,2 to the screen memory
 50+  8005 ~                    push af                     ; copy 1,0 to the screen memory
 51+  8005                  endm
 52+  8005
 53+  8005                  ; this macro copies over a number of rows
 54+  8005                  macro BufferCopyMacro count
 55+  8005 ~                    rept count, i
 56+  8005 ~                        DoCopy i, 0   ; copy the first 16 attributes over to the row
 57+  8005 ~                        DoCopy i, 16  ; copy the remaining 16 attributes over to the row
 58+  8005 ~                    endr
 59+  8005                  endm
 60+  8005
 61+  8005                  ; this macro generates the lookup table for the attribute buffer
 62+  8005                  macro AttributeBufferLookupMacro count
 63+  8005 ~                    rept count, i
 64+  8005 ~                        defw AttributeBuffer + (32 * i)
 65+  8005 ~                    endr
 66+  8005                  endm
 67+  8005
 68+  8005              ; here's our buffer - let's initialise it to all white paper, black ink
 69+  8005              AttributeBuffer:
 70+  8005 07 07 07...      block 768, STABLE + DULL + BLACK_PAPER + WHITE_INK
 71+  8305
 72+  8305              ; here's our lookup table
 73+  8305              AttributeBufferLookup:
 74+  8305                  AttributeBufferLookupMacro 24;
 74+  8305             >        rept 24, i
 74+  8305 05 80       >            defw AttributeBuffer + (32 * i)
 74+  8307 25 80       >            defw AttributeBuffer + (32 * i)
 74+  8309 45 80       >            defw AttributeBuffer + (32 * i)
 74+  830B 65 80       >            defw AttributeBuffer + (32 * i)
 74+  830D 85 80       >            defw AttributeBuffer + (32 * i)
 74+  830F A5 80       >            defw AttributeBuffer + (32 * i)
 74+  8311 C5 80       >            defw AttributeBuffer + (32 * i)
 74+  8313 E5 80       >            defw AttributeBuffer + (32 * i)
 74+  8315 05 81       >            defw AttributeBuffer + (32 * i)
 74+  8317 25 81       >            defw AttributeBuffer + (32 * i)
 74+  8319 45 81       >            defw AttributeBuffer + (32 * i)
 74+  831B 65 81       >            defw AttributeBuffer + (32 * i)
 74+  831D 85 81       >            defw AttributeBuffer + (32 * i)
 74+  831F A5 81       >            defw AttributeBuffer + (32 * i)
 74+  8321 C5 81       >            defw AttributeBuffer + (32 * i)
 74+  8323 E5 81       >            defw AttributeBuffer + (32 * i)
 74+  8325 05 82       >            defw AttributeBuffer + (32 * i)
 74+  8327 25 82       >            defw AttributeBuffer + (32 * i)
 74+  8329 45 82       >            defw AttributeBuffer + (32 * i)
 74+  832B 65 82       >            defw AttributeBuffer + (32 * i)
 74+  832D 85 82       >            defw AttributeBuffer + (32 * i)
 74+  832F A5 82       >            defw AttributeBuffer + (32 * i)
 74+  8331 C5 82       >            defw AttributeBuffer + (32 * i)
 74+  8333 E5 82       >            defw AttributeBuffer + (32 * i)
 74+  8335             >        endr
 75+  8335
 76+  8335
 77+  8335              ; CalculateAttributeBufferAddress - Calculates the attribute buffer address for a given position (X, Y)
 78+  8335              ;
 79+  8335              ; Input:
 80+  8335              ;   B: X coordinate (0-31)
 81+  8335              ;   C: Y coordinate (0-23)
 82+  8335              ;
 83+  8335              ; Output:
 84+  8335              ;   HL: Attribute Buffer address
 85+  8335              ;
 86+  8335              CalculateAttributeBufferAddress:
 87+  8335                ; Load the address of the lookup table into HL
 88+  8335 21 05 83       ld hl, AttributeBufferLookup
 89+  8338
 90+  8338                ; Double the Y coordinate by adding it to itself
 91+  8338 79             ld a, c
 92+  8339 87             add a, a
 93+  833A 85             add a, l
 94+  833B 6F             ld l, a
 95+  833C
 96+  833C                ; Get the table address for the Y coordinate
 97+  833C 5E 23 56 2B    ld de, (hl)
 98+  8340
 99+  8340                ; Add the X coordinate (in register B) to the table address (in register E)
100+  8340 78             ld a, b
101+  8341 83             add a, e
102+  8342 5F             ld e, a
103+  8343
104+  8343                ; Check if we got a carry (i.e. we exceeded 255)
105+  8343 30 01          jr nc, .noCarry
106+  8345
107+  8345                ; If we got a carry, increment the high byte of the address
108+  8345 14             inc d
109+  8346
110+  8346              .noCarry:
111+  8346                ; Move the combined address into HL
112+  8346 62 6B          ld hl, de
113+  8348
114+  8348                ; Return from the subroutine
115+  8348 C9             ret
116+  8349
117+  8349
118+  8349              ; Copy the attributes buffer to the screen attributes
119+  8349              ; TODO: This is a crude implementation that copies the entire buffer.
120+  8349              ; A more efficient implementation is possible.
121+  8349              copyScreenAttributes:
122+  8349                ; Save the current stack pointer to memory
123+  8349 ED 73 03 80    ld (CopyOfStackPointer), sp
124+  834D
125+  834D                ; Call the "BufferCopyMacro" macro to copy the buffer
126+  834D                BufferCopyMacro 24
126+  834D             >        rept 24, i
126+  834D             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  834D             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  834D 31 05 80    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8350             >        ; now we start popping the attributes off the 'stack'
126+  8350 F1          >        pop af                      ; 1,0
126+  8351 C1          >        pop bc                      ; 3,2
126+  8352 D1          >        pop de                      ; 5,4
126+  8353 E1          >        pop hl                      ; 7,6
126+  8354             >
126+  8354             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8354 08          >        ex af, af'                  ; swap af with af'
126+  8355 D9          >        exx
126+  8356             >
126+  8356             >        ; carry on popping
126+  8356 F1          >        pop af                      ; 9,8
126+  8357 C1          >        pop bc                      ; 11,10
126+  8358 D1          >        pop de                      ; 13,12
126+  8359 E1          >        pop hl                      ; 15,14
126+  835A             >
126+  835A             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  835A             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  835A 31 10 58    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  835D             >
126+  835D             >        ; we push back onto the screen memory stack in reverse order
126+  835D E5          >        push hl                     ; copy 15,14 to the screen memory
126+  835E D5          >        push de                     ; copy 13,12 to the screen memory
126+  835F C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8360 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8361             >
126+  8361             >        ; swap back to the original registers
126+  8361 08          >        ex af, af'
126+  8362 D9          >        exx
126+  8363             >
126+  8363 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8364 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8365 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8366 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8367             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  8367             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8367 31 15 80    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  836A             >        ; now we start popping the attributes off the 'stack'
126+  836A F1          >        pop af                      ; 1,0
126+  836B C1          >        pop bc                      ; 3,2
126+  836C D1          >        pop de                      ; 5,4
126+  836D E1          >        pop hl                      ; 7,6
126+  836E             >
126+  836E             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  836E 08          >        ex af, af'                  ; swap af with af'
126+  836F D9          >        exx
126+  8370             >
126+  8370             >        ; carry on popping
126+  8370 F1          >        pop af                      ; 9,8
126+  8371 C1          >        pop bc                      ; 11,10
126+  8372 D1          >        pop de                      ; 13,12
126+  8373 E1          >        pop hl                      ; 15,14
126+  8374             >
126+  8374             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8374             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8374 31 20 58    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  8377             >
126+  8377             >        ; we push back onto the screen memory stack in reverse order
126+  8377 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8378 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8379 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  837A F5          >        push af                     ; copy 9,8 to the screen memory
126+  837B             >
126+  837B             >        ; swap back to the original registers
126+  837B 08          >        ex af, af'
126+  837C D9          >        exx
126+  837D             >
126+  837D E5          >        push hl                     ; copy 7,6 to the screen memory
126+  837E D5          >        push de                     ; copy 5,4 to the screen memory
126+  837F C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8380 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8381             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8381             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8381 31 25 80    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8384             >        ; now we start popping the attributes off the 'stack'
126+  8384 F1          >        pop af                      ; 1,0
126+  8385 C1          >        pop bc                      ; 3,2
126+  8386 D1          >        pop de                      ; 5,4
126+  8387 E1          >        pop hl                      ; 7,6
126+  8388             >
126+  8388             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8388 08          >        ex af, af'                  ; swap af with af'
126+  8389 D9          >        exx
126+  838A             >
126+  838A             >        ; carry on popping
126+  838A F1          >        pop af                      ; 9,8
126+  838B C1          >        pop bc                      ; 11,10
126+  838C D1          >        pop de                      ; 13,12
126+  838D E1          >        pop hl                      ; 15,14
126+  838E             >
126+  838E             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  838E             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  838E 31 30 58    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8391             >
126+  8391             >        ; we push back onto the screen memory stack in reverse order
126+  8391 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8392 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8393 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8394 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8395             >
126+  8395             >        ; swap back to the original registers
126+  8395 08          >        ex af, af'
126+  8396 D9          >        exx
126+  8397             >
126+  8397 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8398 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8399 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  839A F5          >        push af                     ; copy 1,0 to the screen memory
126+  839B             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  839B             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  839B 31 35 80    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  839E             >        ; now we start popping the attributes off the 'stack'
126+  839E F1          >        pop af                      ; 1,0
126+  839F C1          >        pop bc                      ; 3,2
126+  83A0 D1          >        pop de                      ; 5,4
126+  83A1 E1          >        pop hl                      ; 7,6
126+  83A2             >
126+  83A2             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  83A2 08          >        ex af, af'                  ; swap af with af'
126+  83A3 D9          >        exx
126+  83A4             >
126+  83A4             >        ; carry on popping
126+  83A4 F1          >        pop af                      ; 9,8
126+  83A5 C1          >        pop bc                      ; 11,10
126+  83A6 D1          >        pop de                      ; 13,12
126+  83A7 E1          >        pop hl                      ; 15,14
126+  83A8             >
126+  83A8             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  83A8             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  83A8 31 40 58    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  83AB             >
126+  83AB             >        ; we push back onto the screen memory stack in reverse order
126+  83AB E5          >        push hl                     ; copy 15,14 to the screen memory
126+  83AC D5          >        push de                     ; copy 13,12 to the screen memory
126+  83AD C5          >        push bc                     ; copy 11,10 to the screen memory
126+  83AE F5          >        push af                     ; copy 9,8 to the screen memory
126+  83AF             >
126+  83AF             >        ; swap back to the original registers
126+  83AF 08          >        ex af, af'
126+  83B0 D9          >        exx
126+  83B1             >
126+  83B1 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  83B2 D5          >        push de                     ; copy 5,4 to the screen memory
126+  83B3 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  83B4 F5          >        push af                     ; copy 1,0 to the screen memory
126+  83B5             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  83B5             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  83B5 31 45 80    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  83B8             >        ; now we start popping the attributes off the 'stack'
126+  83B8 F1          >        pop af                      ; 1,0
126+  83B9 C1          >        pop bc                      ; 3,2
126+  83BA D1          >        pop de                      ; 5,4
126+  83BB E1          >        pop hl                      ; 7,6
126+  83BC             >
126+  83BC             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  83BC 08          >        ex af, af'                  ; swap af with af'
126+  83BD D9          >        exx
126+  83BE             >
126+  83BE             >        ; carry on popping
126+  83BE F1          >        pop af                      ; 9,8
126+  83BF C1          >        pop bc                      ; 11,10
126+  83C0 D1          >        pop de                      ; 13,12
126+  83C1 E1          >        pop hl                      ; 15,14
126+  83C2             >
126+  83C2             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  83C2             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  83C2 31 50 58    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  83C5             >
126+  83C5             >        ; we push back onto the screen memory stack in reverse order
126+  83C5 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  83C6 D5          >        push de                     ; copy 13,12 to the screen memory
126+  83C7 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  83C8 F5          >        push af                     ; copy 9,8 to the screen memory
126+  83C9             >
126+  83C9             >        ; swap back to the original registers
126+  83C9 08          >        ex af, af'
126+  83CA D9          >        exx
126+  83CB             >
126+  83CB E5          >        push hl                     ; copy 7,6 to the screen memory
126+  83CC D5          >        push de                     ; copy 5,4 to the screen memory
126+  83CD C5          >        push bc                     ; copy 3,2 to the screen memory
126+  83CE F5          >        push af                     ; copy 1,0 to the screen memory
126+  83CF             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  83CF             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  83CF 31 55 80    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  83D2             >        ; now we start popping the attributes off the 'stack'
126+  83D2 F1          >        pop af                      ; 1,0
126+  83D3 C1          >        pop bc                      ; 3,2
126+  83D4 D1          >        pop de                      ; 5,4
126+  83D5 E1          >        pop hl                      ; 7,6
126+  83D6             >
126+  83D6             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  83D6 08          >        ex af, af'                  ; swap af with af'
126+  83D7 D9          >        exx
126+  83D8             >
126+  83D8             >        ; carry on popping
126+  83D8 F1          >        pop af                      ; 9,8
126+  83D9 C1          >        pop bc                      ; 11,10
126+  83DA D1          >        pop de                      ; 13,12
126+  83DB E1          >        pop hl                      ; 15,14
126+  83DC             >
126+  83DC             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  83DC             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  83DC 31 60 58    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  83DF             >
126+  83DF             >        ; we push back onto the screen memory stack in reverse order
126+  83DF E5          >        push hl                     ; copy 15,14 to the screen memory
126+  83E0 D5          >        push de                     ; copy 13,12 to the screen memory
126+  83E1 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  83E2 F5          >        push af                     ; copy 9,8 to the screen memory
126+  83E3             >
126+  83E3             >        ; swap back to the original registers
126+  83E3 08          >        ex af, af'
126+  83E4 D9          >        exx
126+  83E5             >
126+  83E5 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  83E6 D5          >        push de                     ; copy 5,4 to the screen memory
126+  83E7 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  83E8 F5          >        push af                     ; copy 1,0 to the screen memory
126+  83E9             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  83E9             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  83E9 31 65 80    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  83EC             >        ; now we start popping the attributes off the 'stack'
126+  83EC F1          >        pop af                      ; 1,0
126+  83ED C1          >        pop bc                      ; 3,2
126+  83EE D1          >        pop de                      ; 5,4
126+  83EF E1          >        pop hl                      ; 7,6
126+  83F0             >
126+  83F0             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  83F0 08          >        ex af, af'                  ; swap af with af'
126+  83F1 D9          >        exx
126+  83F2             >
126+  83F2             >        ; carry on popping
126+  83F2 F1          >        pop af                      ; 9,8
126+  83F3 C1          >        pop bc                      ; 11,10
126+  83F4 D1          >        pop de                      ; 13,12
126+  83F5 E1          >        pop hl                      ; 15,14
126+  83F6             >
126+  83F6             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  83F6             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  83F6 31 70 58    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  83F9             >
126+  83F9             >        ; we push back onto the screen memory stack in reverse order
126+  83F9 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  83FA D5          >        push de                     ; copy 13,12 to the screen memory
126+  83FB C5          >        push bc                     ; copy 11,10 to the screen memory
126+  83FC F5          >        push af                     ; copy 9,8 to the screen memory
126+  83FD             >
126+  83FD             >        ; swap back to the original registers
126+  83FD 08          >        ex af, af'
126+  83FE D9          >        exx
126+  83FF             >
126+  83FF E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8400 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8401 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8402 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8403             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  8403             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8403 31 75 80    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  8406             >        ; now we start popping the attributes off the 'stack'
126+  8406 F1          >        pop af                      ; 1,0
126+  8407 C1          >        pop bc                      ; 3,2
126+  8408 D1          >        pop de                      ; 5,4
126+  8409 E1          >        pop hl                      ; 7,6
126+  840A             >
126+  840A             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  840A 08          >        ex af, af'                  ; swap af with af'
126+  840B D9          >        exx
126+  840C             >
126+  840C             >        ; carry on popping
126+  840C F1          >        pop af                      ; 9,8
126+  840D C1          >        pop bc                      ; 11,10
126+  840E D1          >        pop de                      ; 13,12
126+  840F E1          >        pop hl                      ; 15,14
126+  8410             >
126+  8410             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8410             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8410 31 80 58    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  8413             >
126+  8413             >        ; we push back onto the screen memory stack in reverse order
126+  8413 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8414 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8415 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8416 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8417             >
126+  8417             >        ; swap back to the original registers
126+  8417 08          >        ex af, af'
126+  8418 D9          >        exx
126+  8419             >
126+  8419 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  841A D5          >        push de                     ; copy 5,4 to the screen memory
126+  841B C5          >        push bc                     ; copy 3,2 to the screen memory
126+  841C F5          >        push af                     ; copy 1,0 to the screen memory
126+  841D             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  841D             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  841D 31 85 80    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8420             >        ; now we start popping the attributes off the 'stack'
126+  8420 F1          >        pop af                      ; 1,0
126+  8421 C1          >        pop bc                      ; 3,2
126+  8422 D1          >        pop de                      ; 5,4
126+  8423 E1          >        pop hl                      ; 7,6
126+  8424             >
126+  8424             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8424 08          >        ex af, af'                  ; swap af with af'
126+  8425 D9          >        exx
126+  8426             >
126+  8426             >        ; carry on popping
126+  8426 F1          >        pop af                      ; 9,8
126+  8427 C1          >        pop bc                      ; 11,10
126+  8428 D1          >        pop de                      ; 13,12
126+  8429 E1          >        pop hl                      ; 15,14
126+  842A             >
126+  842A             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  842A             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  842A 31 90 58    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  842D             >
126+  842D             >        ; we push back onto the screen memory stack in reverse order
126+  842D E5          >        push hl                     ; copy 15,14 to the screen memory
126+  842E D5          >        push de                     ; copy 13,12 to the screen memory
126+  842F C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8430 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8431             >
126+  8431             >        ; swap back to the original registers
126+  8431 08          >        ex af, af'
126+  8432 D9          >        exx
126+  8433             >
126+  8433 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8434 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8435 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8436 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8437             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  8437             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8437 31 95 80    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  843A             >        ; now we start popping the attributes off the 'stack'
126+  843A F1          >        pop af                      ; 1,0
126+  843B C1          >        pop bc                      ; 3,2
126+  843C D1          >        pop de                      ; 5,4
126+  843D E1          >        pop hl                      ; 7,6
126+  843E             >
126+  843E             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  843E 08          >        ex af, af'                  ; swap af with af'
126+  843F D9          >        exx
126+  8440             >
126+  8440             >        ; carry on popping
126+  8440 F1          >        pop af                      ; 9,8
126+  8441 C1          >        pop bc                      ; 11,10
126+  8442 D1          >        pop de                      ; 13,12
126+  8443 E1          >        pop hl                      ; 15,14
126+  8444             >
126+  8444             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8444             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8444 31 A0 58    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  8447             >
126+  8447             >        ; we push back onto the screen memory stack in reverse order
126+  8447 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8448 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8449 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  844A F5          >        push af                     ; copy 9,8 to the screen memory
126+  844B             >
126+  844B             >        ; swap back to the original registers
126+  844B 08          >        ex af, af'
126+  844C D9          >        exx
126+  844D             >
126+  844D E5          >        push hl                     ; copy 7,6 to the screen memory
126+  844E D5          >        push de                     ; copy 5,4 to the screen memory
126+  844F C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8450 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8451             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8451             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8451 31 A5 80    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8454             >        ; now we start popping the attributes off the 'stack'
126+  8454 F1          >        pop af                      ; 1,0
126+  8455 C1          >        pop bc                      ; 3,2
126+  8456 D1          >        pop de                      ; 5,4
126+  8457 E1          >        pop hl                      ; 7,6
126+  8458             >
126+  8458             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8458 08          >        ex af, af'                  ; swap af with af'
126+  8459 D9          >        exx
126+  845A             >
126+  845A             >        ; carry on popping
126+  845A F1          >        pop af                      ; 9,8
126+  845B C1          >        pop bc                      ; 11,10
126+  845C D1          >        pop de                      ; 13,12
126+  845D E1          >        pop hl                      ; 15,14
126+  845E             >
126+  845E             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  845E             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  845E 31 B0 58    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8461             >
126+  8461             >        ; we push back onto the screen memory stack in reverse order
126+  8461 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8462 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8463 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8464 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8465             >
126+  8465             >        ; swap back to the original registers
126+  8465 08          >        ex af, af'
126+  8466 D9          >        exx
126+  8467             >
126+  8467 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8468 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8469 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  846A F5          >        push af                     ; copy 1,0 to the screen memory
126+  846B             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  846B             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  846B 31 B5 80    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  846E             >        ; now we start popping the attributes off the 'stack'
126+  846E F1          >        pop af                      ; 1,0
126+  846F C1          >        pop bc                      ; 3,2
126+  8470 D1          >        pop de                      ; 5,4
126+  8471 E1          >        pop hl                      ; 7,6
126+  8472             >
126+  8472             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8472 08          >        ex af, af'                  ; swap af with af'
126+  8473 D9          >        exx
126+  8474             >
126+  8474             >        ; carry on popping
126+  8474 F1          >        pop af                      ; 9,8
126+  8475 C1          >        pop bc                      ; 11,10
126+  8476 D1          >        pop de                      ; 13,12
126+  8477 E1          >        pop hl                      ; 15,14
126+  8478             >
126+  8478             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8478             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8478 31 C0 58    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  847B             >
126+  847B             >        ; we push back onto the screen memory stack in reverse order
126+  847B E5          >        push hl                     ; copy 15,14 to the screen memory
126+  847C D5          >        push de                     ; copy 13,12 to the screen memory
126+  847D C5          >        push bc                     ; copy 11,10 to the screen memory
126+  847E F5          >        push af                     ; copy 9,8 to the screen memory
126+  847F             >
126+  847F             >        ; swap back to the original registers
126+  847F 08          >        ex af, af'
126+  8480 D9          >        exx
126+  8481             >
126+  8481 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8482 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8483 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8484 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8485             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8485             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8485 31 C5 80    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8488             >        ; now we start popping the attributes off the 'stack'
126+  8488 F1          >        pop af                      ; 1,0
126+  8489 C1          >        pop bc                      ; 3,2
126+  848A D1          >        pop de                      ; 5,4
126+  848B E1          >        pop hl                      ; 7,6
126+  848C             >
126+  848C             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  848C 08          >        ex af, af'                  ; swap af with af'
126+  848D D9          >        exx
126+  848E             >
126+  848E             >        ; carry on popping
126+  848E F1          >        pop af                      ; 9,8
126+  848F C1          >        pop bc                      ; 11,10
126+  8490 D1          >        pop de                      ; 13,12
126+  8491 E1          >        pop hl                      ; 15,14
126+  8492             >
126+  8492             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8492             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8492 31 D0 58    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8495             >
126+  8495             >        ; we push back onto the screen memory stack in reverse order
126+  8495 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8496 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8497 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8498 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8499             >
126+  8499             >        ; swap back to the original registers
126+  8499 08          >        ex af, af'
126+  849A D9          >        exx
126+  849B             >
126+  849B E5          >        push hl                     ; copy 7,6 to the screen memory
126+  849C D5          >        push de                     ; copy 5,4 to the screen memory
126+  849D C5          >        push bc                     ; copy 3,2 to the screen memory
126+  849E F5          >        push af                     ; copy 1,0 to the screen memory
126+  849F             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  849F             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  849F 31 D5 80    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  84A2             >        ; now we start popping the attributes off the 'stack'
126+  84A2 F1          >        pop af                      ; 1,0
126+  84A3 C1          >        pop bc                      ; 3,2
126+  84A4 D1          >        pop de                      ; 5,4
126+  84A5 E1          >        pop hl                      ; 7,6
126+  84A6             >
126+  84A6             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  84A6 08          >        ex af, af'                  ; swap af with af'
126+  84A7 D9          >        exx
126+  84A8             >
126+  84A8             >        ; carry on popping
126+  84A8 F1          >        pop af                      ; 9,8
126+  84A9 C1          >        pop bc                      ; 11,10
126+  84AA D1          >        pop de                      ; 13,12
126+  84AB E1          >        pop hl                      ; 15,14
126+  84AC             >
126+  84AC             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  84AC             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  84AC 31 E0 58    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  84AF             >
126+  84AF             >        ; we push back onto the screen memory stack in reverse order
126+  84AF E5          >        push hl                     ; copy 15,14 to the screen memory
126+  84B0 D5          >        push de                     ; copy 13,12 to the screen memory
126+  84B1 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  84B2 F5          >        push af                     ; copy 9,8 to the screen memory
126+  84B3             >
126+  84B3             >        ; swap back to the original registers
126+  84B3 08          >        ex af, af'
126+  84B4 D9          >        exx
126+  84B5             >
126+  84B5 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  84B6 D5          >        push de                     ; copy 5,4 to the screen memory
126+  84B7 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  84B8 F5          >        push af                     ; copy 1,0 to the screen memory
126+  84B9             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  84B9             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  84B9 31 E5 80    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  84BC             >        ; now we start popping the attributes off the 'stack'
126+  84BC F1          >        pop af                      ; 1,0
126+  84BD C1          >        pop bc                      ; 3,2
126+  84BE D1          >        pop de                      ; 5,4
126+  84BF E1          >        pop hl                      ; 7,6
126+  84C0             >
126+  84C0             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  84C0 08          >        ex af, af'                  ; swap af with af'
126+  84C1 D9          >        exx
126+  84C2             >
126+  84C2             >        ; carry on popping
126+  84C2 F1          >        pop af                      ; 9,8
126+  84C3 C1          >        pop bc                      ; 11,10
126+  84C4 D1          >        pop de                      ; 13,12
126+  84C5 E1          >        pop hl                      ; 15,14
126+  84C6             >
126+  84C6             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  84C6             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  84C6 31 F0 58    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  84C9             >
126+  84C9             >        ; we push back onto the screen memory stack in reverse order
126+  84C9 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  84CA D5          >        push de                     ; copy 13,12 to the screen memory
126+  84CB C5          >        push bc                     ; copy 11,10 to the screen memory
126+  84CC F5          >        push af                     ; copy 9,8 to the screen memory
126+  84CD             >
126+  84CD             >        ; swap back to the original registers
126+  84CD 08          >        ex af, af'
126+  84CE D9          >        exx
126+  84CF             >
126+  84CF E5          >        push hl                     ; copy 7,6 to the screen memory
126+  84D0 D5          >        push de                     ; copy 5,4 to the screen memory
126+  84D1 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  84D2 F5          >        push af                     ; copy 1,0 to the screen memory
126+  84D3             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  84D3             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  84D3 31 F5 80    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  84D6             >        ; now we start popping the attributes off the 'stack'
126+  84D6 F1          >        pop af                      ; 1,0
126+  84D7 C1          >        pop bc                      ; 3,2
126+  84D8 D1          >        pop de                      ; 5,4
126+  84D9 E1          >        pop hl                      ; 7,6
126+  84DA             >
126+  84DA             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  84DA 08          >        ex af, af'                  ; swap af with af'
126+  84DB D9          >        exx
126+  84DC             >
126+  84DC             >        ; carry on popping
126+  84DC F1          >        pop af                      ; 9,8
126+  84DD C1          >        pop bc                      ; 11,10
126+  84DE D1          >        pop de                      ; 13,12
126+  84DF E1          >        pop hl                      ; 15,14
126+  84E0             >
126+  84E0             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  84E0             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  84E0 31 00 59    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  84E3             >
126+  84E3             >        ; we push back onto the screen memory stack in reverse order
126+  84E3 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  84E4 D5          >        push de                     ; copy 13,12 to the screen memory
126+  84E5 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  84E6 F5          >        push af                     ; copy 9,8 to the screen memory
126+  84E7             >
126+  84E7             >        ; swap back to the original registers
126+  84E7 08          >        ex af, af'
126+  84E8 D9          >        exx
126+  84E9             >
126+  84E9 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  84EA D5          >        push de                     ; copy 5,4 to the screen memory
126+  84EB C5          >        push bc                     ; copy 3,2 to the screen memory
126+  84EC F5          >        push af                     ; copy 1,0 to the screen memory
126+  84ED             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  84ED             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  84ED 31 05 81    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  84F0             >        ; now we start popping the attributes off the 'stack'
126+  84F0 F1          >        pop af                      ; 1,0
126+  84F1 C1          >        pop bc                      ; 3,2
126+  84F2 D1          >        pop de                      ; 5,4
126+  84F3 E1          >        pop hl                      ; 7,6
126+  84F4             >
126+  84F4             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  84F4 08          >        ex af, af'                  ; swap af with af'
126+  84F5 D9          >        exx
126+  84F6             >
126+  84F6             >        ; carry on popping
126+  84F6 F1          >        pop af                      ; 9,8
126+  84F7 C1          >        pop bc                      ; 11,10
126+  84F8 D1          >        pop de                      ; 13,12
126+  84F9 E1          >        pop hl                      ; 15,14
126+  84FA             >
126+  84FA             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  84FA             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  84FA 31 10 59    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  84FD             >
126+  84FD             >        ; we push back onto the screen memory stack in reverse order
126+  84FD E5          >        push hl                     ; copy 15,14 to the screen memory
126+  84FE D5          >        push de                     ; copy 13,12 to the screen memory
126+  84FF C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8500 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8501             >
126+  8501             >        ; swap back to the original registers
126+  8501 08          >        ex af, af'
126+  8502 D9          >        exx
126+  8503             >
126+  8503 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8504 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8505 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8506 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8507             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  8507             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8507 31 15 81    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  850A             >        ; now we start popping the attributes off the 'stack'
126+  850A F1          >        pop af                      ; 1,0
126+  850B C1          >        pop bc                      ; 3,2
126+  850C D1          >        pop de                      ; 5,4
126+  850D E1          >        pop hl                      ; 7,6
126+  850E             >
126+  850E             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  850E 08          >        ex af, af'                  ; swap af with af'
126+  850F D9          >        exx
126+  8510             >
126+  8510             >        ; carry on popping
126+  8510 F1          >        pop af                      ; 9,8
126+  8511 C1          >        pop bc                      ; 11,10
126+  8512 D1          >        pop de                      ; 13,12
126+  8513 E1          >        pop hl                      ; 15,14
126+  8514             >
126+  8514             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8514             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8514 31 20 59    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  8517             >
126+  8517             >        ; we push back onto the screen memory stack in reverse order
126+  8517 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8518 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8519 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  851A F5          >        push af                     ; copy 9,8 to the screen memory
126+  851B             >
126+  851B             >        ; swap back to the original registers
126+  851B 08          >        ex af, af'
126+  851C D9          >        exx
126+  851D             >
126+  851D E5          >        push hl                     ; copy 7,6 to the screen memory
126+  851E D5          >        push de                     ; copy 5,4 to the screen memory
126+  851F C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8520 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8521             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8521             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8521 31 25 81    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8524             >        ; now we start popping the attributes off the 'stack'
126+  8524 F1          >        pop af                      ; 1,0
126+  8525 C1          >        pop bc                      ; 3,2
126+  8526 D1          >        pop de                      ; 5,4
126+  8527 E1          >        pop hl                      ; 7,6
126+  8528             >
126+  8528             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8528 08          >        ex af, af'                  ; swap af with af'
126+  8529 D9          >        exx
126+  852A             >
126+  852A             >        ; carry on popping
126+  852A F1          >        pop af                      ; 9,8
126+  852B C1          >        pop bc                      ; 11,10
126+  852C D1          >        pop de                      ; 13,12
126+  852D E1          >        pop hl                      ; 15,14
126+  852E             >
126+  852E             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  852E             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  852E 31 30 59    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8531             >
126+  8531             >        ; we push back onto the screen memory stack in reverse order
126+  8531 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8532 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8533 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8534 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8535             >
126+  8535             >        ; swap back to the original registers
126+  8535 08          >        ex af, af'
126+  8536 D9          >        exx
126+  8537             >
126+  8537 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8538 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8539 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  853A F5          >        push af                     ; copy 1,0 to the screen memory
126+  853B             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  853B             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  853B 31 35 81    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  853E             >        ; now we start popping the attributes off the 'stack'
126+  853E F1          >        pop af                      ; 1,0
126+  853F C1          >        pop bc                      ; 3,2
126+  8540 D1          >        pop de                      ; 5,4
126+  8541 E1          >        pop hl                      ; 7,6
126+  8542             >
126+  8542             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8542 08          >        ex af, af'                  ; swap af with af'
126+  8543 D9          >        exx
126+  8544             >
126+  8544             >        ; carry on popping
126+  8544 F1          >        pop af                      ; 9,8
126+  8545 C1          >        pop bc                      ; 11,10
126+  8546 D1          >        pop de                      ; 13,12
126+  8547 E1          >        pop hl                      ; 15,14
126+  8548             >
126+  8548             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8548             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8548 31 40 59    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  854B             >
126+  854B             >        ; we push back onto the screen memory stack in reverse order
126+  854B E5          >        push hl                     ; copy 15,14 to the screen memory
126+  854C D5          >        push de                     ; copy 13,12 to the screen memory
126+  854D C5          >        push bc                     ; copy 11,10 to the screen memory
126+  854E F5          >        push af                     ; copy 9,8 to the screen memory
126+  854F             >
126+  854F             >        ; swap back to the original registers
126+  854F 08          >        ex af, af'
126+  8550 D9          >        exx
126+  8551             >
126+  8551 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8552 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8553 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8554 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8555             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8555             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8555 31 45 81    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8558             >        ; now we start popping the attributes off the 'stack'
126+  8558 F1          >        pop af                      ; 1,0
126+  8559 C1          >        pop bc                      ; 3,2
126+  855A D1          >        pop de                      ; 5,4
126+  855B E1          >        pop hl                      ; 7,6
126+  855C             >
126+  855C             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  855C 08          >        ex af, af'                  ; swap af with af'
126+  855D D9          >        exx
126+  855E             >
126+  855E             >        ; carry on popping
126+  855E F1          >        pop af                      ; 9,8
126+  855F C1          >        pop bc                      ; 11,10
126+  8560 D1          >        pop de                      ; 13,12
126+  8561 E1          >        pop hl                      ; 15,14
126+  8562             >
126+  8562             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8562             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8562 31 50 59    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8565             >
126+  8565             >        ; we push back onto the screen memory stack in reverse order
126+  8565 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8566 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8567 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8568 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8569             >
126+  8569             >        ; swap back to the original registers
126+  8569 08          >        ex af, af'
126+  856A D9          >        exx
126+  856B             >
126+  856B E5          >        push hl                     ; copy 7,6 to the screen memory
126+  856C D5          >        push de                     ; copy 5,4 to the screen memory
126+  856D C5          >        push bc                     ; copy 3,2 to the screen memory
126+  856E F5          >        push af                     ; copy 1,0 to the screen memory
126+  856F             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  856F             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  856F 31 55 81    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  8572             >        ; now we start popping the attributes off the 'stack'
126+  8572 F1          >        pop af                      ; 1,0
126+  8573 C1          >        pop bc                      ; 3,2
126+  8574 D1          >        pop de                      ; 5,4
126+  8575 E1          >        pop hl                      ; 7,6
126+  8576             >
126+  8576             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8576 08          >        ex af, af'                  ; swap af with af'
126+  8577 D9          >        exx
126+  8578             >
126+  8578             >        ; carry on popping
126+  8578 F1          >        pop af                      ; 9,8
126+  8579 C1          >        pop bc                      ; 11,10
126+  857A D1          >        pop de                      ; 13,12
126+  857B E1          >        pop hl                      ; 15,14
126+  857C             >
126+  857C             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  857C             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  857C 31 60 59    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  857F             >
126+  857F             >        ; we push back onto the screen memory stack in reverse order
126+  857F E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8580 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8581 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8582 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8583             >
126+  8583             >        ; swap back to the original registers
126+  8583 08          >        ex af, af'
126+  8584 D9          >        exx
126+  8585             >
126+  8585 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8586 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8587 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8588 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8589             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8589             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8589 31 65 81    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  858C             >        ; now we start popping the attributes off the 'stack'
126+  858C F1          >        pop af                      ; 1,0
126+  858D C1          >        pop bc                      ; 3,2
126+  858E D1          >        pop de                      ; 5,4
126+  858F E1          >        pop hl                      ; 7,6
126+  8590             >
126+  8590             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8590 08          >        ex af, af'                  ; swap af with af'
126+  8591 D9          >        exx
126+  8592             >
126+  8592             >        ; carry on popping
126+  8592 F1          >        pop af                      ; 9,8
126+  8593 C1          >        pop bc                      ; 11,10
126+  8594 D1          >        pop de                      ; 13,12
126+  8595 E1          >        pop hl                      ; 15,14
126+  8596             >
126+  8596             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8596             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8596 31 70 59    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8599             >
126+  8599             >        ; we push back onto the screen memory stack in reverse order
126+  8599 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  859A D5          >        push de                     ; copy 13,12 to the screen memory
126+  859B C5          >        push bc                     ; copy 11,10 to the screen memory
126+  859C F5          >        push af                     ; copy 9,8 to the screen memory
126+  859D             >
126+  859D             >        ; swap back to the original registers
126+  859D 08          >        ex af, af'
126+  859E D9          >        exx
126+  859F             >
126+  859F E5          >        push hl                     ; copy 7,6 to the screen memory
126+  85A0 D5          >        push de                     ; copy 5,4 to the screen memory
126+  85A1 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  85A2 F5          >        push af                     ; copy 1,0 to the screen memory
126+  85A3             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  85A3             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  85A3 31 75 81    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  85A6             >        ; now we start popping the attributes off the 'stack'
126+  85A6 F1          >        pop af                      ; 1,0
126+  85A7 C1          >        pop bc                      ; 3,2
126+  85A8 D1          >        pop de                      ; 5,4
126+  85A9 E1          >        pop hl                      ; 7,6
126+  85AA             >
126+  85AA             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  85AA 08          >        ex af, af'                  ; swap af with af'
126+  85AB D9          >        exx
126+  85AC             >
126+  85AC             >        ; carry on popping
126+  85AC F1          >        pop af                      ; 9,8
126+  85AD C1          >        pop bc                      ; 11,10
126+  85AE D1          >        pop de                      ; 13,12
126+  85AF E1          >        pop hl                      ; 15,14
126+  85B0             >
126+  85B0             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  85B0             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  85B0 31 80 59    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  85B3             >
126+  85B3             >        ; we push back onto the screen memory stack in reverse order
126+  85B3 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  85B4 D5          >        push de                     ; copy 13,12 to the screen memory
126+  85B5 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  85B6 F5          >        push af                     ; copy 9,8 to the screen memory
126+  85B7             >
126+  85B7             >        ; swap back to the original registers
126+  85B7 08          >        ex af, af'
126+  85B8 D9          >        exx
126+  85B9             >
126+  85B9 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  85BA D5          >        push de                     ; copy 5,4 to the screen memory
126+  85BB C5          >        push bc                     ; copy 3,2 to the screen memory
126+  85BC F5          >        push af                     ; copy 1,0 to the screen memory
126+  85BD             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  85BD             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  85BD 31 85 81    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  85C0             >        ; now we start popping the attributes off the 'stack'
126+  85C0 F1          >        pop af                      ; 1,0
126+  85C1 C1          >        pop bc                      ; 3,2
126+  85C2 D1          >        pop de                      ; 5,4
126+  85C3 E1          >        pop hl                      ; 7,6
126+  85C4             >
126+  85C4             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  85C4 08          >        ex af, af'                  ; swap af with af'
126+  85C5 D9          >        exx
126+  85C6             >
126+  85C6             >        ; carry on popping
126+  85C6 F1          >        pop af                      ; 9,8
126+  85C7 C1          >        pop bc                      ; 11,10
126+  85C8 D1          >        pop de                      ; 13,12
126+  85C9 E1          >        pop hl                      ; 15,14
126+  85CA             >
126+  85CA             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  85CA             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  85CA 31 90 59    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  85CD             >
126+  85CD             >        ; we push back onto the screen memory stack in reverse order
126+  85CD E5          >        push hl                     ; copy 15,14 to the screen memory
126+  85CE D5          >        push de                     ; copy 13,12 to the screen memory
126+  85CF C5          >        push bc                     ; copy 11,10 to the screen memory
126+  85D0 F5          >        push af                     ; copy 9,8 to the screen memory
126+  85D1             >
126+  85D1             >        ; swap back to the original registers
126+  85D1 08          >        ex af, af'
126+  85D2 D9          >        exx
126+  85D3             >
126+  85D3 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  85D4 D5          >        push de                     ; copy 5,4 to the screen memory
126+  85D5 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  85D6 F5          >        push af                     ; copy 1,0 to the screen memory
126+  85D7             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  85D7             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  85D7 31 95 81    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  85DA             >        ; now we start popping the attributes off the 'stack'
126+  85DA F1          >        pop af                      ; 1,0
126+  85DB C1          >        pop bc                      ; 3,2
126+  85DC D1          >        pop de                      ; 5,4
126+  85DD E1          >        pop hl                      ; 7,6
126+  85DE             >
126+  85DE             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  85DE 08          >        ex af, af'                  ; swap af with af'
126+  85DF D9          >        exx
126+  85E0             >
126+  85E0             >        ; carry on popping
126+  85E0 F1          >        pop af                      ; 9,8
126+  85E1 C1          >        pop bc                      ; 11,10
126+  85E2 D1          >        pop de                      ; 13,12
126+  85E3 E1          >        pop hl                      ; 15,14
126+  85E4             >
126+  85E4             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  85E4             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  85E4 31 A0 59    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  85E7             >
126+  85E7             >        ; we push back onto the screen memory stack in reverse order
126+  85E7 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  85E8 D5          >        push de                     ; copy 13,12 to the screen memory
126+  85E9 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  85EA F5          >        push af                     ; copy 9,8 to the screen memory
126+  85EB             >
126+  85EB             >        ; swap back to the original registers
126+  85EB 08          >        ex af, af'
126+  85EC D9          >        exx
126+  85ED             >
126+  85ED E5          >        push hl                     ; copy 7,6 to the screen memory
126+  85EE D5          >        push de                     ; copy 5,4 to the screen memory
126+  85EF C5          >        push bc                     ; copy 3,2 to the screen memory
126+  85F0 F5          >        push af                     ; copy 1,0 to the screen memory
126+  85F1             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  85F1             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  85F1 31 A5 81    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  85F4             >        ; now we start popping the attributes off the 'stack'
126+  85F4 F1          >        pop af                      ; 1,0
126+  85F5 C1          >        pop bc                      ; 3,2
126+  85F6 D1          >        pop de                      ; 5,4
126+  85F7 E1          >        pop hl                      ; 7,6
126+  85F8             >
126+  85F8             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  85F8 08          >        ex af, af'                  ; swap af with af'
126+  85F9 D9          >        exx
126+  85FA             >
126+  85FA             >        ; carry on popping
126+  85FA F1          >        pop af                      ; 9,8
126+  85FB C1          >        pop bc                      ; 11,10
126+  85FC D1          >        pop de                      ; 13,12
126+  85FD E1          >        pop hl                      ; 15,14
126+  85FE             >
126+  85FE             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  85FE             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  85FE 31 B0 59    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8601             >
126+  8601             >        ; we push back onto the screen memory stack in reverse order
126+  8601 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8602 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8603 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8604 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8605             >
126+  8605             >        ; swap back to the original registers
126+  8605 08          >        ex af, af'
126+  8606 D9          >        exx
126+  8607             >
126+  8607 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8608 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8609 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  860A F5          >        push af                     ; copy 1,0 to the screen memory
126+  860B             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  860B             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  860B 31 B5 81    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  860E             >        ; now we start popping the attributes off the 'stack'
126+  860E F1          >        pop af                      ; 1,0
126+  860F C1          >        pop bc                      ; 3,2
126+  8610 D1          >        pop de                      ; 5,4
126+  8611 E1          >        pop hl                      ; 7,6
126+  8612             >
126+  8612             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8612 08          >        ex af, af'                  ; swap af with af'
126+  8613 D9          >        exx
126+  8614             >
126+  8614             >        ; carry on popping
126+  8614 F1          >        pop af                      ; 9,8
126+  8615 C1          >        pop bc                      ; 11,10
126+  8616 D1          >        pop de                      ; 13,12
126+  8617 E1          >        pop hl                      ; 15,14
126+  8618             >
126+  8618             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8618             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8618 31 C0 59    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  861B             >
126+  861B             >        ; we push back onto the screen memory stack in reverse order
126+  861B E5          >        push hl                     ; copy 15,14 to the screen memory
126+  861C D5          >        push de                     ; copy 13,12 to the screen memory
126+  861D C5          >        push bc                     ; copy 11,10 to the screen memory
126+  861E F5          >        push af                     ; copy 9,8 to the screen memory
126+  861F             >
126+  861F             >        ; swap back to the original registers
126+  861F 08          >        ex af, af'
126+  8620 D9          >        exx
126+  8621             >
126+  8621 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8622 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8623 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8624 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8625             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8625             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8625 31 C5 81    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8628             >        ; now we start popping the attributes off the 'stack'
126+  8628 F1          >        pop af                      ; 1,0
126+  8629 C1          >        pop bc                      ; 3,2
126+  862A D1          >        pop de                      ; 5,4
126+  862B E1          >        pop hl                      ; 7,6
126+  862C             >
126+  862C             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  862C 08          >        ex af, af'                  ; swap af with af'
126+  862D D9          >        exx
126+  862E             >
126+  862E             >        ; carry on popping
126+  862E F1          >        pop af                      ; 9,8
126+  862F C1          >        pop bc                      ; 11,10
126+  8630 D1          >        pop de                      ; 13,12
126+  8631 E1          >        pop hl                      ; 15,14
126+  8632             >
126+  8632             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8632             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8632 31 D0 59    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8635             >
126+  8635             >        ; we push back onto the screen memory stack in reverse order
126+  8635 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8636 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8637 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8638 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8639             >
126+  8639             >        ; swap back to the original registers
126+  8639 08          >        ex af, af'
126+  863A D9          >        exx
126+  863B             >
126+  863B E5          >        push hl                     ; copy 7,6 to the screen memory
126+  863C D5          >        push de                     ; copy 5,4 to the screen memory
126+  863D C5          >        push bc                     ; copy 3,2 to the screen memory
126+  863E F5          >        push af                     ; copy 1,0 to the screen memory
126+  863F             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  863F             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  863F 31 D5 81    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  8642             >        ; now we start popping the attributes off the 'stack'
126+  8642 F1          >        pop af                      ; 1,0
126+  8643 C1          >        pop bc                      ; 3,2
126+  8644 D1          >        pop de                      ; 5,4
126+  8645 E1          >        pop hl                      ; 7,6
126+  8646             >
126+  8646             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8646 08          >        ex af, af'                  ; swap af with af'
126+  8647 D9          >        exx
126+  8648             >
126+  8648             >        ; carry on popping
126+  8648 F1          >        pop af                      ; 9,8
126+  8649 C1          >        pop bc                      ; 11,10
126+  864A D1          >        pop de                      ; 13,12
126+  864B E1          >        pop hl                      ; 15,14
126+  864C             >
126+  864C             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  864C             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  864C 31 E0 59    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  864F             >
126+  864F             >        ; we push back onto the screen memory stack in reverse order
126+  864F E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8650 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8651 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8652 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8653             >
126+  8653             >        ; swap back to the original registers
126+  8653 08          >        ex af, af'
126+  8654 D9          >        exx
126+  8655             >
126+  8655 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8656 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8657 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8658 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8659             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8659             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8659 31 E5 81    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  865C             >        ; now we start popping the attributes off the 'stack'
126+  865C F1          >        pop af                      ; 1,0
126+  865D C1          >        pop bc                      ; 3,2
126+  865E D1          >        pop de                      ; 5,4
126+  865F E1          >        pop hl                      ; 7,6
126+  8660             >
126+  8660             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8660 08          >        ex af, af'                  ; swap af with af'
126+  8661 D9          >        exx
126+  8662             >
126+  8662             >        ; carry on popping
126+  8662 F1          >        pop af                      ; 9,8
126+  8663 C1          >        pop bc                      ; 11,10
126+  8664 D1          >        pop de                      ; 13,12
126+  8665 E1          >        pop hl                      ; 15,14
126+  8666             >
126+  8666             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8666             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8666 31 F0 59    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8669             >
126+  8669             >        ; we push back onto the screen memory stack in reverse order
126+  8669 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  866A D5          >        push de                     ; copy 13,12 to the screen memory
126+  866B C5          >        push bc                     ; copy 11,10 to the screen memory
126+  866C F5          >        push af                     ; copy 9,8 to the screen memory
126+  866D             >
126+  866D             >        ; swap back to the original registers
126+  866D 08          >        ex af, af'
126+  866E D9          >        exx
126+  866F             >
126+  866F E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8670 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8671 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8672 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8673             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  8673             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8673 31 F5 81    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  8676             >        ; now we start popping the attributes off the 'stack'
126+  8676 F1          >        pop af                      ; 1,0
126+  8677 C1          >        pop bc                      ; 3,2
126+  8678 D1          >        pop de                      ; 5,4
126+  8679 E1          >        pop hl                      ; 7,6
126+  867A             >
126+  867A             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  867A 08          >        ex af, af'                  ; swap af with af'
126+  867B D9          >        exx
126+  867C             >
126+  867C             >        ; carry on popping
126+  867C F1          >        pop af                      ; 9,8
126+  867D C1          >        pop bc                      ; 11,10
126+  867E D1          >        pop de                      ; 13,12
126+  867F E1          >        pop hl                      ; 15,14
126+  8680             >
126+  8680             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8680             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8680 31 00 5A    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  8683             >
126+  8683             >        ; we push back onto the screen memory stack in reverse order
126+  8683 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8684 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8685 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8686 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8687             >
126+  8687             >        ; swap back to the original registers
126+  8687 08          >        ex af, af'
126+  8688 D9          >        exx
126+  8689             >
126+  8689 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  868A D5          >        push de                     ; copy 5,4 to the screen memory
126+  868B C5          >        push bc                     ; copy 3,2 to the screen memory
126+  868C F5          >        push af                     ; copy 1,0 to the screen memory
126+  868D             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  868D             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  868D 31 05 82    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8690             >        ; now we start popping the attributes off the 'stack'
126+  8690 F1          >        pop af                      ; 1,0
126+  8691 C1          >        pop bc                      ; 3,2
126+  8692 D1          >        pop de                      ; 5,4
126+  8693 E1          >        pop hl                      ; 7,6
126+  8694             >
126+  8694             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8694 08          >        ex af, af'                  ; swap af with af'
126+  8695 D9          >        exx
126+  8696             >
126+  8696             >        ; carry on popping
126+  8696 F1          >        pop af                      ; 9,8
126+  8697 C1          >        pop bc                      ; 11,10
126+  8698 D1          >        pop de                      ; 13,12
126+  8699 E1          >        pop hl                      ; 15,14
126+  869A             >
126+  869A             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  869A             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  869A 31 10 5A    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  869D             >
126+  869D             >        ; we push back onto the screen memory stack in reverse order
126+  869D E5          >        push hl                     ; copy 15,14 to the screen memory
126+  869E D5          >        push de                     ; copy 13,12 to the screen memory
126+  869F C5          >        push bc                     ; copy 11,10 to the screen memory
126+  86A0 F5          >        push af                     ; copy 9,8 to the screen memory
126+  86A1             >
126+  86A1             >        ; swap back to the original registers
126+  86A1 08          >        ex af, af'
126+  86A2 D9          >        exx
126+  86A3             >
126+  86A3 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  86A4 D5          >        push de                     ; copy 5,4 to the screen memory
126+  86A5 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  86A6 F5          >        push af                     ; copy 1,0 to the screen memory
126+  86A7             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  86A7             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  86A7 31 15 82    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  86AA             >        ; now we start popping the attributes off the 'stack'
126+  86AA F1          >        pop af                      ; 1,0
126+  86AB C1          >        pop bc                      ; 3,2
126+  86AC D1          >        pop de                      ; 5,4
126+  86AD E1          >        pop hl                      ; 7,6
126+  86AE             >
126+  86AE             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  86AE 08          >        ex af, af'                  ; swap af with af'
126+  86AF D9          >        exx
126+  86B0             >
126+  86B0             >        ; carry on popping
126+  86B0 F1          >        pop af                      ; 9,8
126+  86B1 C1          >        pop bc                      ; 11,10
126+  86B2 D1          >        pop de                      ; 13,12
126+  86B3 E1          >        pop hl                      ; 15,14
126+  86B4             >
126+  86B4             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  86B4             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  86B4 31 20 5A    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  86B7             >
126+  86B7             >        ; we push back onto the screen memory stack in reverse order
126+  86B7 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  86B8 D5          >        push de                     ; copy 13,12 to the screen memory
126+  86B9 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  86BA F5          >        push af                     ; copy 9,8 to the screen memory
126+  86BB             >
126+  86BB             >        ; swap back to the original registers
126+  86BB 08          >        ex af, af'
126+  86BC D9          >        exx
126+  86BD             >
126+  86BD E5          >        push hl                     ; copy 7,6 to the screen memory
126+  86BE D5          >        push de                     ; copy 5,4 to the screen memory
126+  86BF C5          >        push bc                     ; copy 3,2 to the screen memory
126+  86C0 F5          >        push af                     ; copy 1,0 to the screen memory
126+  86C1             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  86C1             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  86C1 31 25 82    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  86C4             >        ; now we start popping the attributes off the 'stack'
126+  86C4 F1          >        pop af                      ; 1,0
126+  86C5 C1          >        pop bc                      ; 3,2
126+  86C6 D1          >        pop de                      ; 5,4
126+  86C7 E1          >        pop hl                      ; 7,6
126+  86C8             >
126+  86C8             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  86C8 08          >        ex af, af'                  ; swap af with af'
126+  86C9 D9          >        exx
126+  86CA             >
126+  86CA             >        ; carry on popping
126+  86CA F1          >        pop af                      ; 9,8
126+  86CB C1          >        pop bc                      ; 11,10
126+  86CC D1          >        pop de                      ; 13,12
126+  86CD E1          >        pop hl                      ; 15,14
126+  86CE             >
126+  86CE             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  86CE             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  86CE 31 30 5A    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  86D1             >
126+  86D1             >        ; we push back onto the screen memory stack in reverse order
126+  86D1 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  86D2 D5          >        push de                     ; copy 13,12 to the screen memory
126+  86D3 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  86D4 F5          >        push af                     ; copy 9,8 to the screen memory
126+  86D5             >
126+  86D5             >        ; swap back to the original registers
126+  86D5 08          >        ex af, af'
126+  86D6 D9          >        exx
126+  86D7             >
126+  86D7 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  86D8 D5          >        push de                     ; copy 5,4 to the screen memory
126+  86D9 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  86DA F5          >        push af                     ; copy 1,0 to the screen memory
126+  86DB             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  86DB             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  86DB 31 35 82    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  86DE             >        ; now we start popping the attributes off the 'stack'
126+  86DE F1          >        pop af                      ; 1,0
126+  86DF C1          >        pop bc                      ; 3,2
126+  86E0 D1          >        pop de                      ; 5,4
126+  86E1 E1          >        pop hl                      ; 7,6
126+  86E2             >
126+  86E2             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  86E2 08          >        ex af, af'                  ; swap af with af'
126+  86E3 D9          >        exx
126+  86E4             >
126+  86E4             >        ; carry on popping
126+  86E4 F1          >        pop af                      ; 9,8
126+  86E5 C1          >        pop bc                      ; 11,10
126+  86E6 D1          >        pop de                      ; 13,12
126+  86E7 E1          >        pop hl                      ; 15,14
126+  86E8             >
126+  86E8             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  86E8             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  86E8 31 40 5A    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  86EB             >
126+  86EB             >        ; we push back onto the screen memory stack in reverse order
126+  86EB E5          >        push hl                     ; copy 15,14 to the screen memory
126+  86EC D5          >        push de                     ; copy 13,12 to the screen memory
126+  86ED C5          >        push bc                     ; copy 11,10 to the screen memory
126+  86EE F5          >        push af                     ; copy 9,8 to the screen memory
126+  86EF             >
126+  86EF             >        ; swap back to the original registers
126+  86EF 08          >        ex af, af'
126+  86F0 D9          >        exx
126+  86F1             >
126+  86F1 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  86F2 D5          >        push de                     ; copy 5,4 to the screen memory
126+  86F3 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  86F4 F5          >        push af                     ; copy 1,0 to the screen memory
126+  86F5             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  86F5             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  86F5 31 45 82    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  86F8             >        ; now we start popping the attributes off the 'stack'
126+  86F8 F1          >        pop af                      ; 1,0
126+  86F9 C1          >        pop bc                      ; 3,2
126+  86FA D1          >        pop de                      ; 5,4
126+  86FB E1          >        pop hl                      ; 7,6
126+  86FC             >
126+  86FC             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  86FC 08          >        ex af, af'                  ; swap af with af'
126+  86FD D9          >        exx
126+  86FE             >
126+  86FE             >        ; carry on popping
126+  86FE F1          >        pop af                      ; 9,8
126+  86FF C1          >        pop bc                      ; 11,10
126+  8700 D1          >        pop de                      ; 13,12
126+  8701 E1          >        pop hl                      ; 15,14
126+  8702             >
126+  8702             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8702             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8702 31 50 5A    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8705             >
126+  8705             >        ; we push back onto the screen memory stack in reverse order
126+  8705 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8706 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8707 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8708 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8709             >
126+  8709             >        ; swap back to the original registers
126+  8709 08          >        ex af, af'
126+  870A D9          >        exx
126+  870B             >
126+  870B E5          >        push hl                     ; copy 7,6 to the screen memory
126+  870C D5          >        push de                     ; copy 5,4 to the screen memory
126+  870D C5          >        push bc                     ; copy 3,2 to the screen memory
126+  870E F5          >        push af                     ; copy 1,0 to the screen memory
126+  870F             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  870F             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  870F 31 55 82    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  8712             >        ; now we start popping the attributes off the 'stack'
126+  8712 F1          >        pop af                      ; 1,0
126+  8713 C1          >        pop bc                      ; 3,2
126+  8714 D1          >        pop de                      ; 5,4
126+  8715 E1          >        pop hl                      ; 7,6
126+  8716             >
126+  8716             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8716 08          >        ex af, af'                  ; swap af with af'
126+  8717 D9          >        exx
126+  8718             >
126+  8718             >        ; carry on popping
126+  8718 F1          >        pop af                      ; 9,8
126+  8719 C1          >        pop bc                      ; 11,10
126+  871A D1          >        pop de                      ; 13,12
126+  871B E1          >        pop hl                      ; 15,14
126+  871C             >
126+  871C             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  871C             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  871C 31 60 5A    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  871F             >
126+  871F             >        ; we push back onto the screen memory stack in reverse order
126+  871F E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8720 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8721 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8722 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8723             >
126+  8723             >        ; swap back to the original registers
126+  8723 08          >        ex af, af'
126+  8724 D9          >        exx
126+  8725             >
126+  8725 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8726 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8727 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8728 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8729             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8729             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8729 31 65 82    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  872C             >        ; now we start popping the attributes off the 'stack'
126+  872C F1          >        pop af                      ; 1,0
126+  872D C1          >        pop bc                      ; 3,2
126+  872E D1          >        pop de                      ; 5,4
126+  872F E1          >        pop hl                      ; 7,6
126+  8730             >
126+  8730             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8730 08          >        ex af, af'                  ; swap af with af'
126+  8731 D9          >        exx
126+  8732             >
126+  8732             >        ; carry on popping
126+  8732 F1          >        pop af                      ; 9,8
126+  8733 C1          >        pop bc                      ; 11,10
126+  8734 D1          >        pop de                      ; 13,12
126+  8735 E1          >        pop hl                      ; 15,14
126+  8736             >
126+  8736             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8736             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8736 31 70 5A    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8739             >
126+  8739             >        ; we push back onto the screen memory stack in reverse order
126+  8739 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  873A D5          >        push de                     ; copy 13,12 to the screen memory
126+  873B C5          >        push bc                     ; copy 11,10 to the screen memory
126+  873C F5          >        push af                     ; copy 9,8 to the screen memory
126+  873D             >
126+  873D             >        ; swap back to the original registers
126+  873D 08          >        ex af, af'
126+  873E D9          >        exx
126+  873F             >
126+  873F E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8740 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8741 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8742 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8743             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  8743             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8743 31 75 82    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  8746             >        ; now we start popping the attributes off the 'stack'
126+  8746 F1          >        pop af                      ; 1,0
126+  8747 C1          >        pop bc                      ; 3,2
126+  8748 D1          >        pop de                      ; 5,4
126+  8749 E1          >        pop hl                      ; 7,6
126+  874A             >
126+  874A             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  874A 08          >        ex af, af'                  ; swap af with af'
126+  874B D9          >        exx
126+  874C             >
126+  874C             >        ; carry on popping
126+  874C F1          >        pop af                      ; 9,8
126+  874D C1          >        pop bc                      ; 11,10
126+  874E D1          >        pop de                      ; 13,12
126+  874F E1          >        pop hl                      ; 15,14
126+  8750             >
126+  8750             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8750             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8750 31 80 5A    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  8753             >
126+  8753             >        ; we push back onto the screen memory stack in reverse order
126+  8753 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8754 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8755 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8756 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8757             >
126+  8757             >        ; swap back to the original registers
126+  8757 08          >        ex af, af'
126+  8758 D9          >        exx
126+  8759             >
126+  8759 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  875A D5          >        push de                     ; copy 5,4 to the screen memory
126+  875B C5          >        push bc                     ; copy 3,2 to the screen memory
126+  875C F5          >        push af                     ; copy 1,0 to the screen memory
126+  875D             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  875D             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  875D 31 85 82    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8760             >        ; now we start popping the attributes off the 'stack'
126+  8760 F1          >        pop af                      ; 1,0
126+  8761 C1          >        pop bc                      ; 3,2
126+  8762 D1          >        pop de                      ; 5,4
126+  8763 E1          >        pop hl                      ; 7,6
126+  8764             >
126+  8764             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8764 08          >        ex af, af'                  ; swap af with af'
126+  8765 D9          >        exx
126+  8766             >
126+  8766             >        ; carry on popping
126+  8766 F1          >        pop af                      ; 9,8
126+  8767 C1          >        pop bc                      ; 11,10
126+  8768 D1          >        pop de                      ; 13,12
126+  8769 E1          >        pop hl                      ; 15,14
126+  876A             >
126+  876A             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  876A             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  876A 31 90 5A    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  876D             >
126+  876D             >        ; we push back onto the screen memory stack in reverse order
126+  876D E5          >        push hl                     ; copy 15,14 to the screen memory
126+  876E D5          >        push de                     ; copy 13,12 to the screen memory
126+  876F C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8770 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8771             >
126+  8771             >        ; swap back to the original registers
126+  8771 08          >        ex af, af'
126+  8772 D9          >        exx
126+  8773             >
126+  8773 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8774 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8775 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8776 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8777             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  8777             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8777 31 95 82    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  877A             >        ; now we start popping the attributes off the 'stack'
126+  877A F1          >        pop af                      ; 1,0
126+  877B C1          >        pop bc                      ; 3,2
126+  877C D1          >        pop de                      ; 5,4
126+  877D E1          >        pop hl                      ; 7,6
126+  877E             >
126+  877E             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  877E 08          >        ex af, af'                  ; swap af with af'
126+  877F D9          >        exx
126+  8780             >
126+  8780             >        ; carry on popping
126+  8780 F1          >        pop af                      ; 9,8
126+  8781 C1          >        pop bc                      ; 11,10
126+  8782 D1          >        pop de                      ; 13,12
126+  8783 E1          >        pop hl                      ; 15,14
126+  8784             >
126+  8784             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8784             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8784 31 A0 5A    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  8787             >
126+  8787             >        ; we push back onto the screen memory stack in reverse order
126+  8787 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8788 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8789 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  878A F5          >        push af                     ; copy 9,8 to the screen memory
126+  878B             >
126+  878B             >        ; swap back to the original registers
126+  878B 08          >        ex af, af'
126+  878C D9          >        exx
126+  878D             >
126+  878D E5          >        push hl                     ; copy 7,6 to the screen memory
126+  878E D5          >        push de                     ; copy 5,4 to the screen memory
126+  878F C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8790 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8791             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8791             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8791 31 A5 82    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8794             >        ; now we start popping the attributes off the 'stack'
126+  8794 F1          >        pop af                      ; 1,0
126+  8795 C1          >        pop bc                      ; 3,2
126+  8796 D1          >        pop de                      ; 5,4
126+  8797 E1          >        pop hl                      ; 7,6
126+  8798             >
126+  8798             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8798 08          >        ex af, af'                  ; swap af with af'
126+  8799 D9          >        exx
126+  879A             >
126+  879A             >        ; carry on popping
126+  879A F1          >        pop af                      ; 9,8
126+  879B C1          >        pop bc                      ; 11,10
126+  879C D1          >        pop de                      ; 13,12
126+  879D E1          >        pop hl                      ; 15,14
126+  879E             >
126+  879E             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  879E             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  879E 31 B0 5A    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  87A1             >
126+  87A1             >        ; we push back onto the screen memory stack in reverse order
126+  87A1 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  87A2 D5          >        push de                     ; copy 13,12 to the screen memory
126+  87A3 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  87A4 F5          >        push af                     ; copy 9,8 to the screen memory
126+  87A5             >
126+  87A5             >        ; swap back to the original registers
126+  87A5 08          >        ex af, af'
126+  87A6 D9          >        exx
126+  87A7             >
126+  87A7 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  87A8 D5          >        push de                     ; copy 5,4 to the screen memory
126+  87A9 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  87AA F5          >        push af                     ; copy 1,0 to the screen memory
126+  87AB             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  87AB             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  87AB 31 B5 82    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  87AE             >        ; now we start popping the attributes off the 'stack'
126+  87AE F1          >        pop af                      ; 1,0
126+  87AF C1          >        pop bc                      ; 3,2
126+  87B0 D1          >        pop de                      ; 5,4
126+  87B1 E1          >        pop hl                      ; 7,6
126+  87B2             >
126+  87B2             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  87B2 08          >        ex af, af'                  ; swap af with af'
126+  87B3 D9          >        exx
126+  87B4             >
126+  87B4             >        ; carry on popping
126+  87B4 F1          >        pop af                      ; 9,8
126+  87B5 C1          >        pop bc                      ; 11,10
126+  87B6 D1          >        pop de                      ; 13,12
126+  87B7 E1          >        pop hl                      ; 15,14
126+  87B8             >
126+  87B8             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  87B8             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  87B8 31 C0 5A    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  87BB             >
126+  87BB             >        ; we push back onto the screen memory stack in reverse order
126+  87BB E5          >        push hl                     ; copy 15,14 to the screen memory
126+  87BC D5          >        push de                     ; copy 13,12 to the screen memory
126+  87BD C5          >        push bc                     ; copy 11,10 to the screen memory
126+  87BE F5          >        push af                     ; copy 9,8 to the screen memory
126+  87BF             >
126+  87BF             >        ; swap back to the original registers
126+  87BF 08          >        ex af, af'
126+  87C0 D9          >        exx
126+  87C1             >
126+  87C1 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  87C2 D5          >        push de                     ; copy 5,4 to the screen memory
126+  87C3 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  87C4 F5          >        push af                     ; copy 1,0 to the screen memory
126+  87C5             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  87C5             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  87C5 31 C5 82    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  87C8             >        ; now we start popping the attributes off the 'stack'
126+  87C8 F1          >        pop af                      ; 1,0
126+  87C9 C1          >        pop bc                      ; 3,2
126+  87CA D1          >        pop de                      ; 5,4
126+  87CB E1          >        pop hl                      ; 7,6
126+  87CC             >
126+  87CC             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  87CC 08          >        ex af, af'                  ; swap af with af'
126+  87CD D9          >        exx
126+  87CE             >
126+  87CE             >        ; carry on popping
126+  87CE F1          >        pop af                      ; 9,8
126+  87CF C1          >        pop bc                      ; 11,10
126+  87D0 D1          >        pop de                      ; 13,12
126+  87D1 E1          >        pop hl                      ; 15,14
126+  87D2             >
126+  87D2             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  87D2             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  87D2 31 D0 5A    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  87D5             >
126+  87D5             >        ; we push back onto the screen memory stack in reverse order
126+  87D5 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  87D6 D5          >        push de                     ; copy 13,12 to the screen memory
126+  87D7 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  87D8 F5          >        push af                     ; copy 9,8 to the screen memory
126+  87D9             >
126+  87D9             >        ; swap back to the original registers
126+  87D9 08          >        ex af, af'
126+  87DA D9          >        exx
126+  87DB             >
126+  87DB E5          >        push hl                     ; copy 7,6 to the screen memory
126+  87DC D5          >        push de                     ; copy 5,4 to the screen memory
126+  87DD C5          >        push bc                     ; copy 3,2 to the screen memory
126+  87DE F5          >        push af                     ; copy 1,0 to the screen memory
126+  87DF             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  87DF             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  87DF 31 D5 82    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  87E2             >        ; now we start popping the attributes off the 'stack'
126+  87E2 F1          >        pop af                      ; 1,0
126+  87E3 C1          >        pop bc                      ; 3,2
126+  87E4 D1          >        pop de                      ; 5,4
126+  87E5 E1          >        pop hl                      ; 7,6
126+  87E6             >
126+  87E6             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  87E6 08          >        ex af, af'                  ; swap af with af'
126+  87E7 D9          >        exx
126+  87E8             >
126+  87E8             >        ; carry on popping
126+  87E8 F1          >        pop af                      ; 9,8
126+  87E9 C1          >        pop bc                      ; 11,10
126+  87EA D1          >        pop de                      ; 13,12
126+  87EB E1          >        pop hl                      ; 15,14
126+  87EC             >
126+  87EC             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  87EC             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  87EC 31 E0 5A    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  87EF             >
126+  87EF             >        ; we push back onto the screen memory stack in reverse order
126+  87EF E5          >        push hl                     ; copy 15,14 to the screen memory
126+  87F0 D5          >        push de                     ; copy 13,12 to the screen memory
126+  87F1 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  87F2 F5          >        push af                     ; copy 9,8 to the screen memory
126+  87F3             >
126+  87F3             >        ; swap back to the original registers
126+  87F3 08          >        ex af, af'
126+  87F4 D9          >        exx
126+  87F5             >
126+  87F5 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  87F6 D5          >        push de                     ; copy 5,4 to the screen memory
126+  87F7 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  87F8 F5          >        push af                     ; copy 1,0 to the screen memory
126+  87F9             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  87F9             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  87F9 31 E5 82    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  87FC             >        ; now we start popping the attributes off the 'stack'
126+  87FC F1          >        pop af                      ; 1,0
126+  87FD C1          >        pop bc                      ; 3,2
126+  87FE D1          >        pop de                      ; 5,4
126+  87FF E1          >        pop hl                      ; 7,6
126+  8800             >
126+  8800             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8800 08          >        ex af, af'                  ; swap af with af'
126+  8801 D9          >        exx
126+  8802             >
126+  8802             >        ; carry on popping
126+  8802 F1          >        pop af                      ; 9,8
126+  8803 C1          >        pop bc                      ; 11,10
126+  8804 D1          >        pop de                      ; 13,12
126+  8805 E1          >        pop hl                      ; 15,14
126+  8806             >
126+  8806             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8806             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8806 31 F0 5A    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8809             >
126+  8809             >        ; we push back onto the screen memory stack in reverse order
126+  8809 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  880A D5          >        push de                     ; copy 13,12 to the screen memory
126+  880B C5          >        push bc                     ; copy 11,10 to the screen memory
126+  880C F5          >        push af                     ; copy 9,8 to the screen memory
126+  880D             >
126+  880D             >        ; swap back to the original registers
126+  880D 08          >        ex af, af'
126+  880E D9          >        exx
126+  880F             >
126+  880F E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8810 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8811 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8812 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8813             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  8813             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8813 31 F5 82    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  8816             >        ; now we start popping the attributes off the 'stack'
126+  8816 F1          >        pop af                      ; 1,0
126+  8817 C1          >        pop bc                      ; 3,2
126+  8818 D1          >        pop de                      ; 5,4
126+  8819 E1          >        pop hl                      ; 7,6
126+  881A             >
126+  881A             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  881A 08          >        ex af, af'                  ; swap af with af'
126+  881B D9          >        exx
126+  881C             >
126+  881C             >        ; carry on popping
126+  881C F1          >        pop af                      ; 9,8
126+  881D C1          >        pop bc                      ; 11,10
126+  881E D1          >        pop de                      ; 13,12
126+  881F E1          >        pop hl                      ; 15,14
126+  8820             >
126+  8820             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8820             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8820 31 00 5B    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  8823             >
126+  8823             >        ; we push back onto the screen memory stack in reverse order
126+  8823 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8824 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8825 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8826 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8827             >
126+  8827             >        ; swap back to the original registers
126+  8827 08          >        ex af, af'
126+  8828 D9          >        exx
126+  8829             >
126+  8829 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  882A D5          >        push de                     ; copy 5,4 to the screen memory
126+  882B C5          >        push bc                     ; copy 3,2 to the screen memory
126+  882C F5          >        push af                     ; copy 1,0 to the screen memory
126+  882D             >        endr
127+  882D
128+  882D                ; Restore the stack pointer from memory
129+  882D ED 7B 03 80    ld sp, (CopyOfStackPointer)
130+  8831
131+  8831                ; Return from the subroutine
132+  8831 C9             ret
133+  8832
# file closed: /Users/darren/dev/spectrum/zx/project/src/library/doubleBufferAttributes.asm
 20   8832                include "library/colours.asm"
# file opened: /Users/darren/dev/spectrum/zx/project/src/library/colours.asm
  1+  8832              ; *********************************************************************************************************************
  2+  8832              ; Author:  Darren Bowles
  3+  8832              ; Date:    2020-05-03
  4+  8832              ; Purpose: This is currently just colour constants for the ZX Spectrum
  5+  8832              ; *********************************************************************************************************************
  6+  8832
  7+  8832
  8+  8832              STABLE:         equ 0;            %00000000
  9+  8832              FLASHING:       equ 128;          %10000000
 10+  8832
 11+  8832              DULL:           equ 0;            %00000000
 12+  8832              BRIGHT:         equ 64;           %01000000
 13+  8832
 14+  8832              WHITE_PAPER:    equ 56;           %00111000
 15+  8832              YELLOW_PAPER:   equ 48;           %00110000
 16+  8832              CYAN_PAPER:     equ 40;           %00101000
 17+  8832              GREEN_PAPER:    equ 32;           %00100000
 18+  8832              MAGENTA_PAPER:  equ 24;           %00011000
 19+  8832              RED_PAPER:      equ 16;           %00010000
 20+  8832              BLUE_PAPER:     equ 8;            %00001000
 21+  8832              BLACK_PAPER:    equ 0;            %00000000
 22+  8832
 23+  8832              WHITE_INK:      equ 7;            %00000111
 24+  8832              YELLOW_INK:     equ 6;            %00000110
 25+  8832              CYAN_INK:       equ 5;            %00000101
 26+  8832              GREEN_INK:      equ 4;            %00000100
 27+  8832              MAGENTA_INK:    equ 3;            %00000011
 28+  8832              RED_INK:        equ 2;            %00000010
 29+  8832              BLUE_INK:       equ 1;            %00000001
 30+  8832              BLACK_INK:      equ 0;            %00000000
# file closed: /Users/darren/dev/spectrum/zx/project/src/library/colours.asm
 21   8832                include "music.asm"
# file opened: /Users/darren/dev/spectrum/zx/project/src/music.asm
  1+  8832
  2+  8832                include "library/music.asm"
# file opened: /Users/darren/dev/spectrum/zx/project/src/library/music.asm
  1++ 8832              ; *********************************************************************************************************************
  2++ 8832              ; Author:  Darren Bowles
  3++ 8832              ; Date:    2020-05-03
  4++ 8832              ; Purpose: Simple music
  5++ 8832              ; *********************************************************************************************************************
  6++ 8832
  7++ 8832              ; Define the note frequencies
  8++ 8832              noteC: equ 0x30
  9++ 8832              noteD: equ 0x34
 10++ 8832              noteE: equ 0x38
 11++ 8832              noteF: equ 0x3C
 12++ 8832              noteG: equ 0x40
 13++ 8832              noteA: equ 0x44
 14++ 8832              noteB: equ 0x48
 15++ 8832
 16++ 8832              ; Define the note durations
 17++ 8832              durationWhole: equ 32
 18++ 8832              durationHalf: equ 16
 19++ 8832              durationQuarter: equ 8
 20++ 8832              durationEighth: equ 4
 21++ 8832
 22++ 8832
 23++ 8832              loadNote:
 24++ 8832
 25++ 8832                ; increment the in game music note index
 26++ 8832 3A 63 88       ld a, (currentNote)
 27++ 8835 3C             inc a
 28++ 8836 32 63 88       ld (currentNote), a
 29++ 8839
 30++ 8839
 31++ 8839                ; this is like multiply by 128
 32++ 8839 E6 7E          and 126
 33++ 883B 0F             rrca
 34++ 883C
 35++ 883C 5F             ld e, a
 36++ 883D 16 00          ld d, 0
 37++ 883F
 38++ 883F 21 64 88       ld hl, tune
 39++ 8842 19             add hl, de
 40++ 8843
 41++ 8843 3E 07          ld a,7 ; pitch
 42++ 8845 07             rlca ; multiply by 2
 43++ 8846 07             rlca ; multiply by 4
 44++ 8847
 45++ 8847 D6 1C          sub 28
 46++ 8849 ED 44          neg ; make it positive
 47++ 884B
 48++ 884B 86             add a, (hl) ; add the entry from the tune data for the current note
 49++ 884C 57             ld d,a ; store the pitch in d
 50++ 884D
 51++ 884D 3E 00          ld a,0 ; border colour
 52++ 884F
 53++ 884F 5A             ld e, d ; initialise the pitch delay counter
 54++ 8850 01 03 00       ld bc, 3 ; initialise the duration delay counters in b (0) and c(3)
 55++ 8853              .noise:
 56++ 8853 D3 FE          out (254), a ; make a noise
 57++ 8855 1D             dec e
 58++ 8856 20 03          jr nz, .here
 59++ 8858 5A             ld e,d
 60++ 8859 EE 18          xor 24
 61++ 885B              .here:
 62++ 885B 10 F6          djnz .noise
 63++ 885D 0D             dec c
 64++ 885E 20 F3          jr nz, .noise
 65++ 8860
 66++ 8860
 67++ 8860 C9             ret
 68++ 8861
 69++ 8861
 70++ 8861              noteDuration:
 71++ 8861 00 00          dw 0 ; Variable to store the remaining duration of the current note
 72++ 8863              currentNote:
 73++ 8863 00             db 0 ; Variable to store the current note being played
 74++ 8864
 75++ 8864
 76++ 8864              ; Constants for musical notes
 77++ 8864              Pause     equ 0       ; Pause or rest
 78++ 8864              C4 EQU 64
 79++ 8864              CSharp4 EQU 68
 80++ 8864              D4 EQU 72
 81++ 8864              DSharp4 EQU 76
 82++ 8864              E4 EQU 81
 83++ 8864              F4 EQU 86
 84++ 8864              FSharp4 EQU 91
 85++ 8864              G4 EQU 96
 86++ 8864              GSharp4 EQU 102
 87++ 8864              A4 EQU 108
 88++ 8864              ASharp4 EQU 114
 89++ 8864              B4 EQU 120
 90++ 8864              C5 EQU 128
 91++ 8864              CSharp5 EQU 136
 92++ 8864              D5 EQU 144
 93++ 8864              DSharp5 EQU 152
 94++ 8864              E5 EQU 161
 95++ 8864              F5 EQU 170
 96++ 8864              FSharp5 EQU 180
 97++ 8864              G5 EQU 192
 98++ 8864              GSharp5 EQU 204
 99++ 8864              A5 EQU 216
100++ 8864              ASharp5 EQU 229
101++ 8864              B5 EQU 242
102++ 8864              C6 EQU 255
103++ 8864
104++ 8864
105++ 8864
106++ 8864
107++ 8864              ; Melody data
108++ 8864
109++ 8864              tune:
110++ 8864 80 66 56 56    db 128, 102, 86, 86, 171, 43
110++ 8868 AB 2B
111++ 886A 2B             db 43
112++ 886B AB             db 171
113++ 886C 33             db 51
114++ 886D 33             db 51
115++ 886E AB             db 171
116++ 886F 80             db 128
117++ 8870 80             db 128
118++ 8871 66             db 102
119++ 8872 56             db 86
120++ 8873 60             db 96
121++ 8874 AB             db 171
122++ 8875 2B             db 43
123++ 8876 2B             db 43
124++ 8877 AB             db 171
125++ 8878 30             db 48
126++ 8879 30             db 48
127++ 887A AB             db 171
128++ 887B 88             db 136
129++ 887C 88             db 136
130++ 887D 72             db 114
131++ 887E 4C             db 76
132++ 887F 4C             db 76
133++ 8880 AB             db 171
134++ 8881 26             db 38
135++ 8882 26             db 38
136++ 8883 AB             db 171
137++ 8884 30             db 48
138++ 8885 30             db 48
139++ 8886 AB             db 171
140++ 8887 88             db 136
141++ 8888 88             db 136
142++ 8889 72             db 114
143++ 888A 4C             db 76
144++ 888B 4C             db 76
145++ 888C AB             db 171
146++ 888D 26             db 38
147++ 888E 26             db 38
148++ 888F AB             db 171
149++ 8890 33             db 51
150++ 8891 33             db 51
151++ 8892 AB             db 171
152++ 8893 80             db 128
153++ 8894 80             db 128
154++ 8895 66             db 102
155++ 8896 56             db 86
156++ 8897 40             db 64
157++ 8898 80             db 128
158++ 8899 20             db 32
159++ 889A 20             db 32
160++ 889B 80             db 128
161++ 889C 2B             db 43
162++ 889D 2B             db 43
163++ 889E 80             db 128
164++ 889F 80             db 128
165++ 88A0 80             db 128
166++ 88A1 66             db 102
167++ 88A2 56             db 86
168++ 88A3 40             db 64
169++ 88A4 80             db 128
170++ 88A5 20             db 32
171++ 88A6 20             db 32
172++ 88A7 80             db 128
173++ 88A8 26             db 38
174++ 88A9 26             db 38
175++ 88AA 00             db 0
176++ 88AB 72             db 114
177++ 88AC 72             db 114
178++ 88AD 60             db 96
179++ 88AE 4C             db 76
180++ 88AF 4C             db 76
181++ 88B0 4C             db 76
182++ 88B1 4C             db 76
183++ 88B2 4C             db 76
184++ 88B3 5B             db 91
185++ 88B4 56             db 86
186++ 88B5 33             db 51
187++ 88B6 33             db 51
188++ 88B7 33             db 51
189++ 88B8 33             db 51
190++ 88B9 40             db 64
191++ 88BA 66             db 102
192++ 88BB 66             db 102
193++ 88BC 72             db 114
194++ 88BD 4C             db 76
195++ 88BE 56             db 86
196++ 88BF 80             db 128
197++ 88C0 80             db 128
198++ 88C1 80             db 128
199++ 88C2 80             db 128
200++ 88C3
201++ 88C3                ; in the hall of the mountain king
202++ 88C3                ; db C5,ASharp4,GSharp4,G4,F4,GSharp4,F4,F4,E4,G4,E4,E4,F4,GSharp4,F4,F4
203++ 88C3                ; db C5,ASharp4,GSharp4,G4,F4,GSharp4,F4,F4,E4,G4,E4,E4,F4,F4,F4,F4
204++ 88C3                ; db C5,ASharp4,GSharp4,G4,F4,GSharp4,F4,F4,E4,G4,E4,E4,F4,GSharp4,F4,F4
205++ 88C3                ; db C5,ASharp4,GSharp4,G4,F4,GSharp4,F4,C4,F4,GSharp4,C5,GSharp4,F4,F4,F4,F4
206++ 88C3
207++ 88C3                ; if I were a rich man
208++ 88C3                ; db F4,G4,F4,G4,GSharp4,GSharp4,C5,C5,C5,C5,GSharp4,G4,F4,G4,F4,G4
209++ 88C3                ; db GSharp4,G4,F4,DSharp4,D4,DSharp4,D4,DSharp4,F4,F4,F4,F4,F4,F4,F4,F4
210++ 88C3                ; db C4,C4,C4,C4,CSharp4,CSharp4,DSharp4,DSharp4,F4,G4,GSharp4,G4,F4,F4,GSharp4,GSharp4
211++ 88C3                ; db E4,F4,G4,F4,E4,E4,G4,G4,C4,C4,C4,C4,C4,C4,C4,C4
# file closed: /Users/darren/dev/spectrum/zx/project/src/library/music.asm
  3+  88C3
  4+  88C3              ; Define the tune data
  5+  88C3              tuneData:
  6+  88C3 30 20          defb noteC, durationWhole
  7+  88C5 34 08          defb noteD, durationQuarter
  8+  88C7 38 08          defb noteE, durationQuarter
  9+  88C9 3C 08          defb noteF, durationQuarter
 10+  88CB 40 08          defb noteG, durationQuarter
 11+  88CD 44 08          defb noteA, durationQuarter
 12+  88CF 48 08          defb noteB, durationQuarter
 13+  88D1 60 10          defb noteC*2, durationHalf
 14+  88D3 48 08          defb noteB, durationQuarter
 15+  88D5 44 08          defb noteA, durationQuarter
 16+  88D7 40 08          defb noteG, durationQuarter
 17+  88D9 3C 08          defb noteF, durationQuarter
 18+  88DB 38 08          defb noteE, durationQuarter
 19+  88DD 34 08          defb noteD, durationQuarter
 20+  88DF 30 10          defb noteC, durationHalf
 21+  88E1 00             defb 0 ; End of tune marker
 22+  88E2
# file closed: /Users/darren/dev/spectrum/zx/project/src/music.asm
 22   88E2
 23   88E2              ; store the previous timer value
 24   88E2 00           previousTimer: defb 0
 25   88E3
 26   88E3              ; directions
 27   88E3              up: equ 1
 28   88E3              down: equ 2
 29   88E3              left: equ 4
 30   88E3              right: equ 8
 31   88E3
 32   88E3              ; well, just blobs of colour at the moment
 33   88E3              ; direction, x, y, colour
 34   88E3              aliens:
 35   88E3 08 00 00 38    db right, 0,0, WHITE_PAPER
 36   88E7 02 00 00 38    db down, 0, 0, WHITE_PAPER
 37   88EB 04 1F 17 38    db left, 31, 23, WHITE_PAPER
 38   88EF 02 1F 00 38    db down, 31,0, WHITE_PAPER
 39   88F3 01 1F 17 38    db up, 31, 23, WHITE_PAPER
 40   88F7 08 08 17 38    db right, 8,23, WHITE_PAPER
 41   88FB 0A 0F 10 28    db right + down, 15, 16, CYAN_PAPER
 42   88FF 04 03 04 28    db left, 3,4, CYAN_PAPER
 43   8903 08 01 02 28    db right, 1,2, CYAN_PAPER
 44   8907 0A 0A 0A 28    db right + down, 10, 10, CYAN_PAPER
 45   890B 02 14 14 28    db down, 20, 20, CYAN_PAPER
 46   890F 01 15 14 28    db up, 21,20, CYAN_PAPER
 47   8913 06 20 14 18    db down + left, 32, 20, MAGENTA_PAPER
 48   8917 0A 05 06 28    db right + down, 5, 6  , CYAN_PAPER
 49   891B 04 0D 0E 28    db left, 13,14, CYAN_PAPER
 50   891F 08 0B 16 28    db right, 11,22, CYAN_PAPER
 51   8923 0A 01 01 28    db right + down, 1, 1, CYAN_PAPER
 52   8927 02 02 02 28    db down, 2, 2, CYAN_PAPER
 53   892B 01 0B 14 28    db up, 11,20, CYAN_PAPER
 54   892F 06 16 0A 28    db down + left, 22, 10, CYAN_PAPER
 55   8933 06 20 00 18    db down + left, 32, 0, MAGENTA_PAPER
 56   8937 06 1E 02 18    db down + left, 30, 2, MAGENTA_PAPER
 57   893B 06 1C 04 18    db down + left, 28, 4, MAGENTA_PAPER
 58   893F 01 04 17 30    db up, 4, 23, YELLOW_PAPER
 59   8943 01 05 17 30    db up, 5, 23, YELLOW_PAPER
 60   8947 02 0A 00 18    db down, 10, 0, MAGENTA_PAPER
 61   894B 02 0B 00 18    db down, 11, 0, MAGENTA_PAPER
 62   894F 01 0F 17 30    db up, 15, 23, YELLOW_PAPER
 63   8953 01 10 17 30    db up, 16, 23, YELLOW_PAPER
 64   8957 02 11 00 20    db down, 17, 0, GREEN_PAPER
 65   895B 02 12 00 20    db down, 18, 0, GREEN_PAPER
 66   895F 04 20 0A 10    db left, 32, 10, RED_PAPER
 67   8963 04 20 0B 10    db left, 32, 11, RED_PAPER
 68   8967 08 00 0A 10    db right, 0, 10, RED_PAPER
 69   896B 08 00 0B 10    db right, 0, 11, RED_PAPER
 70   896F 02 0F 00 10    db down, 15, 0, RED_PAPER
 71   8973 02 10 00 10    db down, 16, 0, RED_PAPER
 72   8977 01 0F 17 10    db up, 15, 23, RED_PAPER
 73   897B 01 10 17 10    db up, 16, 23, RED_PAPER
 74   897F 06 1C 00 08    db down + left, 28, 0, BLUE_PAPER
 75   8983 06 1D 01 08    db down + left, 29, 1, BLUE_PAPER
 76   8987 06 1E 02 08    db down + left, 30, 2, BLUE_PAPER
 77   898B
 78   898B              numberOfAliens: equ ($ - aliens) / 4
 79   898B
 80   898B              start:
 81   898B                ; This section of code sets up the IM2 interrupt vector table and enables interrupts.
 82   898B
 83   898B                ; Disable interrupts
 84   898B F3             di
 85   898C
 86   898C                ; Load the address of the IM2 interrupt vector table into DE
 87   898C 11 00 FE       ld de, IM2_TABLE
 88   898F
 89   898F                ; Load the address of the IM2 interrupt handler into HL
 90   898F 21 FD FD       ld hl, IM2_VECTOR
 91   8992
 92   8992                ; Load the value of D into A and set the interrupt mode to 2
 93   8992 7A             ld a,d
 94   8993 ED 47          ld i,a
 95   8995 ED 5E          im 2
 96   8997
 97   8997                ; Fill the IM2 interrupt vector table with the address of the IM2 interrupt handler
 98   8997              .fill_loop:
 99   8997 7D             ld a,l
100   8998 12             ld (de),a
101   8999 1C             inc e
102   899A C2 97 89       jp nz, .fill_loop
103   899D 14             inc d
104   899E 12             ld (de), a
105   899F
106   899F              ; Set the IM2 interrupt vector to point to the IM2 interrupt handler
107   899F 36 C3          ld (hl),$c3
108   89A1 2C             inc l
109   89A2 36 F9          ld (hl),low im2_handler
110   89A4 2C             inc l
111   89A5 36 8A          ld (hl),high im2_handler
112   89A7
113   89A7              ; Enable interrupts
114   89A7 FB             ei
115   89A8
116   89A8
117   89A8
118   89A8              ; gameLoop - Main game loop
119   89A8              gameLoop:
120   89A8                ; Wait for 2 ticks
121   89A8              .waitForTwoTicks:
122   89A8                ; Load the previous timer value into HL
123   89A8 21 E2 88       ld hl, previousTimer
124   89AB
125   89AB                ; Get the current timer value and subtract the previous timer value
126   89AB 3A 78 5C       ld a, (23672)
127   89AE 96             sub (hl)
128   89AF
129   89AF                ; Check if we've waited for 2 ticks
130   89AF              .checkIfTwoTicksWaited:
131   89AF FE 04          cp 4
132   89B1 30 03          jr nc, .twoTicksWaited ; no more delay
133   89B3
134   89B3
135   89B3                ; If we haven't waited for 2 ticks yet, jump back to the start of the loop
136   89B3 C3 A8 89       jp .waitForTwoTicks
137   89B6
138   89B6              .twoTicksWaited:
139   89B6                ; If we've waited for 2 ticks, store the current timer value as the previous timer value
140   89B6 3A 78 5C       ld a, (23672)
141   89B9 32 E2 88       ld (previousTimer), a
142   89BC
143   89BC                ; set the border colour to black
144   89BC 3E 00          ld a, 0
145   89BE D3 FE          out (254), a
146   89C0
147   89C0 CD 32 88         call loadNote
148   89C3
149   89C3                ; Loop through the aliens table and show each alien
150   89C3 DD 21 E3 88    ld ix, aliens
151   89C7 06 2A          ld b, numberOfAliens
152   89C9 0E 00          ld c, 0
153   89CB              .showAliensLoop:
154   89CB C5             push bc
155   89CC
156   89CC CD FE 89       call showAlien
157   89CF
158   89CF C1             pop bc
159   89D0
160   89D0                ; Move onto the next alien in the table
161   89D0 11 04 00       ld de, 4 ; size of the table entry
162   89D3 DD 19          add ix, de
163   89D5 10 F4          djnz .showAliensLoop
164   89D7
165   89D7              .display:
166   89D7                ; Copy the attributes buffer to the screen attributes
167   89D7 CD 49 83       call copyScreenAttributes
168   89DA
169   89DA                ; Undraw the aliens (and move them)
170   89DA CD E0 89       call undrawAliens
171   89DD
172   89DD                ; Jump back to the start of the loop
173   89DD C3 A8 89       jp gameLoop
174   89E0
175   89E0
176   89E0              ; undrawAliens - Undraws the alien and then moves it
177   89E0              undrawAliens:
178   89E0 DD 21 E3 88    ld ix, aliens ; Load the address of the aliens table into IX
179   89E4 06 2A          ld b, numberOfAliens ; Load the number of aliens into B
180   89E6 0E 00          ld c, 0 ; Initialize the loop counter
181   89E8
182   89E8              .loop:
183   89E8 C5             push bc ; Save the loop counter on the stack
184   89E9
185   89E9                ; Get the address of the current alien
186   89E9 CD 06 8A       call getAlienAddress
187   89EC
188   89EC                ; Set the paper color to black to 'undraw' the alien
189   89EC 3E 00          ld a, BLACK_PAPER
190   89EE 77             ld (hl), a
191   89EF
192   89EF                ; Move the alien
193   89EF CD 16 8A       call moveAlien
194   89F2
195   89F2                ; Check if the alien is within the screen bounds
196   89F2 CD 4B 8A       call checkBounds
197   89F5
198   89F5 C1             pop bc ; Restore the loop counter from the stack
199   89F6
200   89F6                ; Move onto the next alien in the table
201   89F6 11 04 00       ld de, 4 ; size of the table entry
202   89F9 DD 19          add ix, de
203   89FB 10 EB          djnz .loop ; Decrement B and jump back to the start of the loop if B is not zero
204   89FD
205   89FD                ; Return from the subroutine
206   89FD C9             ret
207   89FE
208   89FE              ; showAlien - Displays the alien on the screen
209   89FE              showAlien:
210   89FE                ; Get the address of the current alien
211   89FE CD 06 8A       call getAlienAddress
212   8A01
213   8A01                ; Get the color of the alien from the table and put it in the buffer
214   8A01 DD 7E 03       ld a, (ix+3)
215   8A04 77             ld (hl), a
216   8A05
217   8A05                ; Return from the subroutine
218   8A05 C9             ret
219   8A06
220   8A06              ; getAlienAddress - Gets the address of the current alien in the attribute buffer
221   8A06              getAlienAddress:
222   8A06                ; Check if the alien is disabled
223   8A06 DD 7E 00       ld a, (ix) ; Load the status/direction byte into A
224   8A09 FE FF          cp 255 ; Check if it's equal to 255 (disabled)
225   8A0B C8             ret z ; If it's disabled, return
226   8A0C
227   8A0C                ; Get the x and y coordinates of the alien
228   8A0C DD 46 01       ld b, (ix+1) ; Load the x coordinate into B
229   8A0F DD 4E 02       ld c, (ix+2) ; Load the y coordinate into C
230   8A12
231   8A12                ; Calculate the address of the alien in the attribute buffer
232   8A12 CD 35 83       call CalculateAttributeBufferAddress
233   8A15
234   8A15                ; Return from the subroutine with the address in HL
235   8A15 C9             ret
236   8A16
237   8A16              ; moveAlien - Moves the alien in the direction specified by its status byte
238   8A16              moveAlien:
239   8A16                ; Check if the alien is moving up
240   8A16 DD 7E 00       ld a, (ix)
241   8A19 E6 01          and up
242   8A1B C4 37 8A       call nz, moveAlienUp
243   8A1E
244   8A1E                ; Check if the alien is moving down
245   8A1E DD 7E 00       ld a, (ix)
246   8A21 E6 02          and down
247   8A23 C4 3C 8A       call nz, moveAlienDown
248   8A26
249   8A26                ; Check if the alien is moving left
250   8A26 DD 7E 00       ld a, (ix)
251   8A29 E6 04          and left
252   8A2B C4 41 8A       call nz, moveAlienLeft
253   8A2E
254   8A2E                ; Check if the alien is moving right
255   8A2E DD 7E 00       ld a, (ix)
256   8A31 E6 08          and right
257   8A33 C4 46 8A       call nz, moveAlienRight
258   8A36
259   8A36 C9             ret
260   8A37
261   8A37              ; moveAlienUp - Moves the alien up by decrementing its y coordinate
262   8A37              moveAlienUp:
263   8A37 0D             dec c ; Decrement the y coordinate
264   8A38 DD 71 02       ld (ix+2), c ; Store the new y coordinate in the aliens table
265   8A3B C9             ret
266   8A3C
267   8A3C              ; moveAlienDown - Moves the alien down by incrementing its y coordinate
268   8A3C              moveAlienDown:
269   8A3C 0C             inc c ; Increment the y coordinate
270   8A3D DD 71 02       ld (ix+2), c ; Store the new y coordinate in the aliens table
271   8A40 C9             ret
272   8A41
273   8A41              ; moveAlienLeft - Moves the alien left by decrementing its x coordinate
274   8A41              moveAlienLeft:
275   8A41 05             dec b ; Decrement the x coordinate
276   8A42 DD 70 01       ld (ix+1), b ; Store the new x coordinate in the aliens table
277   8A45 C9             ret
278   8A46
279   8A46              ; moveAlienRight - Moves the alien right by incrementing its x coordinate
280   8A46              moveAlienRight:
281   8A46 04             inc b ; Increment the x coordinate
282   8A47 DD 70 01       ld (ix+1), b ; Store the new x coordinate in the aliens table
283   8A4A C9             ret
284   8A4B
285   8A4B              checkBounds:
286   8A4B                ; the position is stored in bc
287   8A4B DD 7E 00       ld a, (ix) ;  load the direction / status into D
288   8A4E
289   8A4E              .checkRight:
290   8A4E                ; are we going right
291   8A4E CB 5F          bit 3, a
292   8A50 28 0F          jr z, .checkLeft
293   8A52                ; if we are going right, check if we've hit the right boundary
294   8A52 78             ld a, b ; load the X position into A
295   8A53 FE 1F          cp 31                    ; compare with the right boundary
296   8A55 20 0A          jr nz, .checkLeft        ; if A < 31, we haven't hit the right boundary
297   8A57 DD 7E 00       ld a, (ix)
298   8A5A E6 F7          and 255 - right
299   8A5C F6 04          or left
300   8A5E DD 77 00       ld (ix), a
301   8A61
302   8A61
303   8A61              .checkLeft:
304   8A61                ; are we going left
305   8A61 DD 7E 00       ld a, (ix) ;  load the direction / status into D
306   8A64 CB 57          bit 2, a
307   8A66 28 0F          jr z, .checkUp
308   8A68                ; if we are going left, check if we've hit the left boundary
309   8A68 78             ld a, b ; load the X position into A
310   8A69 FE 00          cp 0
311   8A6B 20 0A          jr nz, .checkUp
312   8A6D DD 7E 00       ld a, (ix)
313   8A70 E6 FB          and 255 - left
314   8A72 F6 08          or right
315   8A74 DD 77 00       ld (ix), a
316   8A77
317   8A77              .checkUp:
318   8A77                ; are we going up
319   8A77 DD 7E 00       ld a, (ix) ;  load the direction / status into D
320   8A7A CB 47          bit 0, a
321   8A7C 28 12          jr z, .checkDown
322   8A7E                ; if we are going up, check if we've hit the top boundary
323   8A7E 79             ld a, c
324   8A7F FE 00          cp 0
325   8A81 20 0D          jr nz, .checkDown
326   8A83 DD 7E 00       ld a, (ix)
327   8A86 E6 FE          and 255 - up
328   8A88 F6 02          or down
329   8A8A DD 77 00       ld (ix), a
330   8A8D C3 A6 8A       jp .done
331   8A90
332   8A90              .checkDown:
333   8A90                ; are we going down
334   8A90 DD 7E 00       ld a, (ix) ;  load the direction / status into D
335   8A93 CB 4F          bit 1, a
336   8A95 28 0F          jr z, .done
337   8A97                ; if we are going down, check if we've hit the bottom boundary
338   8A97 79             ld a, c
339   8A98 FE 17          cp 23                    ; compare with the bottom boundary
340   8A9A 20 0A          jr nz, .done             ; if A < 23, we haven't hit the bottom boundary
341   8A9C DD 7E 00       ld a, (ix)
342   8A9F E6 FD          and 255 - down
343   8AA1 F6 01          or up
344   8AA3 DD 77 00       ld (ix), a
345   8AA6              .done:
346   8AA6 C9             ret
347   8AA7
348   8AA7
349   8AA7 FE 1F          cp 31                    ; compare with the right boundary
350   8AA9 30 3B          jr nc, hitRightBoundary  ; if A >= 31, we've hit the right boundary
351   8AAB B7             or a                     ; check if A is 0 (the left boundary)
352   8AAC 28 25          jr z, hitLeftBoundary    ; if A == 0, we've hit the left boundary
353   8AAE              checkUpperLowerScreenBounds:
354   8AAE                                   ; move to Y position in memory
355   8AAE 79             ld a, c               ; load the Y position into A
356   8AAF FE 17          cp 23                    ; compare with the bottom boundary
357   8AB1 30 12          jr nc, hitBottomBoundary ; if A >= 23, we've hit the bottom boundary
358   8AB3 B7             or a                     ; check if A is 0 (the top boundary)
359   8AB4 28 01          jr z, hitTopBoundary     ; if A == 0, we've hit the top boundary
360   8AB6
361   8AB6 C9             ret
362   8AB7
363   8AB7              hitTopBoundary:
364   8AB7 DD 7E 00       ld a, (ix)
365   8ABA
366   8ABA CB 47          bit 0, a            ; Check if the "down" bit is set in A.
367   8ABC C8             ret z  ; If the "down" bit is not set, we don't need to change the direction.
368   8ABD
369   8ABD
370   8ABD E6 FE          and 255 - up
371   8ABF F6 02          or down
372   8AC1 DD 77 00       ld (ix), a
373   8AC4 C9             ret
374   8AC5
375   8AC5              ; This function is called when the alien hits the bottom boundary of the screen.
376   8AC5              ; It plays a sound effect, changes the direction of the alien to move up, and returns.
377   8AC5
378   8AC5              hitBottomBoundary:
379   8AC5 DD 7E 00       ld a, (ix)          ; Load the current direction of the alien into A.
380   8AC8
381   8AC8 CB 4F          bit 1, a            ; Check if the "down" bit is set in A.
382   8ACA C8             ret z  ; If the "down" bit is not set, we don't need to change the direction.
383   8ACB
384   8ACB
385   8ACB E6 FD          and 255 - down      ; Clear the "down" bit in A by ANDing it with the bitwise complement of "down".
386   8ACD F6 01          or up               ; Set the "up" bit in A by ORing it with "up".
387   8ACF DD 77 00       ld (ix), a          ; Store the new direction back into memory.
388   8AD2 C9             ret                 ; Return from the function.
389   8AD3
390   8AD3              hitLeftBoundary:
391   8AD3 DD 7E 00       ld a, (ix)
392   8AD6 CB 5F          bit 3,a
393   8AD8 CA AE 8A       jp z, checkUpperLowerScreenBounds ; If the "left" bit is not set, we don't need to change the direction.
394   8ADB E6 FB          and 255 - left
395   8ADD F6 08          or right
396   8ADF DD 77 00       ld (ix), a
397   8AE2 C3 AE 8A       jp checkUpperLowerScreenBounds
398   8AE5 C9             ret
399   8AE6              hitRightBoundary:
400   8AE6 DD 7E 00       ld a, (ix)
401   8AE9
402   8AE9 CB 67          bit 4, a ; Check if the "right" bit is set in A.
403   8AEB CA AE 8A       jp z, checkUpperLowerScreenBounds ; If the "right" bit is not set, we don't need to change the direction.
404   8AEE
405   8AEE E6 F7          and 255 - right
406   8AF0 F6 04          or left
407   8AF2 DD 77 00       ld (ix), a
408   8AF5 C3 AE 8A       jp checkUpperLowerScreenBounds
409   8AF8 C9             ret
410   8AF9
411   8AF9              im2_handler:
412   8AF9 F5             push af
413   8AFA C5             push bc
414   8AFB D5             push de
415   8AFC E5             push hl
416   8AFD 08             ex af,af'
417   8AFE D9             exx
418   8AFF F5             push af
419   8B00 C5             push bc
420   8B01 D5             push de
421   8B02 E5             push hl
422   8B03 DD E5          push ix
423   8B05 FD E5          push iy
424   8B07
425   8B07                ; play music here
426   8B07                ; call loadNote
427   8B07
428   8B07                ;rst 56 ; read the keys and update clock
429   8B07 2A 78 5C       ld hl, (23672)
430   8B0A 23             inc hl
431   8B0B 22 78 5C       ld (23672), hl
432   8B0E 7C             ld a,h
433   8B0F B5             or l
434   8B10
435   8B10                ; ^^ this is the same as rst 56
436   8B10
437   8B10 FD E1          pop iy
438   8B12 DD E1          pop ix
439   8B14 E1             pop hl
440   8B15 D1             pop de
441   8B16 C1             pop bc
442   8B17 F1             pop af
443   8B18 08             ex af,af'
444   8B19 D9             exx
445   8B1A E1             pop hl
446   8B1B D1             pop de
447   8B1C C1             pop bc
448   8B1D F1             pop af
449   8B1E FB             ei
450   8B1F C9             ret
451   8B20
452   8B20
453   8B20              ; Deployment
454   8B20                savesna "myapp.sna",start  ; Save the program as a snapshot file
# file closed: /Users/darren/dev/spectrum/zx/project/src/myapp.asm
