# file opened: /Users/darren/dev/spectrum/zx/project/src/myapp.asm
  1   0000              ; *********************************************************************************************************************
  2   0000              ; Author:  Darren Bowles
  3   0000              ; Date:    2020-05-03
  4   0000              ; Purpose: This is just a test to help me learn coding Z80 on a ZX Spectrum
  5   0000              ; shout out to Jonathan Cauldwell for their excellent tutorials and Allan Turvey of Happy Coding ZX for
  6   0000              ; inspiration from his live streaming warts n all coding session on Lunar Rescue conversion
  7   0000              ; *********************************************************************************************************************
  8   0000
  9   0000
 10   0000                device zxspectrum48
 11   0000
 12   0000              IM2_TABLE   = $FE00 ; IM2 interrupt vector table in decimal is 65024
 13   0000              IM2_VECTOR  = $FDFD ; IM2 interrupt vector in decimal is 65021
 14   0000
 15   0000
 16   0000                org 32768             ; Set the origin of the program to 32768 (the start of the BASIC area)
 17   8000 C3 6C 89       jp start              ; Jump to the start of the program
 18   8003
 19   8003                include "library/doubleBufferAttributes.asm"
# file opened: /Users/darren/dev/spectrum/zx/project/src/library/doubleBufferAttributes.asm
  1+  8003              ; *********************************************************************************************************************
  2+  8003              ; Author:  Darren Bowles
  3+  8003              ; Date:    2020-05-03
  4+  8003              ; Purpose: This is a simple example of how to do double buffering with the screen attributes
  5+  8003              ; It's the same style that Jonathan Cauldwell mentions as being used in Rallybug
  6+  8003              ; see https://chuntey.wordpress.com/tag/double-buffering/ apart from i'm not doing screen memory (yet)
  7+  8003              ; and it's using some sjasmplus macros
  8+  8003              ; *********************************************************************************************************************
  9+  8003
 10+  8003              ; we'll need to keep a copy of the stack pointer, as we'll be moving it around
 11+  8003 00 00        CopyOfStackPointer: defw 0
 12+  8005
 13+  8005                  ; this macro copies over the screen attributes from the attribute buffer to the screen
 14+  8005                  macro DoCopy row, columnStart
 15+  8005 ~                    ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
 16+  8005 ~                    ld sp, AttributeBuffer + (row * 32) + columnStart
 17+  8005 ~                    ; now we start popping the attributes off the 'stack'
 18+  8005 ~                    pop af                      ; 1,0
 19+  8005 ~                    pop bc                      ; 3,2
 20+  8005 ~                    pop de                      ; 5,4
 21+  8005 ~                    pop hl                      ; 7,6
 22+  8005 ~
 23+  8005 ~                    ; oops, we've run out of registers, so we need to swap to alternate registers
 24+  8005 ~                    ex af, af'                  ; swap af with af'
 25+  8005 ~                    exx
 26+  8005 ~
 27+  8005 ~                    ; carry on popping
 28+  8005 ~                    pop af                      ; 9,8
 29+  8005 ~                    pop bc                      ; 11,10
 30+  8005 ~                    pop de                      ; 13,12
 31+  8005 ~                    pop hl                      ; 15,14
 32+  8005 ~
 33+  8005 ~                    ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
 34+  8005 ~                    ; as well as including the 16 bytes that we popped off the buffer stack and stored
 35+  8005 ~                    ld sp, $5800 + (row * 32) + columnStart + 16
 36+  8005 ~
 37+  8005 ~                    ; we push back onto the screen memory stack in reverse order
 38+  8005 ~                    push hl                     ; copy 15,14 to the screen memory
 39+  8005 ~                    push de                     ; copy 13,12 to the screen memory
 40+  8005 ~                    push bc                     ; copy 11,10 to the screen memory
 41+  8005 ~                    push af                     ; copy 9,8 to the screen memory
 42+  8005 ~
 43+  8005 ~                    ; swap back to the original registers
 44+  8005 ~                    ex af, af'
 45+  8005 ~                    exx
 46+  8005 ~
 47+  8005 ~                    push hl                     ; copy 7,6 to the screen memory
 48+  8005 ~                    push de                     ; copy 5,4 to the screen memory
 49+  8005 ~                    push bc                     ; copy 3,2 to the screen memory
 50+  8005 ~                    push af                     ; copy 1,0 to the screen memory
 51+  8005                  endm
 52+  8005
 53+  8005                  ; this macro copies over a number of rows
 54+  8005                  macro BufferCopyMacro count
 55+  8005 ~                    rept count, i
 56+  8005 ~                        DoCopy i, 0   ; copy the first 16 attributes over to the row
 57+  8005 ~                        DoCopy i, 16  ; copy the remaining 16 attributes over to the row
 58+  8005 ~                    endr
 59+  8005                  endm
 60+  8005
 61+  8005                  ; this macro generates the lookup table for the attribute buffer
 62+  8005                  macro AttributeBufferLookupMacro count
 63+  8005 ~                    rept count, i
 64+  8005 ~                        defw AttributeBuffer + (32 * i)
 65+  8005 ~                    endr
 66+  8005                  endm
 67+  8005
 68+  8005              ; here's our buffer - let's initialise it to all white paper, black ink
 69+  8005              AttributeBuffer:
 70+  8005 07 07 07...      block 768, STABLE + DULL + BLACK_PAPER + WHITE_INK
 71+  8305
 72+  8305              ; here's our lookup table
 73+  8305              AttributeBufferLookup:
 74+  8305                  AttributeBufferLookupMacro 24;
 74+  8305             >        rept 24, i
 74+  8305 05 80       >            defw AttributeBuffer + (32 * i)
 74+  8307 25 80       >            defw AttributeBuffer + (32 * i)
 74+  8309 45 80       >            defw AttributeBuffer + (32 * i)
 74+  830B 65 80       >            defw AttributeBuffer + (32 * i)
 74+  830D 85 80       >            defw AttributeBuffer + (32 * i)
 74+  830F A5 80       >            defw AttributeBuffer + (32 * i)
 74+  8311 C5 80       >            defw AttributeBuffer + (32 * i)
 74+  8313 E5 80       >            defw AttributeBuffer + (32 * i)
 74+  8315 05 81       >            defw AttributeBuffer + (32 * i)
 74+  8317 25 81       >            defw AttributeBuffer + (32 * i)
 74+  8319 45 81       >            defw AttributeBuffer + (32 * i)
 74+  831B 65 81       >            defw AttributeBuffer + (32 * i)
 74+  831D 85 81       >            defw AttributeBuffer + (32 * i)
 74+  831F A5 81       >            defw AttributeBuffer + (32 * i)
 74+  8321 C5 81       >            defw AttributeBuffer + (32 * i)
 74+  8323 E5 81       >            defw AttributeBuffer + (32 * i)
 74+  8325 05 82       >            defw AttributeBuffer + (32 * i)
 74+  8327 25 82       >            defw AttributeBuffer + (32 * i)
 74+  8329 45 82       >            defw AttributeBuffer + (32 * i)
 74+  832B 65 82       >            defw AttributeBuffer + (32 * i)
 74+  832D 85 82       >            defw AttributeBuffer + (32 * i)
 74+  832F A5 82       >            defw AttributeBuffer + (32 * i)
 74+  8331 C5 82       >            defw AttributeBuffer + (32 * i)
 74+  8333 E5 82       >            defw AttributeBuffer + (32 * i)
 74+  8335             >        endr
 75+  8335
 76+  8335
 77+  8335              ; CalculateAttributeBufferAddress - Calculates the attribute buffer address for a given position (X, Y)
 78+  8335              ;
 79+  8335              ; Input:
 80+  8335              ;   B: X coordinate (0-31)
 81+  8335              ;   C: Y coordinate (0-23)
 82+  8335              ;
 83+  8335              ; Output:
 84+  8335              ;   HL: Attribute Buffer address
 85+  8335              ;
 86+  8335              CalculateAttributeBufferAddress:
 87+  8335                ; Load the address of the lookup table into HL
 88+  8335 21 05 83       ld hl, AttributeBufferLookup
 89+  8338
 90+  8338                ; Double the Y coordinate by adding it to itself
 91+  8338 79             ld a, c
 92+  8339 87             add a, a
 93+  833A 85             add a, l
 94+  833B 6F             ld l, a
 95+  833C
 96+  833C                ; Get the table address for the Y coordinate
 97+  833C 5E 23 56 2B    ld de, (hl)
 98+  8340
 99+  8340                ; Add the X coordinate (in register B) to the table address (in register E)
100+  8340 78             ld a, b
101+  8341 83             add a, e
102+  8342 5F             ld e, a
103+  8343
104+  8343                ; Check if we got a carry (i.e. we exceeded 255)
105+  8343 30 01          jr nc, .noCarry
106+  8345
107+  8345                ; If we got a carry, increment the high byte of the address
108+  8345 14             inc d
109+  8346
110+  8346              .noCarry:
111+  8346                ; Move the combined address into HL
112+  8346 62 6B          ld hl, de
113+  8348
114+  8348                ; Return from the subroutine
115+  8348 C9             ret
116+  8349
117+  8349
118+  8349              ; Copy the attributes buffer to the screen attributes
119+  8349              ; TODO: This is a crude implementation that copies the entire buffer.
120+  8349              ; A more efficient implementation is possible.
121+  8349              copyScreenAttributes:
122+  8349                ; Save the current stack pointer to memory
123+  8349 ED 73 03 80    ld (CopyOfStackPointer), sp
124+  834D
125+  834D                ; Call the "BufferCopyMacro" macro to copy the buffer
126+  834D                BufferCopyMacro 24
126+  834D             >        rept 24, i
126+  834D             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  834D             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  834D 31 05 80    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8350             >        ; now we start popping the attributes off the 'stack'
126+  8350 F1          >        pop af                      ; 1,0
126+  8351 C1          >        pop bc                      ; 3,2
126+  8352 D1          >        pop de                      ; 5,4
126+  8353 E1          >        pop hl                      ; 7,6
126+  8354             >
126+  8354             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8354 08          >        ex af, af'                  ; swap af with af'
126+  8355 D9          >        exx
126+  8356             >
126+  8356             >        ; carry on popping
126+  8356 F1          >        pop af                      ; 9,8
126+  8357 C1          >        pop bc                      ; 11,10
126+  8358 D1          >        pop de                      ; 13,12
126+  8359 E1          >        pop hl                      ; 15,14
126+  835A             >
126+  835A             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  835A             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  835A 31 10 58    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  835D             >
126+  835D             >        ; we push back onto the screen memory stack in reverse order
126+  835D E5          >        push hl                     ; copy 15,14 to the screen memory
126+  835E D5          >        push de                     ; copy 13,12 to the screen memory
126+  835F C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8360 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8361             >
126+  8361             >        ; swap back to the original registers
126+  8361 08          >        ex af, af'
126+  8362 D9          >        exx
126+  8363             >
126+  8363 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8364 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8365 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8366 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8367             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  8367             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8367 31 15 80    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  836A             >        ; now we start popping the attributes off the 'stack'
126+  836A F1          >        pop af                      ; 1,0
126+  836B C1          >        pop bc                      ; 3,2
126+  836C D1          >        pop de                      ; 5,4
126+  836D E1          >        pop hl                      ; 7,6
126+  836E             >
126+  836E             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  836E 08          >        ex af, af'                  ; swap af with af'
126+  836F D9          >        exx
126+  8370             >
126+  8370             >        ; carry on popping
126+  8370 F1          >        pop af                      ; 9,8
126+  8371 C1          >        pop bc                      ; 11,10
126+  8372 D1          >        pop de                      ; 13,12
126+  8373 E1          >        pop hl                      ; 15,14
126+  8374             >
126+  8374             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8374             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8374 31 20 58    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  8377             >
126+  8377             >        ; we push back onto the screen memory stack in reverse order
126+  8377 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8378 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8379 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  837A F5          >        push af                     ; copy 9,8 to the screen memory
126+  837B             >
126+  837B             >        ; swap back to the original registers
126+  837B 08          >        ex af, af'
126+  837C D9          >        exx
126+  837D             >
126+  837D E5          >        push hl                     ; copy 7,6 to the screen memory
126+  837E D5          >        push de                     ; copy 5,4 to the screen memory
126+  837F C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8380 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8381             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8381             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8381 31 25 80    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8384             >        ; now we start popping the attributes off the 'stack'
126+  8384 F1          >        pop af                      ; 1,0
126+  8385 C1          >        pop bc                      ; 3,2
126+  8386 D1          >        pop de                      ; 5,4
126+  8387 E1          >        pop hl                      ; 7,6
126+  8388             >
126+  8388             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8388 08          >        ex af, af'                  ; swap af with af'
126+  8389 D9          >        exx
126+  838A             >
126+  838A             >        ; carry on popping
126+  838A F1          >        pop af                      ; 9,8
126+  838B C1          >        pop bc                      ; 11,10
126+  838C D1          >        pop de                      ; 13,12
126+  838D E1          >        pop hl                      ; 15,14
126+  838E             >
126+  838E             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  838E             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  838E 31 30 58    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8391             >
126+  8391             >        ; we push back onto the screen memory stack in reverse order
126+  8391 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8392 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8393 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8394 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8395             >
126+  8395             >        ; swap back to the original registers
126+  8395 08          >        ex af, af'
126+  8396 D9          >        exx
126+  8397             >
126+  8397 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8398 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8399 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  839A F5          >        push af                     ; copy 1,0 to the screen memory
126+  839B             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  839B             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  839B 31 35 80    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  839E             >        ; now we start popping the attributes off the 'stack'
126+  839E F1          >        pop af                      ; 1,0
126+  839F C1          >        pop bc                      ; 3,2
126+  83A0 D1          >        pop de                      ; 5,4
126+  83A1 E1          >        pop hl                      ; 7,6
126+  83A2             >
126+  83A2             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  83A2 08          >        ex af, af'                  ; swap af with af'
126+  83A3 D9          >        exx
126+  83A4             >
126+  83A4             >        ; carry on popping
126+  83A4 F1          >        pop af                      ; 9,8
126+  83A5 C1          >        pop bc                      ; 11,10
126+  83A6 D1          >        pop de                      ; 13,12
126+  83A7 E1          >        pop hl                      ; 15,14
126+  83A8             >
126+  83A8             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  83A8             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  83A8 31 40 58    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  83AB             >
126+  83AB             >        ; we push back onto the screen memory stack in reverse order
126+  83AB E5          >        push hl                     ; copy 15,14 to the screen memory
126+  83AC D5          >        push de                     ; copy 13,12 to the screen memory
126+  83AD C5          >        push bc                     ; copy 11,10 to the screen memory
126+  83AE F5          >        push af                     ; copy 9,8 to the screen memory
126+  83AF             >
126+  83AF             >        ; swap back to the original registers
126+  83AF 08          >        ex af, af'
126+  83B0 D9          >        exx
126+  83B1             >
126+  83B1 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  83B2 D5          >        push de                     ; copy 5,4 to the screen memory
126+  83B3 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  83B4 F5          >        push af                     ; copy 1,0 to the screen memory
126+  83B5             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  83B5             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  83B5 31 45 80    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  83B8             >        ; now we start popping the attributes off the 'stack'
126+  83B8 F1          >        pop af                      ; 1,0
126+  83B9 C1          >        pop bc                      ; 3,2
126+  83BA D1          >        pop de                      ; 5,4
126+  83BB E1          >        pop hl                      ; 7,6
126+  83BC             >
126+  83BC             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  83BC 08          >        ex af, af'                  ; swap af with af'
126+  83BD D9          >        exx
126+  83BE             >
126+  83BE             >        ; carry on popping
126+  83BE F1          >        pop af                      ; 9,8
126+  83BF C1          >        pop bc                      ; 11,10
126+  83C0 D1          >        pop de                      ; 13,12
126+  83C1 E1          >        pop hl                      ; 15,14
126+  83C2             >
126+  83C2             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  83C2             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  83C2 31 50 58    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  83C5             >
126+  83C5             >        ; we push back onto the screen memory stack in reverse order
126+  83C5 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  83C6 D5          >        push de                     ; copy 13,12 to the screen memory
126+  83C7 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  83C8 F5          >        push af                     ; copy 9,8 to the screen memory
126+  83C9             >
126+  83C9             >        ; swap back to the original registers
126+  83C9 08          >        ex af, af'
126+  83CA D9          >        exx
126+  83CB             >
126+  83CB E5          >        push hl                     ; copy 7,6 to the screen memory
126+  83CC D5          >        push de                     ; copy 5,4 to the screen memory
126+  83CD C5          >        push bc                     ; copy 3,2 to the screen memory
126+  83CE F5          >        push af                     ; copy 1,0 to the screen memory
126+  83CF             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  83CF             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  83CF 31 55 80    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  83D2             >        ; now we start popping the attributes off the 'stack'
126+  83D2 F1          >        pop af                      ; 1,0
126+  83D3 C1          >        pop bc                      ; 3,2
126+  83D4 D1          >        pop de                      ; 5,4
126+  83D5 E1          >        pop hl                      ; 7,6
126+  83D6             >
126+  83D6             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  83D6 08          >        ex af, af'                  ; swap af with af'
126+  83D7 D9          >        exx
126+  83D8             >
126+  83D8             >        ; carry on popping
126+  83D8 F1          >        pop af                      ; 9,8
126+  83D9 C1          >        pop bc                      ; 11,10
126+  83DA D1          >        pop de                      ; 13,12
126+  83DB E1          >        pop hl                      ; 15,14
126+  83DC             >
126+  83DC             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  83DC             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  83DC 31 60 58    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  83DF             >
126+  83DF             >        ; we push back onto the screen memory stack in reverse order
126+  83DF E5          >        push hl                     ; copy 15,14 to the screen memory
126+  83E0 D5          >        push de                     ; copy 13,12 to the screen memory
126+  83E1 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  83E2 F5          >        push af                     ; copy 9,8 to the screen memory
126+  83E3             >
126+  83E3             >        ; swap back to the original registers
126+  83E3 08          >        ex af, af'
126+  83E4 D9          >        exx
126+  83E5             >
126+  83E5 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  83E6 D5          >        push de                     ; copy 5,4 to the screen memory
126+  83E7 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  83E8 F5          >        push af                     ; copy 1,0 to the screen memory
126+  83E9             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  83E9             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  83E9 31 65 80    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  83EC             >        ; now we start popping the attributes off the 'stack'
126+  83EC F1          >        pop af                      ; 1,0
126+  83ED C1          >        pop bc                      ; 3,2
126+  83EE D1          >        pop de                      ; 5,4
126+  83EF E1          >        pop hl                      ; 7,6
126+  83F0             >
126+  83F0             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  83F0 08          >        ex af, af'                  ; swap af with af'
126+  83F1 D9          >        exx
126+  83F2             >
126+  83F2             >        ; carry on popping
126+  83F2 F1          >        pop af                      ; 9,8
126+  83F3 C1          >        pop bc                      ; 11,10
126+  83F4 D1          >        pop de                      ; 13,12
126+  83F5 E1          >        pop hl                      ; 15,14
126+  83F6             >
126+  83F6             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  83F6             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  83F6 31 70 58    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  83F9             >
126+  83F9             >        ; we push back onto the screen memory stack in reverse order
126+  83F9 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  83FA D5          >        push de                     ; copy 13,12 to the screen memory
126+  83FB C5          >        push bc                     ; copy 11,10 to the screen memory
126+  83FC F5          >        push af                     ; copy 9,8 to the screen memory
126+  83FD             >
126+  83FD             >        ; swap back to the original registers
126+  83FD 08          >        ex af, af'
126+  83FE D9          >        exx
126+  83FF             >
126+  83FF E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8400 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8401 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8402 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8403             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  8403             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8403 31 75 80    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  8406             >        ; now we start popping the attributes off the 'stack'
126+  8406 F1          >        pop af                      ; 1,0
126+  8407 C1          >        pop bc                      ; 3,2
126+  8408 D1          >        pop de                      ; 5,4
126+  8409 E1          >        pop hl                      ; 7,6
126+  840A             >
126+  840A             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  840A 08          >        ex af, af'                  ; swap af with af'
126+  840B D9          >        exx
126+  840C             >
126+  840C             >        ; carry on popping
126+  840C F1          >        pop af                      ; 9,8
126+  840D C1          >        pop bc                      ; 11,10
126+  840E D1          >        pop de                      ; 13,12
126+  840F E1          >        pop hl                      ; 15,14
126+  8410             >
126+  8410             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8410             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8410 31 80 58    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  8413             >
126+  8413             >        ; we push back onto the screen memory stack in reverse order
126+  8413 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8414 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8415 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8416 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8417             >
126+  8417             >        ; swap back to the original registers
126+  8417 08          >        ex af, af'
126+  8418 D9          >        exx
126+  8419             >
126+  8419 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  841A D5          >        push de                     ; copy 5,4 to the screen memory
126+  841B C5          >        push bc                     ; copy 3,2 to the screen memory
126+  841C F5          >        push af                     ; copy 1,0 to the screen memory
126+  841D             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  841D             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  841D 31 85 80    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8420             >        ; now we start popping the attributes off the 'stack'
126+  8420 F1          >        pop af                      ; 1,0
126+  8421 C1          >        pop bc                      ; 3,2
126+  8422 D1          >        pop de                      ; 5,4
126+  8423 E1          >        pop hl                      ; 7,6
126+  8424             >
126+  8424             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8424 08          >        ex af, af'                  ; swap af with af'
126+  8425 D9          >        exx
126+  8426             >
126+  8426             >        ; carry on popping
126+  8426 F1          >        pop af                      ; 9,8
126+  8427 C1          >        pop bc                      ; 11,10
126+  8428 D1          >        pop de                      ; 13,12
126+  8429 E1          >        pop hl                      ; 15,14
126+  842A             >
126+  842A             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  842A             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  842A 31 90 58    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  842D             >
126+  842D             >        ; we push back onto the screen memory stack in reverse order
126+  842D E5          >        push hl                     ; copy 15,14 to the screen memory
126+  842E D5          >        push de                     ; copy 13,12 to the screen memory
126+  842F C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8430 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8431             >
126+  8431             >        ; swap back to the original registers
126+  8431 08          >        ex af, af'
126+  8432 D9          >        exx
126+  8433             >
126+  8433 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8434 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8435 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8436 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8437             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  8437             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8437 31 95 80    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  843A             >        ; now we start popping the attributes off the 'stack'
126+  843A F1          >        pop af                      ; 1,0
126+  843B C1          >        pop bc                      ; 3,2
126+  843C D1          >        pop de                      ; 5,4
126+  843D E1          >        pop hl                      ; 7,6
126+  843E             >
126+  843E             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  843E 08          >        ex af, af'                  ; swap af with af'
126+  843F D9          >        exx
126+  8440             >
126+  8440             >        ; carry on popping
126+  8440 F1          >        pop af                      ; 9,8
126+  8441 C1          >        pop bc                      ; 11,10
126+  8442 D1          >        pop de                      ; 13,12
126+  8443 E1          >        pop hl                      ; 15,14
126+  8444             >
126+  8444             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8444             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8444 31 A0 58    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  8447             >
126+  8447             >        ; we push back onto the screen memory stack in reverse order
126+  8447 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8448 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8449 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  844A F5          >        push af                     ; copy 9,8 to the screen memory
126+  844B             >
126+  844B             >        ; swap back to the original registers
126+  844B 08          >        ex af, af'
126+  844C D9          >        exx
126+  844D             >
126+  844D E5          >        push hl                     ; copy 7,6 to the screen memory
126+  844E D5          >        push de                     ; copy 5,4 to the screen memory
126+  844F C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8450 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8451             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8451             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8451 31 A5 80    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8454             >        ; now we start popping the attributes off the 'stack'
126+  8454 F1          >        pop af                      ; 1,0
126+  8455 C1          >        pop bc                      ; 3,2
126+  8456 D1          >        pop de                      ; 5,4
126+  8457 E1          >        pop hl                      ; 7,6
126+  8458             >
126+  8458             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8458 08          >        ex af, af'                  ; swap af with af'
126+  8459 D9          >        exx
126+  845A             >
126+  845A             >        ; carry on popping
126+  845A F1          >        pop af                      ; 9,8
126+  845B C1          >        pop bc                      ; 11,10
126+  845C D1          >        pop de                      ; 13,12
126+  845D E1          >        pop hl                      ; 15,14
126+  845E             >
126+  845E             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  845E             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  845E 31 B0 58    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8461             >
126+  8461             >        ; we push back onto the screen memory stack in reverse order
126+  8461 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8462 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8463 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8464 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8465             >
126+  8465             >        ; swap back to the original registers
126+  8465 08          >        ex af, af'
126+  8466 D9          >        exx
126+  8467             >
126+  8467 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8468 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8469 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  846A F5          >        push af                     ; copy 1,0 to the screen memory
126+  846B             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  846B             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  846B 31 B5 80    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  846E             >        ; now we start popping the attributes off the 'stack'
126+  846E F1          >        pop af                      ; 1,0
126+  846F C1          >        pop bc                      ; 3,2
126+  8470 D1          >        pop de                      ; 5,4
126+  8471 E1          >        pop hl                      ; 7,6
126+  8472             >
126+  8472             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8472 08          >        ex af, af'                  ; swap af with af'
126+  8473 D9          >        exx
126+  8474             >
126+  8474             >        ; carry on popping
126+  8474 F1          >        pop af                      ; 9,8
126+  8475 C1          >        pop bc                      ; 11,10
126+  8476 D1          >        pop de                      ; 13,12
126+  8477 E1          >        pop hl                      ; 15,14
126+  8478             >
126+  8478             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8478             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8478 31 C0 58    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  847B             >
126+  847B             >        ; we push back onto the screen memory stack in reverse order
126+  847B E5          >        push hl                     ; copy 15,14 to the screen memory
126+  847C D5          >        push de                     ; copy 13,12 to the screen memory
126+  847D C5          >        push bc                     ; copy 11,10 to the screen memory
126+  847E F5          >        push af                     ; copy 9,8 to the screen memory
126+  847F             >
126+  847F             >        ; swap back to the original registers
126+  847F 08          >        ex af, af'
126+  8480 D9          >        exx
126+  8481             >
126+  8481 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8482 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8483 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8484 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8485             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8485             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8485 31 C5 80    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8488             >        ; now we start popping the attributes off the 'stack'
126+  8488 F1          >        pop af                      ; 1,0
126+  8489 C1          >        pop bc                      ; 3,2
126+  848A D1          >        pop de                      ; 5,4
126+  848B E1          >        pop hl                      ; 7,6
126+  848C             >
126+  848C             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  848C 08          >        ex af, af'                  ; swap af with af'
126+  848D D9          >        exx
126+  848E             >
126+  848E             >        ; carry on popping
126+  848E F1          >        pop af                      ; 9,8
126+  848F C1          >        pop bc                      ; 11,10
126+  8490 D1          >        pop de                      ; 13,12
126+  8491 E1          >        pop hl                      ; 15,14
126+  8492             >
126+  8492             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8492             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8492 31 D0 58    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8495             >
126+  8495             >        ; we push back onto the screen memory stack in reverse order
126+  8495 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8496 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8497 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8498 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8499             >
126+  8499             >        ; swap back to the original registers
126+  8499 08          >        ex af, af'
126+  849A D9          >        exx
126+  849B             >
126+  849B E5          >        push hl                     ; copy 7,6 to the screen memory
126+  849C D5          >        push de                     ; copy 5,4 to the screen memory
126+  849D C5          >        push bc                     ; copy 3,2 to the screen memory
126+  849E F5          >        push af                     ; copy 1,0 to the screen memory
126+  849F             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  849F             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  849F 31 D5 80    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  84A2             >        ; now we start popping the attributes off the 'stack'
126+  84A2 F1          >        pop af                      ; 1,0
126+  84A3 C1          >        pop bc                      ; 3,2
126+  84A4 D1          >        pop de                      ; 5,4
126+  84A5 E1          >        pop hl                      ; 7,6
126+  84A6             >
126+  84A6             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  84A6 08          >        ex af, af'                  ; swap af with af'
126+  84A7 D9          >        exx
126+  84A8             >
126+  84A8             >        ; carry on popping
126+  84A8 F1          >        pop af                      ; 9,8
126+  84A9 C1          >        pop bc                      ; 11,10
126+  84AA D1          >        pop de                      ; 13,12
126+  84AB E1          >        pop hl                      ; 15,14
126+  84AC             >
126+  84AC             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  84AC             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  84AC 31 E0 58    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  84AF             >
126+  84AF             >        ; we push back onto the screen memory stack in reverse order
126+  84AF E5          >        push hl                     ; copy 15,14 to the screen memory
126+  84B0 D5          >        push de                     ; copy 13,12 to the screen memory
126+  84B1 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  84B2 F5          >        push af                     ; copy 9,8 to the screen memory
126+  84B3             >
126+  84B3             >        ; swap back to the original registers
126+  84B3 08          >        ex af, af'
126+  84B4 D9          >        exx
126+  84B5             >
126+  84B5 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  84B6 D5          >        push de                     ; copy 5,4 to the screen memory
126+  84B7 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  84B8 F5          >        push af                     ; copy 1,0 to the screen memory
126+  84B9             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  84B9             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  84B9 31 E5 80    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  84BC             >        ; now we start popping the attributes off the 'stack'
126+  84BC F1          >        pop af                      ; 1,0
126+  84BD C1          >        pop bc                      ; 3,2
126+  84BE D1          >        pop de                      ; 5,4
126+  84BF E1          >        pop hl                      ; 7,6
126+  84C0             >
126+  84C0             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  84C0 08          >        ex af, af'                  ; swap af with af'
126+  84C1 D9          >        exx
126+  84C2             >
126+  84C2             >        ; carry on popping
126+  84C2 F1          >        pop af                      ; 9,8
126+  84C3 C1          >        pop bc                      ; 11,10
126+  84C4 D1          >        pop de                      ; 13,12
126+  84C5 E1          >        pop hl                      ; 15,14
126+  84C6             >
126+  84C6             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  84C6             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  84C6 31 F0 58    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  84C9             >
126+  84C9             >        ; we push back onto the screen memory stack in reverse order
126+  84C9 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  84CA D5          >        push de                     ; copy 13,12 to the screen memory
126+  84CB C5          >        push bc                     ; copy 11,10 to the screen memory
126+  84CC F5          >        push af                     ; copy 9,8 to the screen memory
126+  84CD             >
126+  84CD             >        ; swap back to the original registers
126+  84CD 08          >        ex af, af'
126+  84CE D9          >        exx
126+  84CF             >
126+  84CF E5          >        push hl                     ; copy 7,6 to the screen memory
126+  84D0 D5          >        push de                     ; copy 5,4 to the screen memory
126+  84D1 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  84D2 F5          >        push af                     ; copy 1,0 to the screen memory
126+  84D3             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  84D3             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  84D3 31 F5 80    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  84D6             >        ; now we start popping the attributes off the 'stack'
126+  84D6 F1          >        pop af                      ; 1,0
126+  84D7 C1          >        pop bc                      ; 3,2
126+  84D8 D1          >        pop de                      ; 5,4
126+  84D9 E1          >        pop hl                      ; 7,6
126+  84DA             >
126+  84DA             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  84DA 08          >        ex af, af'                  ; swap af with af'
126+  84DB D9          >        exx
126+  84DC             >
126+  84DC             >        ; carry on popping
126+  84DC F1          >        pop af                      ; 9,8
126+  84DD C1          >        pop bc                      ; 11,10
126+  84DE D1          >        pop de                      ; 13,12
126+  84DF E1          >        pop hl                      ; 15,14
126+  84E0             >
126+  84E0             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  84E0             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  84E0 31 00 59    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  84E3             >
126+  84E3             >        ; we push back onto the screen memory stack in reverse order
126+  84E3 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  84E4 D5          >        push de                     ; copy 13,12 to the screen memory
126+  84E5 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  84E6 F5          >        push af                     ; copy 9,8 to the screen memory
126+  84E7             >
126+  84E7             >        ; swap back to the original registers
126+  84E7 08          >        ex af, af'
126+  84E8 D9          >        exx
126+  84E9             >
126+  84E9 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  84EA D5          >        push de                     ; copy 5,4 to the screen memory
126+  84EB C5          >        push bc                     ; copy 3,2 to the screen memory
126+  84EC F5          >        push af                     ; copy 1,0 to the screen memory
126+  84ED             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  84ED             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  84ED 31 05 81    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  84F0             >        ; now we start popping the attributes off the 'stack'
126+  84F0 F1          >        pop af                      ; 1,0
126+  84F1 C1          >        pop bc                      ; 3,2
126+  84F2 D1          >        pop de                      ; 5,4
126+  84F3 E1          >        pop hl                      ; 7,6
126+  84F4             >
126+  84F4             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  84F4 08          >        ex af, af'                  ; swap af with af'
126+  84F5 D9          >        exx
126+  84F6             >
126+  84F6             >        ; carry on popping
126+  84F6 F1          >        pop af                      ; 9,8
126+  84F7 C1          >        pop bc                      ; 11,10
126+  84F8 D1          >        pop de                      ; 13,12
126+  84F9 E1          >        pop hl                      ; 15,14
126+  84FA             >
126+  84FA             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  84FA             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  84FA 31 10 59    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  84FD             >
126+  84FD             >        ; we push back onto the screen memory stack in reverse order
126+  84FD E5          >        push hl                     ; copy 15,14 to the screen memory
126+  84FE D5          >        push de                     ; copy 13,12 to the screen memory
126+  84FF C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8500 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8501             >
126+  8501             >        ; swap back to the original registers
126+  8501 08          >        ex af, af'
126+  8502 D9          >        exx
126+  8503             >
126+  8503 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8504 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8505 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8506 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8507             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  8507             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8507 31 15 81    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  850A             >        ; now we start popping the attributes off the 'stack'
126+  850A F1          >        pop af                      ; 1,0
126+  850B C1          >        pop bc                      ; 3,2
126+  850C D1          >        pop de                      ; 5,4
126+  850D E1          >        pop hl                      ; 7,6
126+  850E             >
126+  850E             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  850E 08          >        ex af, af'                  ; swap af with af'
126+  850F D9          >        exx
126+  8510             >
126+  8510             >        ; carry on popping
126+  8510 F1          >        pop af                      ; 9,8
126+  8511 C1          >        pop bc                      ; 11,10
126+  8512 D1          >        pop de                      ; 13,12
126+  8513 E1          >        pop hl                      ; 15,14
126+  8514             >
126+  8514             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8514             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8514 31 20 59    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  8517             >
126+  8517             >        ; we push back onto the screen memory stack in reverse order
126+  8517 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8518 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8519 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  851A F5          >        push af                     ; copy 9,8 to the screen memory
126+  851B             >
126+  851B             >        ; swap back to the original registers
126+  851B 08          >        ex af, af'
126+  851C D9          >        exx
126+  851D             >
126+  851D E5          >        push hl                     ; copy 7,6 to the screen memory
126+  851E D5          >        push de                     ; copy 5,4 to the screen memory
126+  851F C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8520 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8521             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8521             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8521 31 25 81    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8524             >        ; now we start popping the attributes off the 'stack'
126+  8524 F1          >        pop af                      ; 1,0
126+  8525 C1          >        pop bc                      ; 3,2
126+  8526 D1          >        pop de                      ; 5,4
126+  8527 E1          >        pop hl                      ; 7,6
126+  8528             >
126+  8528             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8528 08          >        ex af, af'                  ; swap af with af'
126+  8529 D9          >        exx
126+  852A             >
126+  852A             >        ; carry on popping
126+  852A F1          >        pop af                      ; 9,8
126+  852B C1          >        pop bc                      ; 11,10
126+  852C D1          >        pop de                      ; 13,12
126+  852D E1          >        pop hl                      ; 15,14
126+  852E             >
126+  852E             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  852E             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  852E 31 30 59    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8531             >
126+  8531             >        ; we push back onto the screen memory stack in reverse order
126+  8531 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8532 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8533 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8534 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8535             >
126+  8535             >        ; swap back to the original registers
126+  8535 08          >        ex af, af'
126+  8536 D9          >        exx
126+  8537             >
126+  8537 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8538 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8539 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  853A F5          >        push af                     ; copy 1,0 to the screen memory
126+  853B             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  853B             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  853B 31 35 81    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  853E             >        ; now we start popping the attributes off the 'stack'
126+  853E F1          >        pop af                      ; 1,0
126+  853F C1          >        pop bc                      ; 3,2
126+  8540 D1          >        pop de                      ; 5,4
126+  8541 E1          >        pop hl                      ; 7,6
126+  8542             >
126+  8542             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8542 08          >        ex af, af'                  ; swap af with af'
126+  8543 D9          >        exx
126+  8544             >
126+  8544             >        ; carry on popping
126+  8544 F1          >        pop af                      ; 9,8
126+  8545 C1          >        pop bc                      ; 11,10
126+  8546 D1          >        pop de                      ; 13,12
126+  8547 E1          >        pop hl                      ; 15,14
126+  8548             >
126+  8548             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8548             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8548 31 40 59    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  854B             >
126+  854B             >        ; we push back onto the screen memory stack in reverse order
126+  854B E5          >        push hl                     ; copy 15,14 to the screen memory
126+  854C D5          >        push de                     ; copy 13,12 to the screen memory
126+  854D C5          >        push bc                     ; copy 11,10 to the screen memory
126+  854E F5          >        push af                     ; copy 9,8 to the screen memory
126+  854F             >
126+  854F             >        ; swap back to the original registers
126+  854F 08          >        ex af, af'
126+  8550 D9          >        exx
126+  8551             >
126+  8551 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8552 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8553 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8554 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8555             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8555             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8555 31 45 81    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8558             >        ; now we start popping the attributes off the 'stack'
126+  8558 F1          >        pop af                      ; 1,0
126+  8559 C1          >        pop bc                      ; 3,2
126+  855A D1          >        pop de                      ; 5,4
126+  855B E1          >        pop hl                      ; 7,6
126+  855C             >
126+  855C             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  855C 08          >        ex af, af'                  ; swap af with af'
126+  855D D9          >        exx
126+  855E             >
126+  855E             >        ; carry on popping
126+  855E F1          >        pop af                      ; 9,8
126+  855F C1          >        pop bc                      ; 11,10
126+  8560 D1          >        pop de                      ; 13,12
126+  8561 E1          >        pop hl                      ; 15,14
126+  8562             >
126+  8562             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8562             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8562 31 50 59    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8565             >
126+  8565             >        ; we push back onto the screen memory stack in reverse order
126+  8565 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8566 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8567 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8568 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8569             >
126+  8569             >        ; swap back to the original registers
126+  8569 08          >        ex af, af'
126+  856A D9          >        exx
126+  856B             >
126+  856B E5          >        push hl                     ; copy 7,6 to the screen memory
126+  856C D5          >        push de                     ; copy 5,4 to the screen memory
126+  856D C5          >        push bc                     ; copy 3,2 to the screen memory
126+  856E F5          >        push af                     ; copy 1,0 to the screen memory
126+  856F             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  856F             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  856F 31 55 81    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  8572             >        ; now we start popping the attributes off the 'stack'
126+  8572 F1          >        pop af                      ; 1,0
126+  8573 C1          >        pop bc                      ; 3,2
126+  8574 D1          >        pop de                      ; 5,4
126+  8575 E1          >        pop hl                      ; 7,6
126+  8576             >
126+  8576             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8576 08          >        ex af, af'                  ; swap af with af'
126+  8577 D9          >        exx
126+  8578             >
126+  8578             >        ; carry on popping
126+  8578 F1          >        pop af                      ; 9,8
126+  8579 C1          >        pop bc                      ; 11,10
126+  857A D1          >        pop de                      ; 13,12
126+  857B E1          >        pop hl                      ; 15,14
126+  857C             >
126+  857C             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  857C             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  857C 31 60 59    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  857F             >
126+  857F             >        ; we push back onto the screen memory stack in reverse order
126+  857F E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8580 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8581 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8582 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8583             >
126+  8583             >        ; swap back to the original registers
126+  8583 08          >        ex af, af'
126+  8584 D9          >        exx
126+  8585             >
126+  8585 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8586 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8587 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8588 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8589             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8589             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8589 31 65 81    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  858C             >        ; now we start popping the attributes off the 'stack'
126+  858C F1          >        pop af                      ; 1,0
126+  858D C1          >        pop bc                      ; 3,2
126+  858E D1          >        pop de                      ; 5,4
126+  858F E1          >        pop hl                      ; 7,6
126+  8590             >
126+  8590             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8590 08          >        ex af, af'                  ; swap af with af'
126+  8591 D9          >        exx
126+  8592             >
126+  8592             >        ; carry on popping
126+  8592 F1          >        pop af                      ; 9,8
126+  8593 C1          >        pop bc                      ; 11,10
126+  8594 D1          >        pop de                      ; 13,12
126+  8595 E1          >        pop hl                      ; 15,14
126+  8596             >
126+  8596             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8596             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8596 31 70 59    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8599             >
126+  8599             >        ; we push back onto the screen memory stack in reverse order
126+  8599 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  859A D5          >        push de                     ; copy 13,12 to the screen memory
126+  859B C5          >        push bc                     ; copy 11,10 to the screen memory
126+  859C F5          >        push af                     ; copy 9,8 to the screen memory
126+  859D             >
126+  859D             >        ; swap back to the original registers
126+  859D 08          >        ex af, af'
126+  859E D9          >        exx
126+  859F             >
126+  859F E5          >        push hl                     ; copy 7,6 to the screen memory
126+  85A0 D5          >        push de                     ; copy 5,4 to the screen memory
126+  85A1 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  85A2 F5          >        push af                     ; copy 1,0 to the screen memory
126+  85A3             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  85A3             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  85A3 31 75 81    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  85A6             >        ; now we start popping the attributes off the 'stack'
126+  85A6 F1          >        pop af                      ; 1,0
126+  85A7 C1          >        pop bc                      ; 3,2
126+  85A8 D1          >        pop de                      ; 5,4
126+  85A9 E1          >        pop hl                      ; 7,6
126+  85AA             >
126+  85AA             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  85AA 08          >        ex af, af'                  ; swap af with af'
126+  85AB D9          >        exx
126+  85AC             >
126+  85AC             >        ; carry on popping
126+  85AC F1          >        pop af                      ; 9,8
126+  85AD C1          >        pop bc                      ; 11,10
126+  85AE D1          >        pop de                      ; 13,12
126+  85AF E1          >        pop hl                      ; 15,14
126+  85B0             >
126+  85B0             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  85B0             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  85B0 31 80 59    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  85B3             >
126+  85B3             >        ; we push back onto the screen memory stack in reverse order
126+  85B3 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  85B4 D5          >        push de                     ; copy 13,12 to the screen memory
126+  85B5 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  85B6 F5          >        push af                     ; copy 9,8 to the screen memory
126+  85B7             >
126+  85B7             >        ; swap back to the original registers
126+  85B7 08          >        ex af, af'
126+  85B8 D9          >        exx
126+  85B9             >
126+  85B9 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  85BA D5          >        push de                     ; copy 5,4 to the screen memory
126+  85BB C5          >        push bc                     ; copy 3,2 to the screen memory
126+  85BC F5          >        push af                     ; copy 1,0 to the screen memory
126+  85BD             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  85BD             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  85BD 31 85 81    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  85C0             >        ; now we start popping the attributes off the 'stack'
126+  85C0 F1          >        pop af                      ; 1,0
126+  85C1 C1          >        pop bc                      ; 3,2
126+  85C2 D1          >        pop de                      ; 5,4
126+  85C3 E1          >        pop hl                      ; 7,6
126+  85C4             >
126+  85C4             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  85C4 08          >        ex af, af'                  ; swap af with af'
126+  85C5 D9          >        exx
126+  85C6             >
126+  85C6             >        ; carry on popping
126+  85C6 F1          >        pop af                      ; 9,8
126+  85C7 C1          >        pop bc                      ; 11,10
126+  85C8 D1          >        pop de                      ; 13,12
126+  85C9 E1          >        pop hl                      ; 15,14
126+  85CA             >
126+  85CA             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  85CA             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  85CA 31 90 59    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  85CD             >
126+  85CD             >        ; we push back onto the screen memory stack in reverse order
126+  85CD E5          >        push hl                     ; copy 15,14 to the screen memory
126+  85CE D5          >        push de                     ; copy 13,12 to the screen memory
126+  85CF C5          >        push bc                     ; copy 11,10 to the screen memory
126+  85D0 F5          >        push af                     ; copy 9,8 to the screen memory
126+  85D1             >
126+  85D1             >        ; swap back to the original registers
126+  85D1 08          >        ex af, af'
126+  85D2 D9          >        exx
126+  85D3             >
126+  85D3 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  85D4 D5          >        push de                     ; copy 5,4 to the screen memory
126+  85D5 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  85D6 F5          >        push af                     ; copy 1,0 to the screen memory
126+  85D7             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  85D7             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  85D7 31 95 81    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  85DA             >        ; now we start popping the attributes off the 'stack'
126+  85DA F1          >        pop af                      ; 1,0
126+  85DB C1          >        pop bc                      ; 3,2
126+  85DC D1          >        pop de                      ; 5,4
126+  85DD E1          >        pop hl                      ; 7,6
126+  85DE             >
126+  85DE             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  85DE 08          >        ex af, af'                  ; swap af with af'
126+  85DF D9          >        exx
126+  85E0             >
126+  85E0             >        ; carry on popping
126+  85E0 F1          >        pop af                      ; 9,8
126+  85E1 C1          >        pop bc                      ; 11,10
126+  85E2 D1          >        pop de                      ; 13,12
126+  85E3 E1          >        pop hl                      ; 15,14
126+  85E4             >
126+  85E4             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  85E4             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  85E4 31 A0 59    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  85E7             >
126+  85E7             >        ; we push back onto the screen memory stack in reverse order
126+  85E7 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  85E8 D5          >        push de                     ; copy 13,12 to the screen memory
126+  85E9 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  85EA F5          >        push af                     ; copy 9,8 to the screen memory
126+  85EB             >
126+  85EB             >        ; swap back to the original registers
126+  85EB 08          >        ex af, af'
126+  85EC D9          >        exx
126+  85ED             >
126+  85ED E5          >        push hl                     ; copy 7,6 to the screen memory
126+  85EE D5          >        push de                     ; copy 5,4 to the screen memory
126+  85EF C5          >        push bc                     ; copy 3,2 to the screen memory
126+  85F0 F5          >        push af                     ; copy 1,0 to the screen memory
126+  85F1             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  85F1             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  85F1 31 A5 81    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  85F4             >        ; now we start popping the attributes off the 'stack'
126+  85F4 F1          >        pop af                      ; 1,0
126+  85F5 C1          >        pop bc                      ; 3,2
126+  85F6 D1          >        pop de                      ; 5,4
126+  85F7 E1          >        pop hl                      ; 7,6
126+  85F8             >
126+  85F8             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  85F8 08          >        ex af, af'                  ; swap af with af'
126+  85F9 D9          >        exx
126+  85FA             >
126+  85FA             >        ; carry on popping
126+  85FA F1          >        pop af                      ; 9,8
126+  85FB C1          >        pop bc                      ; 11,10
126+  85FC D1          >        pop de                      ; 13,12
126+  85FD E1          >        pop hl                      ; 15,14
126+  85FE             >
126+  85FE             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  85FE             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  85FE 31 B0 59    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8601             >
126+  8601             >        ; we push back onto the screen memory stack in reverse order
126+  8601 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8602 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8603 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8604 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8605             >
126+  8605             >        ; swap back to the original registers
126+  8605 08          >        ex af, af'
126+  8606 D9          >        exx
126+  8607             >
126+  8607 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8608 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8609 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  860A F5          >        push af                     ; copy 1,0 to the screen memory
126+  860B             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  860B             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  860B 31 B5 81    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  860E             >        ; now we start popping the attributes off the 'stack'
126+  860E F1          >        pop af                      ; 1,0
126+  860F C1          >        pop bc                      ; 3,2
126+  8610 D1          >        pop de                      ; 5,4
126+  8611 E1          >        pop hl                      ; 7,6
126+  8612             >
126+  8612             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8612 08          >        ex af, af'                  ; swap af with af'
126+  8613 D9          >        exx
126+  8614             >
126+  8614             >        ; carry on popping
126+  8614 F1          >        pop af                      ; 9,8
126+  8615 C1          >        pop bc                      ; 11,10
126+  8616 D1          >        pop de                      ; 13,12
126+  8617 E1          >        pop hl                      ; 15,14
126+  8618             >
126+  8618             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8618             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8618 31 C0 59    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  861B             >
126+  861B             >        ; we push back onto the screen memory stack in reverse order
126+  861B E5          >        push hl                     ; copy 15,14 to the screen memory
126+  861C D5          >        push de                     ; copy 13,12 to the screen memory
126+  861D C5          >        push bc                     ; copy 11,10 to the screen memory
126+  861E F5          >        push af                     ; copy 9,8 to the screen memory
126+  861F             >
126+  861F             >        ; swap back to the original registers
126+  861F 08          >        ex af, af'
126+  8620 D9          >        exx
126+  8621             >
126+  8621 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8622 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8623 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8624 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8625             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8625             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8625 31 C5 81    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8628             >        ; now we start popping the attributes off the 'stack'
126+  8628 F1          >        pop af                      ; 1,0
126+  8629 C1          >        pop bc                      ; 3,2
126+  862A D1          >        pop de                      ; 5,4
126+  862B E1          >        pop hl                      ; 7,6
126+  862C             >
126+  862C             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  862C 08          >        ex af, af'                  ; swap af with af'
126+  862D D9          >        exx
126+  862E             >
126+  862E             >        ; carry on popping
126+  862E F1          >        pop af                      ; 9,8
126+  862F C1          >        pop bc                      ; 11,10
126+  8630 D1          >        pop de                      ; 13,12
126+  8631 E1          >        pop hl                      ; 15,14
126+  8632             >
126+  8632             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8632             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8632 31 D0 59    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8635             >
126+  8635             >        ; we push back onto the screen memory stack in reverse order
126+  8635 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8636 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8637 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8638 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8639             >
126+  8639             >        ; swap back to the original registers
126+  8639 08          >        ex af, af'
126+  863A D9          >        exx
126+  863B             >
126+  863B E5          >        push hl                     ; copy 7,6 to the screen memory
126+  863C D5          >        push de                     ; copy 5,4 to the screen memory
126+  863D C5          >        push bc                     ; copy 3,2 to the screen memory
126+  863E F5          >        push af                     ; copy 1,0 to the screen memory
126+  863F             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  863F             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  863F 31 D5 81    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  8642             >        ; now we start popping the attributes off the 'stack'
126+  8642 F1          >        pop af                      ; 1,0
126+  8643 C1          >        pop bc                      ; 3,2
126+  8644 D1          >        pop de                      ; 5,4
126+  8645 E1          >        pop hl                      ; 7,6
126+  8646             >
126+  8646             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8646 08          >        ex af, af'                  ; swap af with af'
126+  8647 D9          >        exx
126+  8648             >
126+  8648             >        ; carry on popping
126+  8648 F1          >        pop af                      ; 9,8
126+  8649 C1          >        pop bc                      ; 11,10
126+  864A D1          >        pop de                      ; 13,12
126+  864B E1          >        pop hl                      ; 15,14
126+  864C             >
126+  864C             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  864C             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  864C 31 E0 59    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  864F             >
126+  864F             >        ; we push back onto the screen memory stack in reverse order
126+  864F E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8650 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8651 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8652 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8653             >
126+  8653             >        ; swap back to the original registers
126+  8653 08          >        ex af, af'
126+  8654 D9          >        exx
126+  8655             >
126+  8655 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8656 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8657 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8658 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8659             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8659             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8659 31 E5 81    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  865C             >        ; now we start popping the attributes off the 'stack'
126+  865C F1          >        pop af                      ; 1,0
126+  865D C1          >        pop bc                      ; 3,2
126+  865E D1          >        pop de                      ; 5,4
126+  865F E1          >        pop hl                      ; 7,6
126+  8660             >
126+  8660             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8660 08          >        ex af, af'                  ; swap af with af'
126+  8661 D9          >        exx
126+  8662             >
126+  8662             >        ; carry on popping
126+  8662 F1          >        pop af                      ; 9,8
126+  8663 C1          >        pop bc                      ; 11,10
126+  8664 D1          >        pop de                      ; 13,12
126+  8665 E1          >        pop hl                      ; 15,14
126+  8666             >
126+  8666             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8666             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8666 31 F0 59    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8669             >
126+  8669             >        ; we push back onto the screen memory stack in reverse order
126+  8669 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  866A D5          >        push de                     ; copy 13,12 to the screen memory
126+  866B C5          >        push bc                     ; copy 11,10 to the screen memory
126+  866C F5          >        push af                     ; copy 9,8 to the screen memory
126+  866D             >
126+  866D             >        ; swap back to the original registers
126+  866D 08          >        ex af, af'
126+  866E D9          >        exx
126+  866F             >
126+  866F E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8670 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8671 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8672 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8673             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  8673             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8673 31 F5 81    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  8676             >        ; now we start popping the attributes off the 'stack'
126+  8676 F1          >        pop af                      ; 1,0
126+  8677 C1          >        pop bc                      ; 3,2
126+  8678 D1          >        pop de                      ; 5,4
126+  8679 E1          >        pop hl                      ; 7,6
126+  867A             >
126+  867A             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  867A 08          >        ex af, af'                  ; swap af with af'
126+  867B D9          >        exx
126+  867C             >
126+  867C             >        ; carry on popping
126+  867C F1          >        pop af                      ; 9,8
126+  867D C1          >        pop bc                      ; 11,10
126+  867E D1          >        pop de                      ; 13,12
126+  867F E1          >        pop hl                      ; 15,14
126+  8680             >
126+  8680             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8680             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8680 31 00 5A    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  8683             >
126+  8683             >        ; we push back onto the screen memory stack in reverse order
126+  8683 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8684 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8685 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8686 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8687             >
126+  8687             >        ; swap back to the original registers
126+  8687 08          >        ex af, af'
126+  8688 D9          >        exx
126+  8689             >
126+  8689 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  868A D5          >        push de                     ; copy 5,4 to the screen memory
126+  868B C5          >        push bc                     ; copy 3,2 to the screen memory
126+  868C F5          >        push af                     ; copy 1,0 to the screen memory
126+  868D             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  868D             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  868D 31 05 82    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8690             >        ; now we start popping the attributes off the 'stack'
126+  8690 F1          >        pop af                      ; 1,0
126+  8691 C1          >        pop bc                      ; 3,2
126+  8692 D1          >        pop de                      ; 5,4
126+  8693 E1          >        pop hl                      ; 7,6
126+  8694             >
126+  8694             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8694 08          >        ex af, af'                  ; swap af with af'
126+  8695 D9          >        exx
126+  8696             >
126+  8696             >        ; carry on popping
126+  8696 F1          >        pop af                      ; 9,8
126+  8697 C1          >        pop bc                      ; 11,10
126+  8698 D1          >        pop de                      ; 13,12
126+  8699 E1          >        pop hl                      ; 15,14
126+  869A             >
126+  869A             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  869A             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  869A 31 10 5A    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  869D             >
126+  869D             >        ; we push back onto the screen memory stack in reverse order
126+  869D E5          >        push hl                     ; copy 15,14 to the screen memory
126+  869E D5          >        push de                     ; copy 13,12 to the screen memory
126+  869F C5          >        push bc                     ; copy 11,10 to the screen memory
126+  86A0 F5          >        push af                     ; copy 9,8 to the screen memory
126+  86A1             >
126+  86A1             >        ; swap back to the original registers
126+  86A1 08          >        ex af, af'
126+  86A2 D9          >        exx
126+  86A3             >
126+  86A3 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  86A4 D5          >        push de                     ; copy 5,4 to the screen memory
126+  86A5 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  86A6 F5          >        push af                     ; copy 1,0 to the screen memory
126+  86A7             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  86A7             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  86A7 31 15 82    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  86AA             >        ; now we start popping the attributes off the 'stack'
126+  86AA F1          >        pop af                      ; 1,0
126+  86AB C1          >        pop bc                      ; 3,2
126+  86AC D1          >        pop de                      ; 5,4
126+  86AD E1          >        pop hl                      ; 7,6
126+  86AE             >
126+  86AE             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  86AE 08          >        ex af, af'                  ; swap af with af'
126+  86AF D9          >        exx
126+  86B0             >
126+  86B0             >        ; carry on popping
126+  86B0 F1          >        pop af                      ; 9,8
126+  86B1 C1          >        pop bc                      ; 11,10
126+  86B2 D1          >        pop de                      ; 13,12
126+  86B3 E1          >        pop hl                      ; 15,14
126+  86B4             >
126+  86B4             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  86B4             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  86B4 31 20 5A    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  86B7             >
126+  86B7             >        ; we push back onto the screen memory stack in reverse order
126+  86B7 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  86B8 D5          >        push de                     ; copy 13,12 to the screen memory
126+  86B9 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  86BA F5          >        push af                     ; copy 9,8 to the screen memory
126+  86BB             >
126+  86BB             >        ; swap back to the original registers
126+  86BB 08          >        ex af, af'
126+  86BC D9          >        exx
126+  86BD             >
126+  86BD E5          >        push hl                     ; copy 7,6 to the screen memory
126+  86BE D5          >        push de                     ; copy 5,4 to the screen memory
126+  86BF C5          >        push bc                     ; copy 3,2 to the screen memory
126+  86C0 F5          >        push af                     ; copy 1,0 to the screen memory
126+  86C1             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  86C1             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  86C1 31 25 82    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  86C4             >        ; now we start popping the attributes off the 'stack'
126+  86C4 F1          >        pop af                      ; 1,0
126+  86C5 C1          >        pop bc                      ; 3,2
126+  86C6 D1          >        pop de                      ; 5,4
126+  86C7 E1          >        pop hl                      ; 7,6
126+  86C8             >
126+  86C8             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  86C8 08          >        ex af, af'                  ; swap af with af'
126+  86C9 D9          >        exx
126+  86CA             >
126+  86CA             >        ; carry on popping
126+  86CA F1          >        pop af                      ; 9,8
126+  86CB C1          >        pop bc                      ; 11,10
126+  86CC D1          >        pop de                      ; 13,12
126+  86CD E1          >        pop hl                      ; 15,14
126+  86CE             >
126+  86CE             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  86CE             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  86CE 31 30 5A    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  86D1             >
126+  86D1             >        ; we push back onto the screen memory stack in reverse order
126+  86D1 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  86D2 D5          >        push de                     ; copy 13,12 to the screen memory
126+  86D3 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  86D4 F5          >        push af                     ; copy 9,8 to the screen memory
126+  86D5             >
126+  86D5             >        ; swap back to the original registers
126+  86D5 08          >        ex af, af'
126+  86D6 D9          >        exx
126+  86D7             >
126+  86D7 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  86D8 D5          >        push de                     ; copy 5,4 to the screen memory
126+  86D9 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  86DA F5          >        push af                     ; copy 1,0 to the screen memory
126+  86DB             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  86DB             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  86DB 31 35 82    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  86DE             >        ; now we start popping the attributes off the 'stack'
126+  86DE F1          >        pop af                      ; 1,0
126+  86DF C1          >        pop bc                      ; 3,2
126+  86E0 D1          >        pop de                      ; 5,4
126+  86E1 E1          >        pop hl                      ; 7,6
126+  86E2             >
126+  86E2             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  86E2 08          >        ex af, af'                  ; swap af with af'
126+  86E3 D9          >        exx
126+  86E4             >
126+  86E4             >        ; carry on popping
126+  86E4 F1          >        pop af                      ; 9,8
126+  86E5 C1          >        pop bc                      ; 11,10
126+  86E6 D1          >        pop de                      ; 13,12
126+  86E7 E1          >        pop hl                      ; 15,14
126+  86E8             >
126+  86E8             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  86E8             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  86E8 31 40 5A    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  86EB             >
126+  86EB             >        ; we push back onto the screen memory stack in reverse order
126+  86EB E5          >        push hl                     ; copy 15,14 to the screen memory
126+  86EC D5          >        push de                     ; copy 13,12 to the screen memory
126+  86ED C5          >        push bc                     ; copy 11,10 to the screen memory
126+  86EE F5          >        push af                     ; copy 9,8 to the screen memory
126+  86EF             >
126+  86EF             >        ; swap back to the original registers
126+  86EF 08          >        ex af, af'
126+  86F0 D9          >        exx
126+  86F1             >
126+  86F1 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  86F2 D5          >        push de                     ; copy 5,4 to the screen memory
126+  86F3 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  86F4 F5          >        push af                     ; copy 1,0 to the screen memory
126+  86F5             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  86F5             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  86F5 31 45 82    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  86F8             >        ; now we start popping the attributes off the 'stack'
126+  86F8 F1          >        pop af                      ; 1,0
126+  86F9 C1          >        pop bc                      ; 3,2
126+  86FA D1          >        pop de                      ; 5,4
126+  86FB E1          >        pop hl                      ; 7,6
126+  86FC             >
126+  86FC             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  86FC 08          >        ex af, af'                  ; swap af with af'
126+  86FD D9          >        exx
126+  86FE             >
126+  86FE             >        ; carry on popping
126+  86FE F1          >        pop af                      ; 9,8
126+  86FF C1          >        pop bc                      ; 11,10
126+  8700 D1          >        pop de                      ; 13,12
126+  8701 E1          >        pop hl                      ; 15,14
126+  8702             >
126+  8702             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8702             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8702 31 50 5A    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8705             >
126+  8705             >        ; we push back onto the screen memory stack in reverse order
126+  8705 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8706 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8707 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8708 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8709             >
126+  8709             >        ; swap back to the original registers
126+  8709 08          >        ex af, af'
126+  870A D9          >        exx
126+  870B             >
126+  870B E5          >        push hl                     ; copy 7,6 to the screen memory
126+  870C D5          >        push de                     ; copy 5,4 to the screen memory
126+  870D C5          >        push bc                     ; copy 3,2 to the screen memory
126+  870E F5          >        push af                     ; copy 1,0 to the screen memory
126+  870F             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  870F             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  870F 31 55 82    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  8712             >        ; now we start popping the attributes off the 'stack'
126+  8712 F1          >        pop af                      ; 1,0
126+  8713 C1          >        pop bc                      ; 3,2
126+  8714 D1          >        pop de                      ; 5,4
126+  8715 E1          >        pop hl                      ; 7,6
126+  8716             >
126+  8716             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8716 08          >        ex af, af'                  ; swap af with af'
126+  8717 D9          >        exx
126+  8718             >
126+  8718             >        ; carry on popping
126+  8718 F1          >        pop af                      ; 9,8
126+  8719 C1          >        pop bc                      ; 11,10
126+  871A D1          >        pop de                      ; 13,12
126+  871B E1          >        pop hl                      ; 15,14
126+  871C             >
126+  871C             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  871C             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  871C 31 60 5A    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  871F             >
126+  871F             >        ; we push back onto the screen memory stack in reverse order
126+  871F E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8720 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8721 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8722 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8723             >
126+  8723             >        ; swap back to the original registers
126+  8723 08          >        ex af, af'
126+  8724 D9          >        exx
126+  8725             >
126+  8725 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8726 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8727 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8728 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8729             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8729             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8729 31 65 82    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  872C             >        ; now we start popping the attributes off the 'stack'
126+  872C F1          >        pop af                      ; 1,0
126+  872D C1          >        pop bc                      ; 3,2
126+  872E D1          >        pop de                      ; 5,4
126+  872F E1          >        pop hl                      ; 7,6
126+  8730             >
126+  8730             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8730 08          >        ex af, af'                  ; swap af with af'
126+  8731 D9          >        exx
126+  8732             >
126+  8732             >        ; carry on popping
126+  8732 F1          >        pop af                      ; 9,8
126+  8733 C1          >        pop bc                      ; 11,10
126+  8734 D1          >        pop de                      ; 13,12
126+  8735 E1          >        pop hl                      ; 15,14
126+  8736             >
126+  8736             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8736             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8736 31 70 5A    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8739             >
126+  8739             >        ; we push back onto the screen memory stack in reverse order
126+  8739 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  873A D5          >        push de                     ; copy 13,12 to the screen memory
126+  873B C5          >        push bc                     ; copy 11,10 to the screen memory
126+  873C F5          >        push af                     ; copy 9,8 to the screen memory
126+  873D             >
126+  873D             >        ; swap back to the original registers
126+  873D 08          >        ex af, af'
126+  873E D9          >        exx
126+  873F             >
126+  873F E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8740 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8741 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8742 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8743             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  8743             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8743 31 75 82    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  8746             >        ; now we start popping the attributes off the 'stack'
126+  8746 F1          >        pop af                      ; 1,0
126+  8747 C1          >        pop bc                      ; 3,2
126+  8748 D1          >        pop de                      ; 5,4
126+  8749 E1          >        pop hl                      ; 7,6
126+  874A             >
126+  874A             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  874A 08          >        ex af, af'                  ; swap af with af'
126+  874B D9          >        exx
126+  874C             >
126+  874C             >        ; carry on popping
126+  874C F1          >        pop af                      ; 9,8
126+  874D C1          >        pop bc                      ; 11,10
126+  874E D1          >        pop de                      ; 13,12
126+  874F E1          >        pop hl                      ; 15,14
126+  8750             >
126+  8750             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8750             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8750 31 80 5A    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  8753             >
126+  8753             >        ; we push back onto the screen memory stack in reverse order
126+  8753 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8754 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8755 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8756 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8757             >
126+  8757             >        ; swap back to the original registers
126+  8757 08          >        ex af, af'
126+  8758 D9          >        exx
126+  8759             >
126+  8759 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  875A D5          >        push de                     ; copy 5,4 to the screen memory
126+  875B C5          >        push bc                     ; copy 3,2 to the screen memory
126+  875C F5          >        push af                     ; copy 1,0 to the screen memory
126+  875D             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  875D             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  875D 31 85 82    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8760             >        ; now we start popping the attributes off the 'stack'
126+  8760 F1          >        pop af                      ; 1,0
126+  8761 C1          >        pop bc                      ; 3,2
126+  8762 D1          >        pop de                      ; 5,4
126+  8763 E1          >        pop hl                      ; 7,6
126+  8764             >
126+  8764             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8764 08          >        ex af, af'                  ; swap af with af'
126+  8765 D9          >        exx
126+  8766             >
126+  8766             >        ; carry on popping
126+  8766 F1          >        pop af                      ; 9,8
126+  8767 C1          >        pop bc                      ; 11,10
126+  8768 D1          >        pop de                      ; 13,12
126+  8769 E1          >        pop hl                      ; 15,14
126+  876A             >
126+  876A             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  876A             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  876A 31 90 5A    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  876D             >
126+  876D             >        ; we push back onto the screen memory stack in reverse order
126+  876D E5          >        push hl                     ; copy 15,14 to the screen memory
126+  876E D5          >        push de                     ; copy 13,12 to the screen memory
126+  876F C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8770 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8771             >
126+  8771             >        ; swap back to the original registers
126+  8771 08          >        ex af, af'
126+  8772 D9          >        exx
126+  8773             >
126+  8773 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8774 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8775 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8776 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8777             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  8777             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8777 31 95 82    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  877A             >        ; now we start popping the attributes off the 'stack'
126+  877A F1          >        pop af                      ; 1,0
126+  877B C1          >        pop bc                      ; 3,2
126+  877C D1          >        pop de                      ; 5,4
126+  877D E1          >        pop hl                      ; 7,6
126+  877E             >
126+  877E             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  877E 08          >        ex af, af'                  ; swap af with af'
126+  877F D9          >        exx
126+  8780             >
126+  8780             >        ; carry on popping
126+  8780 F1          >        pop af                      ; 9,8
126+  8781 C1          >        pop bc                      ; 11,10
126+  8782 D1          >        pop de                      ; 13,12
126+  8783 E1          >        pop hl                      ; 15,14
126+  8784             >
126+  8784             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8784             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8784 31 A0 5A    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  8787             >
126+  8787             >        ; we push back onto the screen memory stack in reverse order
126+  8787 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8788 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8789 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  878A F5          >        push af                     ; copy 9,8 to the screen memory
126+  878B             >
126+  878B             >        ; swap back to the original registers
126+  878B 08          >        ex af, af'
126+  878C D9          >        exx
126+  878D             >
126+  878D E5          >        push hl                     ; copy 7,6 to the screen memory
126+  878E D5          >        push de                     ; copy 5,4 to the screen memory
126+  878F C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8790 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8791             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  8791             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8791 31 A5 82    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  8794             >        ; now we start popping the attributes off the 'stack'
126+  8794 F1          >        pop af                      ; 1,0
126+  8795 C1          >        pop bc                      ; 3,2
126+  8796 D1          >        pop de                      ; 5,4
126+  8797 E1          >        pop hl                      ; 7,6
126+  8798             >
126+  8798             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8798 08          >        ex af, af'                  ; swap af with af'
126+  8799 D9          >        exx
126+  879A             >
126+  879A             >        ; carry on popping
126+  879A F1          >        pop af                      ; 9,8
126+  879B C1          >        pop bc                      ; 11,10
126+  879C D1          >        pop de                      ; 13,12
126+  879D E1          >        pop hl                      ; 15,14
126+  879E             >
126+  879E             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  879E             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  879E 31 B0 5A    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  87A1             >
126+  87A1             >        ; we push back onto the screen memory stack in reverse order
126+  87A1 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  87A2 D5          >        push de                     ; copy 13,12 to the screen memory
126+  87A3 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  87A4 F5          >        push af                     ; copy 9,8 to the screen memory
126+  87A5             >
126+  87A5             >        ; swap back to the original registers
126+  87A5 08          >        ex af, af'
126+  87A6 D9          >        exx
126+  87A7             >
126+  87A7 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  87A8 D5          >        push de                     ; copy 5,4 to the screen memory
126+  87A9 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  87AA F5          >        push af                     ; copy 1,0 to the screen memory
126+  87AB             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  87AB             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  87AB 31 B5 82    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  87AE             >        ; now we start popping the attributes off the 'stack'
126+  87AE F1          >        pop af                      ; 1,0
126+  87AF C1          >        pop bc                      ; 3,2
126+  87B0 D1          >        pop de                      ; 5,4
126+  87B1 E1          >        pop hl                      ; 7,6
126+  87B2             >
126+  87B2             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  87B2 08          >        ex af, af'                  ; swap af with af'
126+  87B3 D9          >        exx
126+  87B4             >
126+  87B4             >        ; carry on popping
126+  87B4 F1          >        pop af                      ; 9,8
126+  87B5 C1          >        pop bc                      ; 11,10
126+  87B6 D1          >        pop de                      ; 13,12
126+  87B7 E1          >        pop hl                      ; 15,14
126+  87B8             >
126+  87B8             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  87B8             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  87B8 31 C0 5A    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  87BB             >
126+  87BB             >        ; we push back onto the screen memory stack in reverse order
126+  87BB E5          >        push hl                     ; copy 15,14 to the screen memory
126+  87BC D5          >        push de                     ; copy 13,12 to the screen memory
126+  87BD C5          >        push bc                     ; copy 11,10 to the screen memory
126+  87BE F5          >        push af                     ; copy 9,8 to the screen memory
126+  87BF             >
126+  87BF             >        ; swap back to the original registers
126+  87BF 08          >        ex af, af'
126+  87C0 D9          >        exx
126+  87C1             >
126+  87C1 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  87C2 D5          >        push de                     ; copy 5,4 to the screen memory
126+  87C3 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  87C4 F5          >        push af                     ; copy 1,0 to the screen memory
126+  87C5             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  87C5             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  87C5 31 C5 82    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  87C8             >        ; now we start popping the attributes off the 'stack'
126+  87C8 F1          >        pop af                      ; 1,0
126+  87C9 C1          >        pop bc                      ; 3,2
126+  87CA D1          >        pop de                      ; 5,4
126+  87CB E1          >        pop hl                      ; 7,6
126+  87CC             >
126+  87CC             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  87CC 08          >        ex af, af'                  ; swap af with af'
126+  87CD D9          >        exx
126+  87CE             >
126+  87CE             >        ; carry on popping
126+  87CE F1          >        pop af                      ; 9,8
126+  87CF C1          >        pop bc                      ; 11,10
126+  87D0 D1          >        pop de                      ; 13,12
126+  87D1 E1          >        pop hl                      ; 15,14
126+  87D2             >
126+  87D2             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  87D2             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  87D2 31 D0 5A    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  87D5             >
126+  87D5             >        ; we push back onto the screen memory stack in reverse order
126+  87D5 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  87D6 D5          >        push de                     ; copy 13,12 to the screen memory
126+  87D7 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  87D8 F5          >        push af                     ; copy 9,8 to the screen memory
126+  87D9             >
126+  87D9             >        ; swap back to the original registers
126+  87D9 08          >        ex af, af'
126+  87DA D9          >        exx
126+  87DB             >
126+  87DB E5          >        push hl                     ; copy 7,6 to the screen memory
126+  87DC D5          >        push de                     ; copy 5,4 to the screen memory
126+  87DD C5          >        push bc                     ; copy 3,2 to the screen memory
126+  87DE F5          >        push af                     ; copy 1,0 to the screen memory
126+  87DF             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  87DF             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  87DF 31 D5 82    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  87E2             >        ; now we start popping the attributes off the 'stack'
126+  87E2 F1          >        pop af                      ; 1,0
126+  87E3 C1          >        pop bc                      ; 3,2
126+  87E4 D1          >        pop de                      ; 5,4
126+  87E5 E1          >        pop hl                      ; 7,6
126+  87E6             >
126+  87E6             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  87E6 08          >        ex af, af'                  ; swap af with af'
126+  87E7 D9          >        exx
126+  87E8             >
126+  87E8             >        ; carry on popping
126+  87E8 F1          >        pop af                      ; 9,8
126+  87E9 C1          >        pop bc                      ; 11,10
126+  87EA D1          >        pop de                      ; 13,12
126+  87EB E1          >        pop hl                      ; 15,14
126+  87EC             >
126+  87EC             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  87EC             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  87EC 31 E0 5A    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  87EF             >
126+  87EF             >        ; we push back onto the screen memory stack in reverse order
126+  87EF E5          >        push hl                     ; copy 15,14 to the screen memory
126+  87F0 D5          >        push de                     ; copy 13,12 to the screen memory
126+  87F1 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  87F2 F5          >        push af                     ; copy 9,8 to the screen memory
126+  87F3             >
126+  87F3             >        ; swap back to the original registers
126+  87F3 08          >        ex af, af'
126+  87F4 D9          >        exx
126+  87F5             >
126+  87F5 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  87F6 D5          >        push de                     ; copy 5,4 to the screen memory
126+  87F7 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  87F8 F5          >        push af                     ; copy 1,0 to the screen memory
126+  87F9             >            DoCopy i, 0   ; copy the first 16 attributes over to the row
126+  87F9             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  87F9 31 E5 82    >        ld sp, AttributeBuffer + (i * 32) + 0
126+  87FC             >        ; now we start popping the attributes off the 'stack'
126+  87FC F1          >        pop af                      ; 1,0
126+  87FD C1          >        pop bc                      ; 3,2
126+  87FE D1          >        pop de                      ; 5,4
126+  87FF E1          >        pop hl                      ; 7,6
126+  8800             >
126+  8800             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  8800 08          >        ex af, af'                  ; swap af with af'
126+  8801 D9          >        exx
126+  8802             >
126+  8802             >        ; carry on popping
126+  8802 F1          >        pop af                      ; 9,8
126+  8803 C1          >        pop bc                      ; 11,10
126+  8804 D1          >        pop de                      ; 13,12
126+  8805 E1          >        pop hl                      ; 15,14
126+  8806             >
126+  8806             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8806             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8806 31 F0 5A    >        ld sp, $5800 + (i * 32) + 0 + 16
126+  8809             >
126+  8809             >        ; we push back onto the screen memory stack in reverse order
126+  8809 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  880A D5          >        push de                     ; copy 13,12 to the screen memory
126+  880B C5          >        push bc                     ; copy 11,10 to the screen memory
126+  880C F5          >        push af                     ; copy 9,8 to the screen memory
126+  880D             >
126+  880D             >        ; swap back to the original registers
126+  880D 08          >        ex af, af'
126+  880E D9          >        exx
126+  880F             >
126+  880F E5          >        push hl                     ; copy 7,6 to the screen memory
126+  8810 D5          >        push de                     ; copy 5,4 to the screen memory
126+  8811 C5          >        push bc                     ; copy 3,2 to the screen memory
126+  8812 F5          >        push af                     ; copy 1,0 to the screen memory
126+  8813             >            DoCopy i, 16  ; copy the remaining 16 attributes over to the row
126+  8813             >        ; we move the stack pointer to our attribute buffer, with our offset row and columnStart
126+  8813 31 F5 82    >        ld sp, AttributeBuffer + (i * 32) + 16
126+  8816             >        ; now we start popping the attributes off the 'stack'
126+  8816 F1          >        pop af                      ; 1,0
126+  8817 C1          >        pop bc                      ; 3,2
126+  8818 D1          >        pop de                      ; 5,4
126+  8819 E1          >        pop hl                      ; 7,6
126+  881A             >
126+  881A             >        ; oops, we've run out of registers, so we need to swap to alternate registers
126+  881A 08          >        ex af, af'                  ; swap af with af'
126+  881B D9          >        exx
126+  881C             >
126+  881C             >        ; carry on popping
126+  881C F1          >        pop af                      ; 9,8
126+  881D C1          >        pop bc                      ; 11,10
126+  881E D1          >        pop de                      ; 13,12
126+  881F E1          >        pop hl                      ; 15,14
126+  8820             >
126+  8820             >        ; we move the stack pointer to the attribute screen memory, with our offset row and columnStart
126+  8820             >        ; as well as including the 16 bytes that we popped off the buffer stack and stored
126+  8820 31 00 5B    >        ld sp, $5800 + (i * 32) + 16 + 16
126+  8823             >
126+  8823             >        ; we push back onto the screen memory stack in reverse order
126+  8823 E5          >        push hl                     ; copy 15,14 to the screen memory
126+  8824 D5          >        push de                     ; copy 13,12 to the screen memory
126+  8825 C5          >        push bc                     ; copy 11,10 to the screen memory
126+  8826 F5          >        push af                     ; copy 9,8 to the screen memory
126+  8827             >
126+  8827             >        ; swap back to the original registers
126+  8827 08          >        ex af, af'
126+  8828 D9          >        exx
126+  8829             >
126+  8829 E5          >        push hl                     ; copy 7,6 to the screen memory
126+  882A D5          >        push de                     ; copy 5,4 to the screen memory
126+  882B C5          >        push bc                     ; copy 3,2 to the screen memory
126+  882C F5          >        push af                     ; copy 1,0 to the screen memory
126+  882D             >        endr
127+  882D
128+  882D                ; Restore the stack pointer from memory
129+  882D ED 7B 03 80    ld sp, (CopyOfStackPointer)
130+  8831
131+  8831                ; Return from the subroutine
132+  8831 C9             ret
133+  8832
# file closed: /Users/darren/dev/spectrum/zx/project/src/library/doubleBufferAttributes.asm
 20   8832                include "library/colours.asm"
# file opened: /Users/darren/dev/spectrum/zx/project/src/library/colours.asm
  1+  8832              ; *********************************************************************************************************************
  2+  8832              ; Author:  Darren Bowles
  3+  8832              ; Date:    2020-05-03
  4+  8832              ; Purpose: This is currently just colour constants for the ZX Spectrum
  5+  8832              ; *********************************************************************************************************************
  6+  8832
  7+  8832
  8+  8832              STABLE:         equ 0;            %00000000
  9+  8832              FLASHING:       equ 128;          %10000000
 10+  8832
 11+  8832              DULL:           equ 0;            %00000000
 12+  8832              BRIGHT:         equ 64;           %01000000
 13+  8832
 14+  8832              WHITE_PAPER:    equ 56;           %00111000
 15+  8832              YELLOW_PAPER:   equ 48;           %00110000
 16+  8832              CYAN_PAPER:     equ 40;           %00101000
 17+  8832              GREEN_PAPER:    equ 32;           %00100000
 18+  8832              MAGENTA_PAPER:  equ 24;           %00011000
 19+  8832              RED_PAPER:      equ 16;           %00010000
 20+  8832              BLUE_PAPER:     equ 8;            %00001000
 21+  8832              BLACK_PAPER:    equ 0;            %00000000
 22+  8832
 23+  8832              WHITE_INK:      equ 7;            %00000111
 24+  8832              YELLOW_INK:     equ 6;            %00000110
 25+  8832              CYAN_INK:       equ 5;            %00000101
 26+  8832              GREEN_INK:      equ 4;            %00000100
 27+  8832              MAGENTA_INK:    equ 3;            %00000011
 28+  8832              RED_INK:        equ 2;            %00000010
 29+  8832              BLUE_INK:       equ 1;            %00000001
 30+  8832              BLACK_INK:      equ 0;            %00000000
# file closed: /Users/darren/dev/spectrum/zx/project/src/library/colours.asm
 21   8832                include "music.asm"
# file opened: /Users/darren/dev/spectrum/zx/project/src/music.asm
  1+  8832
  2+  8832                include "library/music.asm"
# file opened: /Users/darren/dev/spectrum/zx/project/src/library/music.asm
  1++ 8832              ; *********************************************************************************************************************
  2++ 8832              ; Author:  Darren Bowles
  3++ 8832              ; Date:    2020-05-03
  4++ 8832              ; Purpose: Simple music
  5++ 8832              ; *********************************************************************************************************************
  6++ 8832
  7++ 8832              ; Define the note frequencies
  8++ 8832              noteC: equ 0x30
  9++ 8832              noteD: equ 0x34
 10++ 8832              noteE: equ 0x38
 11++ 8832              noteF: equ 0x3C
 12++ 8832              noteG: equ 0x40
 13++ 8832              noteA: equ 0x44
 14++ 8832              noteB: equ 0x48
 15++ 8832
 16++ 8832              ; Define the note durations
 17++ 8832              durationWhole: equ 32
 18++ 8832              durationHalf: equ 16
 19++ 8832              durationQuarter: equ 8
 20++ 8832              durationEighth: equ 4
 21++ 8832
 22++ 8832
 23++ 8832              loadNote:
 24++ 8832
 25++ 8832                ; increment the in game music note index
 26++ 8832 3A 63 88       ld a, (currentNote)
 27++ 8835 3C             inc a
 28++ 8836 32 63 88       ld (currentNote), a
 29++ 8839
 30++ 8839
 31++ 8839                ; this is like multiply by 128
 32++ 8839 E6 7E          and 126
 33++ 883B 0F             rrca
 34++ 883C
 35++ 883C 5F             ld e, a
 36++ 883D 16 00          ld d, 0
 37++ 883F
 38++ 883F 21 64 88       ld hl, tune
 39++ 8842 19             add hl, de
 40++ 8843
 41++ 8843 3E 07          ld a,7 ; pitch
 42++ 8845 07             rlca ; multiply by 2
 43++ 8846 07             rlca ; multiply by 4
 44++ 8847
 45++ 8847 D6 1C          sub 28
 46++ 8849 ED 44          neg ; make it positive
 47++ 884B
 48++ 884B 86             add a, (hl) ; add the entry from the tune data for the current note
 49++ 884C 57             ld d,a ; store the pitch in d
 50++ 884D
 51++ 884D 3E 00          ld a,0 ; border colour
 52++ 884F
 53++ 884F 5A             ld e, d ; initialise the pitch delay counter
 54++ 8850 01 0E 00       ld bc, 14 ; initialise the duration delay counters in b (0) and c(3)
 55++ 8853              .noise:
 56++ 8853 D3 FE          out (254), a ; make a noise
 57++ 8855 1D             dec e
 58++ 8856 20 03          jr nz, .here
 59++ 8858 5A             ld e,d
 60++ 8859 EE 18          xor 24
 61++ 885B              .here:
 62++ 885B 10 F6          djnz .noise
 63++ 885D 0D             dec c
 64++ 885E 20 F3          jr nz, .noise
 65++ 8860
 66++ 8860
 67++ 8860 C9             ret
 68++ 8861
 69++ 8861
 70++ 8861              noteDuration:
 71++ 8861 00 00          dw 0 ; Variable to store the remaining duration of the current note
 72++ 8863              currentNote:
 73++ 8863 00             db 0 ; Variable to store the current note being played
 74++ 8864
 75++ 8864
 76++ 8864              ; Constants for musical notes
 77++ 8864              Pause     equ 0       ; Pause or rest
 78++ 8864              C4 EQU 64
 79++ 8864              CSharp4 EQU 68
 80++ 8864              D4 EQU 72
 81++ 8864              DSharp4 EQU 76
 82++ 8864              E4 EQU 81
 83++ 8864              F4 EQU 86
 84++ 8864              FSharp4 EQU 91
 85++ 8864              G4 EQU 96
 86++ 8864              GSharp4 EQU 102
 87++ 8864              A4 EQU 108
 88++ 8864              ASharp4 EQU 114
 89++ 8864              B4 EQU 120
 90++ 8864              C5 EQU 128
 91++ 8864              CSharp5 EQU 136
 92++ 8864              D5 EQU 144
 93++ 8864              DSharp5 EQU 152
 94++ 8864              E5 EQU 161
 95++ 8864              F5 EQU 170
 96++ 8864              FSharp5 EQU 180
 97++ 8864              G5 EQU 192
 98++ 8864              GSharp5 EQU 204
 99++ 8864              A5 EQU 216
100++ 8864              ASharp5 EQU 229
101++ 8864              B5 EQU 242
102++ 8864              C6 EQU 255
103++ 8864
104++ 8864
105++ 8864
106++ 8864
107++ 8864              ; Melody data
108++ 8864
109++ 8864              tune:
110++ 8864                ; db 128, 102, 86, 86, 171, 43
111++ 8864                ; db 43
112++ 8864                ; db 171
113++ 8864                ; db 51
114++ 8864                ; db 51
115++ 8864                ; db 171
116++ 8864                ; db 128
117++ 8864                ; db 128
118++ 8864                ; db 102
119++ 8864                ; db 86
120++ 8864                ; db 96
121++ 8864                ; db 171
122++ 8864                ; db 43
123++ 8864                ; db 43
124++ 8864                ; db 171
125++ 8864                ; db 48
126++ 8864                ; db 48
127++ 8864                ; db 171
128++ 8864                ; db 136
129++ 8864                ; db 136
130++ 8864                ; db 114
131++ 8864                ; db 76
132++ 8864                ; db 76
133++ 8864                ; db 171
134++ 8864                ; db 38
135++ 8864                ; db 38
136++ 8864                ; db 171
137++ 8864                ; db 48
138++ 8864                ; db 48
139++ 8864                ; db 171
140++ 8864                ; db 136
141++ 8864                ; db 136
142++ 8864                ; db 114
143++ 8864                ; db 76
144++ 8864                ; db 76
145++ 8864                ; db 171
146++ 8864                ; db 38
147++ 8864                ; db 38
148++ 8864                ; db 171
149++ 8864                ; db 51
150++ 8864                ; db 51
151++ 8864                ; db 171
152++ 8864                ; db 128
153++ 8864                ; db 128
154++ 8864                ; db 102
155++ 8864                ; db 86
156++ 8864                ; db 64
157++ 8864                ; db 128
158++ 8864                ; db 32
159++ 8864                ; db 32
160++ 8864                ; db 128
161++ 8864                ; db 43
162++ 8864                ; db 43
163++ 8864                ; db 128
164++ 8864                ; db 128
165++ 8864                ; db 128
166++ 8864                ; db 102
167++ 8864                ; db 86
168++ 8864                ; db 64
169++ 8864                ; db 128
170++ 8864                ; db 32
171++ 8864                ; db 32
172++ 8864                ; db 128
173++ 8864                ; db 38
174++ 8864                ; db 38
175++ 8864                ; db 0
176++ 8864                ; db 114
177++ 8864                ; db 114
178++ 8864                ; db 96
179++ 8864                ; db 76
180++ 8864                ; db 76
181++ 8864                ; db 76
182++ 8864                ; db 76
183++ 8864                ; db 76
184++ 8864                ; db 91
185++ 8864                ; db 86
186++ 8864                ; db 51
187++ 8864                ; db 51
188++ 8864                ; db 51
189++ 8864                ; db 51
190++ 8864                ; db 64
191++ 8864                ; db 102
192++ 8864                ; db 102
193++ 8864                ; db 114
194++ 8864                ; db 76
195++ 8864                ; db 86
196++ 8864                ; db 128
197++ 8864                ; db 128
198++ 8864                ; db 128
199++ 8864                ; db 128
200++ 8864
201++ 8864                ; in the hall of the mountain king
202++ 8864                ; db C5,ASharp4,GSharp4,G4,F4,GSharp4,F4,F4,E4,G4,E4,E4,F4,GSharp4,F4,F4
203++ 8864                ; db C5,ASharp4,GSharp4,G4,F4,GSharp4,F4,F4,E4,G4,E4,E4,F4,F4,F4,F4
204++ 8864                ; db C5,ASharp4,GSharp4,G4,F4,GSharp4,F4,F4,E4,G4,E4,E4,F4,GSharp4,F4,F4
205++ 8864                ; db C5,ASharp4,GSharp4,G4,F4,GSharp4,F4,C4,F4,GSharp4,C5,GSharp4,F4,F4,F4,F4
206++ 8864
207++ 8864                ; if I were a rich man
208++ 8864 56 60 56 60    db F4,G4,F4,G4,GSharp4,GSharp4,C5,C5,C5,C5,GSharp4,G4,F4,G4,F4,G4
208++ 8868 66 66 80 80
208++ 886C 80 80 66 60
208++ 8870 56 60 56 60
209++ 8874 66 60 56 4C    db GSharp4,G4,F4,DSharp4,D4,DSharp4,D4,DSharp4,F4,F4,F4,F4,F4,F4,F4,F4
209++ 8878 48 4C 48 4C
209++ 887C 56 56 56 56
209++ 8880 56 56 56 56
210++ 8884 40 40 40 40    db C4,C4,C4,C4,CSharp4,CSharp4,DSharp4,DSharp4,F4,G4,GSharp4,G4,F4,F4,GSharp4,GSharp4
210++ 8888 44 44 4C 4C
210++ 888C 56 60 66 60
210++ 8890 56 56 66 66
211++ 8894 51 56 60 56    db E4,F4,G4,F4,E4,E4,G4,G4,C4,C4,C4,C4,C4,C4,C4,C4
211++ 8898 51 51 60 60
211++ 889C 40 40 40 40
211++ 88A0 40 40 40 40
# file closed: /Users/darren/dev/spectrum/zx/project/src/library/music.asm
  3+  88A4
  4+  88A4              ; Define the tune data
  5+  88A4              tuneData:
  6+  88A4 30 20          defb noteC, durationWhole
  7+  88A6 34 08          defb noteD, durationQuarter
  8+  88A8 38 08          defb noteE, durationQuarter
  9+  88AA 3C 08          defb noteF, durationQuarter
 10+  88AC 40 08          defb noteG, durationQuarter
 11+  88AE 44 08          defb noteA, durationQuarter
 12+  88B0 48 08          defb noteB, durationQuarter
 13+  88B2 60 10          defb noteC*2, durationHalf
 14+  88B4 48 08          defb noteB, durationQuarter
 15+  88B6 44 08          defb noteA, durationQuarter
 16+  88B8 40 08          defb noteG, durationQuarter
 17+  88BA 3C 08          defb noteF, durationQuarter
 18+  88BC 38 08          defb noteE, durationQuarter
 19+  88BE 34 08          defb noteD, durationQuarter
 20+  88C0 30 10          defb noteC, durationHalf
 21+  88C2 00             defb 0 ; End of tune marker
 22+  88C3
# file closed: /Users/darren/dev/spectrum/zx/project/src/music.asm
 22   88C3
 23   88C3              ; store the previous timer value
 24   88C3 00           previousTimer: defb 0
 25   88C4
 26   88C4              ; directions
 27   88C4              up: equ 1
 28   88C4              down: equ 2
 29   88C4              left: equ 4
 30   88C4              right: equ 8
 31   88C4
 32   88C4              ; well, just blobs of colour at the moment
 33   88C4              ; direction, x, y, colour
 34   88C4              aliens:
 35   88C4 08 00 00 38    db right, 0,0, WHITE_PAPER
 36   88C8 02 00 00 38    db down, 0, 0, WHITE_PAPER
 37   88CC 04 1F 17 38    db left, 31, 23, WHITE_PAPER
 38   88D0 02 1F 00 38    db down, 31,0, WHITE_PAPER
 39   88D4 01 1F 17 38    db up, 31, 23, WHITE_PAPER
 40   88D8 08 08 17 38    db right, 8,23, WHITE_PAPER
 41   88DC 0A 0F 10 28    db right + down, 15, 16, CYAN_PAPER
 42   88E0 04 03 04 28    db left, 3,4, CYAN_PAPER
 43   88E4 08 01 02 28    db right, 1,2, CYAN_PAPER
 44   88E8 0A 0A 0A 28    db right + down, 10, 10, CYAN_PAPER
 45   88EC 02 14 14 28    db down, 20, 20, CYAN_PAPER
 46   88F0 01 15 14 28    db up, 21,20, CYAN_PAPER
 47   88F4 06 20 14 18    db down + left, 32, 20, MAGENTA_PAPER
 48   88F8 0A 05 06 28    db right + down, 5, 6  , CYAN_PAPER
 49   88FC 04 0D 0E 28    db left, 13,14, CYAN_PAPER
 50   8900 08 0B 16 28    db right, 11,22, CYAN_PAPER
 51   8904 0A 01 01 28    db right + down, 1, 1, CYAN_PAPER
 52   8908 02 02 02 28    db down, 2, 2, CYAN_PAPER
 53   890C 01 0B 14 28    db up, 11,20, CYAN_PAPER
 54   8910 06 16 0A 28    db down + left, 22, 10, CYAN_PAPER
 55   8914 06 20 00 18    db down + left, 32, 0, MAGENTA_PAPER
 56   8918 06 1E 02 18    db down + left, 30, 2, MAGENTA_PAPER
 57   891C 06 1C 04 18    db down + left, 28, 4, MAGENTA_PAPER
 58   8920 01 04 17 30    db up, 4, 23, YELLOW_PAPER
 59   8924 01 05 17 30    db up, 5, 23, YELLOW_PAPER
 60   8928 02 0A 00 18    db down, 10, 0, MAGENTA_PAPER
 61   892C 02 0B 00 18    db down, 11, 0, MAGENTA_PAPER
 62   8930 01 0F 17 30    db up, 15, 23, YELLOW_PAPER
 63   8934 01 10 17 30    db up, 16, 23, YELLOW_PAPER
 64   8938 02 11 00 20    db down, 17, 0, GREEN_PAPER
 65   893C 02 12 00 20    db down, 18, 0, GREEN_PAPER
 66   8940 04 20 0A 10    db left, 32, 10, RED_PAPER
 67   8944 04 20 0B 10    db left, 32, 11, RED_PAPER
 68   8948 08 00 0A 10    db right, 0, 10, RED_PAPER
 69   894C 08 00 0B 10    db right, 0, 11, RED_PAPER
 70   8950 02 0F 00 10    db down, 15, 0, RED_PAPER
 71   8954 02 10 00 10    db down, 16, 0, RED_PAPER
 72   8958 01 0F 17 10    db up, 15, 23, RED_PAPER
 73   895C 01 10 17 10    db up, 16, 23, RED_PAPER
 74   8960 06 1C 00 08    db down + left, 28, 0, BLUE_PAPER
 75   8964 06 1D 01 08    db down + left, 29, 1, BLUE_PAPER
 76   8968 06 1E 02 08    db down + left, 30, 2, BLUE_PAPER
 77   896C
 78   896C              numberOfAliens: equ ($ - aliens) / 4
 79   896C
 80   896C              start:
 81   896C C3 A4 89       jp myStart
 82   896F                ; This section of code sets up the IM2 interrupt vector table and enables interrupts.
 83   896F
 84   896F                ; Disable interrupts
 85   896F F3             di
 86   8970
 87   8970                ; Load the address of the IM2 interrupt vector table into DE
 88   8970 11 00 FE       ld de, IM2_TABLE
 89   8973
 90   8973                ; Load the address of the IM2 interrupt handler into HL
 91   8973 21 FD FD       ld hl, IM2_VECTOR
 92   8976
 93   8976                ; Load the value of D into A and set the interrupt mode to 2
 94   8976 7A             ld a,d
 95   8977 ED 47          ld i,a
 96   8979 ED 5E          im 2
 97   897B
 98   897B                ; Fill the IM2 interrupt vector table with the address of the IM2 interrupt handler
 99   897B              .fill_loop:
100   897B 7D             ld a,l
101   897C 12             ld (de),a
102   897D 1C             inc e
103   897E C2 7B 89       jp nz, .fill_loop
104   8981 14             inc d
105   8982 12             ld (de), a
106   8983
107   8983              ; Set the IM2 interrupt vector to point to the IM2 interrupt handler
108   8983 36 C3          ld (hl),$c3
109   8985 2C             inc l
110   8986 36 DD          ld (hl),low im2_handler
111   8988 2C             inc l
112   8989 36 8A          ld (hl),high im2_handler
113   898B
114   898B              ; Enable interrupts
115   898B FB             ei
116   898C
117   898C
118   898C
119   898C              ; gameLoop - Main game loop
120   898C              gameLoop:
121   898C                ; Wait for 2 ticks
122   898C              .waitForTwoTicks:
123   898C                ; Load the previous timer value into HL
124   898C 21 C3 88       ld hl, previousTimer
125   898F
126   898F                ; Get the current timer value and subtract the previous timer value
127   898F 3A 78 5C       ld a, (23672)
128   8992 96             sub (hl)
129   8993
130   8993                ; Check if we've waited for 2 ticks
131   8993              .checkIfTwoTicksWaited:
132   8993 FE 03          cp 3
133   8995 30 03          jr nc, .twoTicksWaited ; no more delay
134   8997
135   8997                    ; call loadNote
136   8997
137   8997                ; If we haven't waited for 2 ticks yet, jump back to the start of the loop
138   8997 C3 8C 89       jp .waitForTwoTicks
139   899A
140   899A              .twoTicksWaited:
141   899A                ; If we've waited for 2 ticks, store the current timer value as the previous timer value
142   899A 3A 78 5C       ld a, (23672)
143   899D 32 C3 88       ld (previousTimer), a
144   89A0
145   89A0
146   89A0
147   89A0                ; set the border colour to black
148   89A0 3E 00          ld a, 0
149   89A2 D3 FE          out (254), a
150   89A4
151   89A4
152   89A4              myStart:
153   89A4                ; Loop through the aliens table and show each alien
154   89A4
155   89A4 CD 32 88       call loadNote
156   89A7 DD 21 C4 88    ld ix, aliens
157   89AB 06 2A          ld b, numberOfAliens
158   89AD 0E 00          ld c, 0
159   89AF              .showAliensLoop:
160   89AF C5             push bc
161   89B0
162   89B0 CD E2 89       call showAlien
163   89B3
164   89B3 C1             pop bc
165   89B4
166   89B4                ; Move onto the next alien in the table
167   89B4 11 04 00       ld de, 4 ; size of the table entry
168   89B7 DD 19          add ix, de
169   89B9 10 F4          djnz .showAliensLoop
170   89BB
171   89BB              .display:
172   89BB                ; Copy the attributes buffer to the screen attributes
173   89BB CD 49 83       call copyScreenAttributes
174   89BE
175   89BE                ; Undraw the aliens (and move them)
176   89BE CD C4 89       call undrawAliens
177   89C1
178   89C1                ; Jump back to the start of the loop
179   89C1                ;jp gameLoop
180   89C1 C3 A4 89       jp myStart
181   89C4
182   89C4
183   89C4              ; undrawAliens - Undraws the alien and then moves it
184   89C4              undrawAliens:
185   89C4 DD 21 C4 88    ld ix, aliens ; Load the address of the aliens table into IX
186   89C8 06 2A          ld b, numberOfAliens ; Load the number of aliens into B
187   89CA 0E 00          ld c, 0 ; Initialize the loop counter
188   89CC
189   89CC              .loop:
190   89CC C5             push bc ; Save the loop counter on the stack
191   89CD
192   89CD                ; Get the address of the current alien
193   89CD CD EA 89       call getAlienAddress
194   89D0
195   89D0                ; Set the paper color to black to 'undraw' the alien
196   89D0 3E 00          ld a, BLACK_PAPER
197   89D2 77             ld (hl), a
198   89D3
199   89D3                ; Move the alien
200   89D3 CD FA 89       call moveAlien
201   89D6
202   89D6                ; Check if the alien is within the screen bounds
203   89D6 CD 2F 8A       call checkBounds
204   89D9
205   89D9 C1             pop bc ; Restore the loop counter from the stack
206   89DA
207   89DA                ; Move onto the next alien in the table
208   89DA 11 04 00       ld de, 4 ; size of the table entry
209   89DD DD 19          add ix, de
210   89DF 10 EB          djnz .loop ; Decrement B and jump back to the start of the loop if B is not zero
211   89E1
212   89E1                ; Return from the subroutine
213   89E1 C9             ret
214   89E2
215   89E2              ; showAlien - Displays the alien on the screen
216   89E2              showAlien:
217   89E2                ; Get the address of the current alien
218   89E2 CD EA 89       call getAlienAddress
219   89E5
220   89E5                ; Get the color of the alien from the table and put it in the buffer
221   89E5 DD 7E 03       ld a, (ix+3)
222   89E8 77             ld (hl), a
223   89E9
224   89E9                ; Return from the subroutine
225   89E9 C9             ret
226   89EA
227   89EA              ; getAlienAddress - Gets the address of the current alien in the attribute buffer
228   89EA              getAlienAddress:
229   89EA                ; Check if the alien is disabled
230   89EA DD 7E 00       ld a, (ix) ; Load the status/direction byte into A
231   89ED FE FF          cp 255 ; Check if it's equal to 255 (disabled)
232   89EF C8             ret z ; If it's disabled, return
233   89F0
234   89F0                ; Get the x and y coordinates of the alien
235   89F0 DD 46 01       ld b, (ix+1) ; Load the x coordinate into B
236   89F3 DD 4E 02       ld c, (ix+2) ; Load the y coordinate into C
237   89F6
238   89F6                ; Calculate the address of the alien in the attribute buffer
239   89F6 CD 35 83       call CalculateAttributeBufferAddress
240   89F9
241   89F9                ; Return from the subroutine with the address in HL
242   89F9 C9             ret
243   89FA
244   89FA              ; moveAlien - Moves the alien in the direction specified by its status byte
245   89FA              moveAlien:
246   89FA                ; Check if the alien is moving up
247   89FA DD 7E 00       ld a, (ix)
248   89FD E6 01          and up
249   89FF C4 1B 8A       call nz, moveAlienUp
250   8A02
251   8A02                ; Check if the alien is moving down
252   8A02 DD 7E 00       ld a, (ix)
253   8A05 E6 02          and down
254   8A07 C4 20 8A       call nz, moveAlienDown
255   8A0A
256   8A0A                ; Check if the alien is moving left
257   8A0A DD 7E 00       ld a, (ix)
258   8A0D E6 04          and left
259   8A0F C4 25 8A       call nz, moveAlienLeft
260   8A12
261   8A12                ; Check if the alien is moving right
262   8A12 DD 7E 00       ld a, (ix)
263   8A15 E6 08          and right
264   8A17 C4 2A 8A       call nz, moveAlienRight
265   8A1A
266   8A1A C9             ret
267   8A1B
268   8A1B              ; moveAlienUp - Moves the alien up by decrementing its y coordinate
269   8A1B              moveAlienUp:
270   8A1B 0D             dec c ; Decrement the y coordinate
271   8A1C DD 71 02       ld (ix+2), c ; Store the new y coordinate in the aliens table
272   8A1F C9             ret
273   8A20
274   8A20              ; moveAlienDown - Moves the alien down by incrementing its y coordinate
275   8A20              moveAlienDown:
276   8A20 0C             inc c ; Increment the y coordinate
277   8A21 DD 71 02       ld (ix+2), c ; Store the new y coordinate in the aliens table
278   8A24 C9             ret
279   8A25
280   8A25              ; moveAlienLeft - Moves the alien left by decrementing its x coordinate
281   8A25              moveAlienLeft:
282   8A25 05             dec b ; Decrement the x coordinate
283   8A26 DD 70 01       ld (ix+1), b ; Store the new x coordinate in the aliens table
284   8A29 C9             ret
285   8A2A
286   8A2A              ; moveAlienRight - Moves the alien right by incrementing its x coordinate
287   8A2A              moveAlienRight:
288   8A2A 04             inc b ; Increment the x coordinate
289   8A2B DD 70 01       ld (ix+1), b ; Store the new x coordinate in the aliens table
290   8A2E C9             ret
291   8A2F
292   8A2F              checkBounds:
293   8A2F                ; the position is stored in bc
294   8A2F DD 7E 00       ld a, (ix) ;  load the direction / status into D
295   8A32
296   8A32              .checkRight:
297   8A32                ; are we going right
298   8A32 CB 5F          bit 3, a
299   8A34 28 0F          jr z, .checkLeft
300   8A36                ; if we are going right, check if we've hit the right boundary
301   8A36 78             ld a, b ; load the X position into A
302   8A37 FE 1F          cp 31                    ; compare with the right boundary
303   8A39 20 0A          jr nz, .checkLeft        ; if A < 31, we haven't hit the right boundary
304   8A3B DD 7E 00       ld a, (ix)
305   8A3E E6 F7          and 255 - right
306   8A40 F6 04          or left
307   8A42 DD 77 00       ld (ix), a
308   8A45
309   8A45
310   8A45              .checkLeft:
311   8A45                ; are we going left
312   8A45 DD 7E 00       ld a, (ix) ;  load the direction / status into D
313   8A48 CB 57          bit 2, a
314   8A4A 28 0F          jr z, .checkUp
315   8A4C                ; if we are going left, check if we've hit the left boundary
316   8A4C 78             ld a, b ; load the X position into A
317   8A4D FE 00          cp 0
318   8A4F 20 0A          jr nz, .checkUp
319   8A51 DD 7E 00       ld a, (ix)
320   8A54 E6 FB          and 255 - left
321   8A56 F6 08          or right
322   8A58 DD 77 00       ld (ix), a
323   8A5B
324   8A5B              .checkUp:
325   8A5B                ; are we going up
326   8A5B DD 7E 00       ld a, (ix) ;  load the direction / status into D
327   8A5E CB 47          bit 0, a
328   8A60 28 12          jr z, .checkDown
329   8A62                ; if we are going up, check if we've hit the top boundary
330   8A62 79             ld a, c
331   8A63 FE 00          cp 0
332   8A65 20 0D          jr nz, .checkDown
333   8A67 DD 7E 00       ld a, (ix)
334   8A6A E6 FE          and 255 - up
335   8A6C F6 02          or down
336   8A6E DD 77 00       ld (ix), a
337   8A71 C3 8A 8A       jp .done
338   8A74
339   8A74              .checkDown:
340   8A74                ; are we going down
341   8A74 DD 7E 00       ld a, (ix) ;  load the direction / status into D
342   8A77 CB 4F          bit 1, a
343   8A79 28 0F          jr z, .done
344   8A7B                ; if we are going down, check if we've hit the bottom boundary
345   8A7B 79             ld a, c
346   8A7C FE 17          cp 23                    ; compare with the bottom boundary
347   8A7E 20 0A          jr nz, .done             ; if A < 23, we haven't hit the bottom boundary
348   8A80 DD 7E 00       ld a, (ix)
349   8A83 E6 FD          and 255 - down
350   8A85 F6 01          or up
351   8A87 DD 77 00       ld (ix), a
352   8A8A              .done:
353   8A8A C9             ret
354   8A8B
355   8A8B
356   8A8B FE 1F          cp 31                    ; compare with the right boundary
357   8A8D 30 3B          jr nc, hitRightBoundary  ; if A >= 31, we've hit the right boundary
358   8A8F B7             or a                     ; check if A is 0 (the left boundary)
359   8A90 28 25          jr z, hitLeftBoundary    ; if A == 0, we've hit the left boundary
360   8A92              checkUpperLowerScreenBounds:
361   8A92                                   ; move to Y position in memory
362   8A92 79             ld a, c               ; load the Y position into A
363   8A93 FE 17          cp 23                    ; compare with the bottom boundary
364   8A95 30 12          jr nc, hitBottomBoundary ; if A >= 23, we've hit the bottom boundary
365   8A97 B7             or a                     ; check if A is 0 (the top boundary)
366   8A98 28 01          jr z, hitTopBoundary     ; if A == 0, we've hit the top boundary
367   8A9A
368   8A9A C9             ret
369   8A9B
370   8A9B              hitTopBoundary:
371   8A9B DD 7E 00       ld a, (ix)
372   8A9E
373   8A9E CB 47          bit 0, a            ; Check if the "down" bit is set in A.
374   8AA0 C8             ret z  ; If the "down" bit is not set, we don't need to change the direction.
375   8AA1
376   8AA1
377   8AA1 E6 FE          and 255 - up
378   8AA3 F6 02          or down
379   8AA5 DD 77 00       ld (ix), a
380   8AA8 C9             ret
381   8AA9
382   8AA9              ; This function is called when the alien hits the bottom boundary of the screen.
383   8AA9              ; It plays a sound effect, changes the direction of the alien to move up, and returns.
384   8AA9
385   8AA9              hitBottomBoundary:
386   8AA9 DD 7E 00       ld a, (ix)          ; Load the current direction of the alien into A.
387   8AAC
388   8AAC CB 4F          bit 1, a            ; Check if the "down" bit is set in A.
389   8AAE C8             ret z  ; If the "down" bit is not set, we don't need to change the direction.
390   8AAF
391   8AAF
392   8AAF E6 FD          and 255 - down      ; Clear the "down" bit in A by ANDing it with the bitwise complement of "down".
393   8AB1 F6 01          or up               ; Set the "up" bit in A by ORing it with "up".
394   8AB3 DD 77 00       ld (ix), a          ; Store the new direction back into memory.
395   8AB6 C9             ret                 ; Return from the function.
396   8AB7
397   8AB7              hitLeftBoundary:
398   8AB7 DD 7E 00       ld a, (ix)
399   8ABA CB 5F          bit 3,a
400   8ABC CA 92 8A       jp z, checkUpperLowerScreenBounds ; If the "left" bit is not set, we don't need to change the direction.
401   8ABF E6 FB          and 255 - left
402   8AC1 F6 08          or right
403   8AC3 DD 77 00       ld (ix), a
404   8AC6 C3 92 8A       jp checkUpperLowerScreenBounds
405   8AC9 C9             ret
406   8ACA              hitRightBoundary:
407   8ACA DD 7E 00       ld a, (ix)
408   8ACD
409   8ACD CB 67          bit 4, a ; Check if the "right" bit is set in A.
410   8ACF CA 92 8A       jp z, checkUpperLowerScreenBounds ; If the "right" bit is not set, we don't need to change the direction.
411   8AD2
412   8AD2 E6 F7          and 255 - right
413   8AD4 F6 04          or left
414   8AD6 DD 77 00       ld (ix), a
415   8AD9 C3 92 8A       jp checkUpperLowerScreenBounds
416   8ADC C9             ret
417   8ADD
418   8ADD              im2_handler:
419   8ADD F5             push af
420   8ADE C5             push bc
421   8ADF D5             push de
422   8AE0 E5             push hl
423   8AE1 08             ex af,af'
424   8AE2 D9             exx
425   8AE3 F5             push af
426   8AE4 C5             push bc
427   8AE5 D5             push de
428   8AE6 E5             push hl
429   8AE7 DD E5          push ix
430   8AE9 FD E5          push iy
431   8AEB
432   8AEB                ; play music here
433   8AEB                ; call loadNote
434   8AEB
435   8AEB                ;rst 56 ; read the keys and update clock
436   8AEB 2A 78 5C       ld hl, (23672)
437   8AEE 23             inc hl
438   8AEF 22 78 5C       ld (23672), hl
439   8AF2 7C             ld a,h
440   8AF3 B5             or l
441   8AF4
442   8AF4                ; ^^ this is the same as rst 56
443   8AF4
444   8AF4 FD E1          pop iy
445   8AF6 DD E1          pop ix
446   8AF8 E1             pop hl
447   8AF9 D1             pop de
448   8AFA C1             pop bc
449   8AFB F1             pop af
450   8AFC 08             ex af,af'
451   8AFD D9             exx
452   8AFE E1             pop hl
453   8AFF D1             pop de
454   8B00 C1             pop bc
455   8B01 F1             pop af
456   8B02 FB             ei
457   8B03 C9             ret
458   8B04
459   8B04
460   8B04              ; Deployment
461   8B04                savesna "myapp.sna",start  ; Save the program as a snapshot file
# file closed: /Users/darren/dev/spectrum/zx/project/src/myapp.asm
